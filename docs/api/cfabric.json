{
  "name": "cfabric",
  "kind": "module",
  "path": "",
  "docstring": {
    "summary": "Context-Fabric: A graph-based corpus engine for annotated text.",
    "description": "Context-Fabric: A graph-based corpus engine for annotated text.\n\nThis package provides tools for loading, navigating, and querying\nannotated text corpora using a graph-based data model.\n\nBasic usage:\n    >>> import cfabric\n    >>> CF = cfabric.Fabric(locations='path/to/corpus')\n    >>> api = CF.load('feature1', 'feature2')\n    >>> for node in api.F.feature1.s('value'):\n    ...     print(api.T.text(node))",
    "parsed": []
  },
  "classes": {},
  "functions": {},
  "modules": {
    "core": {
      "name": "core",
      "kind": "module",
      "path": "",
      "docstring": {
        "summary": "Core API of Context-Fabric.",
        "description": "Core API of Context-Fabric.\n\nThis module provides the main entry points for Context-Fabric:\n\n- `Fabric`: Main class for loading and managing corpora\n- `Api`: Runtime API with F, E, L, T, S, N, C accessors\n\nThe core API consists of:\n\n- `N`: see `cfabric.navigation.nodes.Nodes` (walk through nodes)\n- `F`: see `cfabric.features.node.NodeFeature` (retrieve feature values for nodes)\n- `E`: see `cfabric.features.edge.EdgeFeature` (retrieve feature values for edges)\n- `L`: see `cfabric.navigation.locality.Locality` (move between levels)\n- `T`: see `cfabric.navigation.text.Text` (get the text)\n- `S`: see `cfabric.search.search.Search` (search by templates)\n\nBased on Text-Fabric by Dirk Roorda.",
        "parsed": []
      },
      "classes": {},
      "functions": {},
      "modules": {
        "api": {
          "name": "api",
          "kind": "module",
          "path": "",
          "docstring": {
            "summary": "# The core API of CF.",
            "description": "# The core API of CF.\n\nIt provides methods to navigate nodes and edges and lookup features.",
            "parsed": []
          },
          "classes": {
            "Api": {
              "name": "Api",
              "kind": "class",
              "path": "",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "bases": [],
              "methods": {
                "Call": {
                  "name": "Call",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "Returns a sorted list of all usable, loaded computed data names.",
                    "description": "Returns a sorted list of all usable, loaded computed data names.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "list[str]"
                  },
                  "decorators": []
                },
                "Cs": {
                  "name": "Cs",
                  "kind": "function",
                  "signature": "(self, fName: str, warn: bool = True)",
                  "docstring": {
                    "summary": "Get the computed data sub API.",
                    "description": "Get the computed data sub API.\n\nIf component name is not a valid python identifier,\nor if you do not know its name in advance,\nyou can not use `C.component`, but you should use\n`Cs(component)`.\n\nParameters\n----------\nfName: string\n    The name of the feature.\nwarn: boolean, optional `True`\n    Whether to warn if the feature is not loaded.\n\nReturns\n-------\nThe feature API, or `None` if the feature is not loaded.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "fName",
                      "type": "str",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "warn",
                      "type": "bool",
                      "default": "True",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "Any"
                  },
                  "decorators": []
                },
                "Eall": {
                  "name": "Eall",
                  "kind": "function",
                  "signature": "(self, warp: bool = True)",
                  "docstring": {
                    "summary": "Returns a sorted list of all usable, loaded edge feature names.",
                    "description": "Returns a sorted list of all usable, loaded edge feature names.\n\nParameters\n----------\nwarp: boolean, optional True\n    Whether to include the warp features, i.e. `oslots`.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "warp",
                      "type": "bool",
                      "default": "True",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "list[str]"
                  },
                  "decorators": []
                },
                "Es": {
                  "name": "Es",
                  "kind": "function",
                  "signature": "(self, fName: str, warn: bool = True)",
                  "docstring": {
                    "summary": "Get the edge feature sub API.",
                    "description": "Get the edge feature sub API.\n\nIf feature name is not a valid python identifier,\nor if you do not know its name in advance,\nyou can not use `E.feature`, but you should use\n`Es(feature)`.\n\nParameters\n----------\nfName: string\n    The name of the feature.\nwarn: boolean, optional `True`\n    Whether to warn if the feature is not loaded.\n\nReturns\n-------\nThe feature API, or `None` if the feature is not loaded.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "fName",
                      "type": "str",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "warn",
                      "type": "bool",
                      "default": "True",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "Any"
                  },
                  "decorators": []
                },
                "Fall": {
                  "name": "Fall",
                  "kind": "function",
                  "signature": "(self, warp: bool = True)",
                  "docstring": {
                    "summary": "Returns a sorted list of all usable, loaded node feature names.",
                    "description": "Returns a sorted list of all usable, loaded node feature names.\n\nParameters\n----------\nwarp: boolean, optional True\n    Whether to include the warp features, i.e. `otype`.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "warp",
                      "type": "bool",
                      "default": "True",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "list[str]"
                  },
                  "decorators": []
                },
                "Fs": {
                  "name": "Fs",
                  "kind": "function",
                  "signature": "(self, fName: str, warn: bool = True)",
                  "docstring": {
                    "summary": "Get the node feature sub API.",
                    "description": "Get the node feature sub API.\n\nIf feature name is not a valid python identifier,\nor if you do not know its name in advance,\nyou can not use `F.feature`, but you should use\n`Fs(feature)`.\n\nParameters\n----------\nfName: string\n    The name of the feature.\nwarn: boolean, optional `True`\n    Whether to warn if the feature is not loaded.\n\nReturns\n-------\nThe feature API, or `None` if the feature is not loaded.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "fName",
                      "type": "str",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "warn",
                      "type": "bool",
                      "default": "True",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "Any"
                  },
                  "decorators": []
                },
                "__init__": {
                  "name": "__init__",
                  "kind": "function",
                  "signature": "(self, CF: Fabric)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "CF",
                      "type": "Fabric",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "ensureLoaded": {
                  "name": "ensureLoaded",
                  "kind": "function",
                  "signature": "(self, features: str | Iterable[str])",
                  "docstring": {
                    "summary": "Checks if features are loaded and if not loads them.",
                    "description": "Checks if features are loaded and if not loads them.\n\nAll features in question will be made available to the core API.\n\nParameters\n----------\nfeatures: string | iterable of strings\n    It is a string containing space separated feature names,\n    or an iterable of feature names.\n    The feature names are just the names of `.tf` files\n    without directory information and without extension.\n\nReturns\n-------\nset\n    The names of the features in question as a set of strings.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "features",
                      "type": "str | Iterable[str]",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "set[str]"
                  },
                  "decorators": []
                },
                "footprint": {
                  "name": "footprint",
                  "kind": "function",
                  "signature": "(self, recompute: bool = False, bySize: bool = True)",
                  "docstring": {
                    "summary": "Computes the memory footprint in RAM of the loaded CF data.",
                    "description": "Computes the memory footprint in RAM of the loaded CF data.\n\nThis includes the pre-computed data.\n\nParameters\n----------\nrecompute: boolean, optional False\n    The function looks first for earlier computed size data.\n    If that is found, it will be used, and no size computation will take place.\n    Unless this parameter is True.\n    If no earlier computed size data is found, sizes will be computed anyway.\nbySize: boolean, optional True\n    Whether to sort the features by the size they occupy in RAM.\n    If False, the features will be sorted alphabetically.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "recompute",
                      "type": "bool",
                      "default": "False",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "bySize",
                      "type": "bool",
                      "default": "True",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "isLoaded": {
                  "name": "isLoaded",
                  "kind": "function",
                  "signature": "(self, features: Iterable[str] | str | None = None, pretty: bool = True, valueType: bool = True, path: bool = False, meta: str | list[str] | bool = 'description')",
                  "docstring": {
                    "summary": "Show information about loaded features.",
                    "description": "Show information about loaded features.\n\nParameters\n----------\nfeatures: iterable | string, optional None\n    The features to get info for.\n    If absent or None: all features seen by CF.\n    If a string, it is a comma and / or space separated list of feature names.\n    Otherwise the items of the iterable are feature names.\n\npretty: boolean, optional True\n    If True, it prints an overview of all features seen by CF with\n    information about kind, type, source location and loaded status.\n    The amount of information printed can be tweaked by other parameters.\n    Otherwise, it returns this information as a dict.\n\nvalueType: boolean, optional True\n    Only relevant if `pretty=True`: whether to print the value type of\n    the values in the feature file.\n\npath: boolean, optional True\n    Only relevant if `pretty=True`: whether to print the path name of\n    the feature file.\n\nmeta: string|list|boolean, optional \"description\"\n    Only relevant if `pretty=True`: controls what metadata of the feature\n    should be printed.\n\n    If it is None, False, or the empty string or empty list:\n    no metadata will be printed.\n\n    It it is the boolean value True: all metadata will be printed.\n\n    If it is a list of key names or a string with key names\n    separated by white-space and / or commas, only these metadata keys\n    will be printed.\n\nReturns\n-------\ndict of dict\n    The features are keys, the value per feature is None or a dict with the\n    following information:\n\n    `None` if  the feature is not loaded.\n\n    If the feature is loaded:\n\n    *   `kind`: `node`, `edge`, `config`, `computed`;\n    *   `type` is the type of values: `int`, or `str` or `\"\"`;\n    *   `edgeValues`: if an edge feature it indicates whether\n        the edges have values. Otherwise `None`.\n    *   `meta`: dictionary containing the metadata of the feature\n\n    If `pretty`, nothing is returned, but the dict is pretty printed.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "features",
                      "type": "Iterable[str] | str | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "pretty",
                      "type": "bool",
                      "default": "True",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "valueType",
                      "type": "bool",
                      "default": "True",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "path",
                      "type": "bool",
                      "default": "False",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "meta",
                      "type": "str | list[str] | bool",
                      "default": "'description'",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "dict[(str, dict[(str, Any)] | None)] | None"
                  },
                  "decorators": []
                },
                "makeAvailableIn": {
                  "name": "makeAvailableIn",
                  "kind": "function",
                  "signature": "(self, scope: dict[(str, Any)])",
                  "docstring": {
                    "summary": "Exports members of the API to the global namespace.",
                    "description": "Exports members of the API to the global namespace.\n\nOnly the members whose names start with a capital are exported.\n\nIf you are working with a single data source in your program, it is a bit\ntedious to write the initial `CF.api.` or `A.api` all the time.\nBy this method you can avoid that.\n\n!!! explanation \"Longer names\"\n    There are also longer names which can be used as aliases\n    to the single capital letters.\n    This might or might not improve the readability of your program.\n\n    short name | long name\n    --- | ---\n    `N` | `Nodes`\n    `F` | `Feature`\n    `Fs` | `FeatureString`\n    `Fall` | `AllFeatures`\n    `E` | `Edge`\n    `Es` | `EdgeString`\n    `Eall`  `AllEdges`\n    `C` | `Computed`\n    `Cs`  `ComputedString`\n    `Call` | `AllComputeds`\n    `L` | `Locality`\n    `T` | `Text`\n    `S` | `Search`\n\nParameters\n----------\nscope: dict\n    A dictionary into which the members of the core API will be inserted.\n    The only sensible choice is: `globals()`.\n\nReturns\n-------\ntuple\n    A grouped list of API members that has been hoisted to the global\n    scope.\n\nNotes\n-----\n!!! explanation \"Why pass `globals()`?\"\n    Although we know it should always be `globals()`, we cannot\n    define a function that looks into the `globals()` of its caller.\n    So we have to pass it on.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "scope",
                      "type": "dict[(str, Any)]",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "list[tuple[(str, str, tuple[(str, ...)])]]"
                  },
                  "decorators": []
                }
              },
              "attributes": {
                "C": {
                  "name": "C",
                  "type": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "arguments": [],
                    "cls": "ExprCall",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "Computeds"
                    }
                  }
                },
                "CF": {
                  "name": "CF",
                  "type": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "CF"
                  }
                },
                "Computed": {
                  "name": "Computed",
                  "type": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprAttribute",
                    "values": [
                      {
                        "cls": "ExprName",
                        "member": null,
                        "name": "self"
                      },
                      {
                        "cls": "ExprName",
                        "member": null,
                        "name": "C"
                      }
                    ]
                  }
                },
                "E": {
                  "name": "E",
                  "type": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "arguments": [],
                    "cls": "ExprCall",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "EdgeFeatures"
                    }
                  }
                },
                "Edge": {
                  "name": "Edge",
                  "type": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprAttribute",
                    "values": [
                      {
                        "cls": "ExprName",
                        "member": null,
                        "name": "self"
                      },
                      {
                        "cls": "ExprName",
                        "member": null,
                        "name": "E"
                      }
                    ]
                  }
                },
                "F": {
                  "name": "F",
                  "type": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "arguments": [],
                    "cls": "ExprCall",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "NodeFeatures"
                    }
                  }
                },
                "Feature": {
                  "name": "Feature",
                  "type": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprAttribute",
                    "values": [
                      {
                        "cls": "ExprName",
                        "member": null,
                        "name": "self"
                      },
                      {
                        "cls": "ExprName",
                        "member": null,
                        "name": "F"
                      }
                    ]
                  }
                },
                "TF": {
                  "name": "TF",
                  "type": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "CF"
                  }
                },
                "ignored": {
                  "name": "ignored",
                  "type": "",
                  "docstring": {
                    "summary": "Which features were found but ignored.",
                    "description": "Which features were found but ignored.\n\nFeatures are ignored if the feature is also present in another location\nthat is loaded later.",
                    "parsed": []
                  },
                  "value": {
                    "arguments": [
                      {
                        "arguments": [
                          {
                            "cls": "ExprAttribute",
                            "values": [
                              {
                                "cls": "ExprName",
                                "member": null,
                                "name": "CF"
                              },
                              {
                                "cls": "ExprName",
                                "member": null,
                                "name": "featuresIgnored"
                              }
                            ]
                          }
                        ],
                        "cls": "ExprCall",
                        "function": {
                          "cls": "ExprName",
                          "member": null,
                          "name": "sorted"
                        }
                      }
                    ],
                    "cls": "ExprCall",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "tuple"
                    }
                  }
                }
              }
            }
          },
          "functions": {
            "addLocality": {
              "name": "addLocality",
              "kind": "function",
              "signature": "(api: Api)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "api",
                  "type": "Api",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "addNodes": {
              "name": "addNodes",
              "kind": "function",
              "signature": "(api: Api)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "api",
                  "type": "Api",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "addOtype": {
              "name": "addOtype",
              "kind": "function",
              "signature": "(api: Api)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "api",
                  "type": "Api",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "addSearch": {
              "name": "addSearch",
              "kind": "function",
              "signature": "(api: Api, silent: str = {'cls': 'ExprName', 'member': None, 'name': 'SILENT_D'})",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "api",
                  "type": "Api",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "silent",
                  "type": "str",
                  "default": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "SILENT_D"
                  },
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "addText": {
              "name": "addText",
              "kind": "function",
              "signature": "(api: Api)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "api",
                  "type": "Api",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            }
          },
          "modules": {},
          "aliases": {
            "Any": {
              "name": "Any",
              "target": "typing.Any"
            },
            "Computeds": {
              "name": "Computeds",
              "target": "cfabric.features.computed.Computeds"
            },
            "DEEP": {
              "name": "DEEP",
              "target": "cfabric.utils.logging.DEEP"
            },
            "EdgeFeatures": {
              "name": "EdgeFeatures",
              "target": "cfabric.features.edge.EdgeFeatures"
            },
            "Fabric": {
              "name": "Fabric",
              "target": "cfabric.core.fabric.Fabric"
            },
            "Iterable": {
              "name": "Iterable",
              "target": "collections.abc.Iterable"
            },
            "Locality": {
              "name": "Locality",
              "target": "cfabric.navigation.locality.Locality"
            },
            "NodeFeatures": {
              "name": "NodeFeatures",
              "target": "cfabric.features.node.NodeFeatures"
            },
            "Nodes": {
              "name": "Nodes",
              "target": "cfabric.navigation.nodes.Nodes"
            },
            "OSLOTS": {
              "name": "OSLOTS",
              "target": "cfabric.core.config.OSLOTS"
            },
            "OTYPE": {
              "name": "OTYPE",
              "target": "cfabric.core.config.OTYPE"
            },
            "SILENT_D": {
              "name": "SILENT_D",
              "target": "cfabric.utils.logging.SILENT_D"
            },
            "Search": {
              "name": "Search",
              "target": "cfabric.search.search.Search"
            },
            "TYPE_CHECKING": {
              "name": "TYPE_CHECKING",
              "target": "typing.TYPE_CHECKING"
            },
            "Text": {
              "name": "Text",
              "target": "cfabric.navigation.text.Text"
            },
            "annotations": {
              "name": "annotations",
              "target": "__future__.annotations"
            },
            "collections": {
              "name": "collections",
              "target": "collections"
            },
            "console": {
              "name": "console",
              "target": "cfabric.utils.helpers.console"
            },
            "dedent": {
              "name": "dedent",
              "target": "textwrap.dedent"
            },
            "deepSize": {
              "name": "deepSize",
              "target": "cfabric.utils.helpers.deepSize"
            },
            "fitemize": {
              "name": "fitemize",
              "target": "cfabric.utils.helpers.fitemize"
            },
            "flattenToSet": {
              "name": "flattenToSet",
              "target": "cfabric.utils.helpers.flattenToSet"
            },
            "logging": {
              "name": "logging",
              "target": "logging"
            },
            "silentConvert": {
              "name": "silentConvert",
              "target": "cfabric.utils.logging.silentConvert"
            },
            "ux": {
              "name": "ux",
              "target": "cfabric.utils.files.unexpanduser"
            },
            "wrap": {
              "name": "wrap",
              "target": "textwrap.wrap"
            }
          }
        },
        "config": {
          "name": "config",
          "kind": "module",
          "path": "",
          "docstring": {
            "summary": "Parameters for Context-Fabric.",
            "description": "Parameters for Context-Fabric.\n\nFixed values for the whole program.\nBased on Text-Fabric parameters.",
            "parsed": []
          },
          "classes": {},
          "functions": {},
          "modules": {},
          "aliases": {
            "ZIP_DEFLATED": {
              "name": "ZIP_DEFLATED",
              "target": "zipfile.ZIP_DEFLATED"
            },
            "os": {
              "name": "os",
              "target": "os"
            },
            "sys": {
              "name": "sys",
              "target": "sys"
            }
          }
        },
        "fabric": {
          "name": "fabric",
          "kind": "module",
          "path": "",
          "docstring": {
            "summary": "# Fabric",
            "description": "# Fabric\n\nThe main class that works the core API.\n\nThis module defines `Fabric`, which provides:\n- Locating and loading CF feature files\n- Compiling to and loading from .cfm format\n- Managing the core API (F, E, L, T, S, N, C)",
            "parsed": []
          },
          "classes": {
            "Fabric": {
              "name": "Fabric",
              "kind": "class",
              "path": "",
              "docstring": {
                "summary": "Initialize the core API for a corpus.",
                "description": "Initialize the core API for a corpus.\n\nTop level management of\n\n*   locating CF feature files\n*   loading and saving feature data\n*   pre-computing auxiliary data\n*   caching pre-computed and compressed data\n\nCF is initialized for a corpus.\nIt will search a set of directories and catalogue all `.tf` files it finds there.\nThese are the features you can subsequently load.\n\nHere `directories` and `subdirectories` are strings with directory names\nseparated by newlines, or iterables of directories.\n\nParameters\n----------\nlocations: string | iterable of strings, optional\n    The directories specified here are used as base locations\n    in searching for CF feature files.\n    In general, they will not searched directly, but certain subdirectories\n    of them will be searched, specified by the `modules` parameter.\n\n    Defaults:\n\n        ~/Downloads/text-fabric-data\n        ~/text-fabric-data\n        ~/github/text-fabric-data\n\n    So if you have stored your main CF dataset in\n    `text-fabric-data` in one of these directories\n    you do not have to pass a location to Fabric.\n\nmodules: string | iterable of strings\n    The directories specified in here are used as sub directories\n    appended to the directories given by the `locations` parameter.\n\n    All `.tf` files (non-recursively) in any `location/module`\n    will be added to the feature set to be loaded in this session.\n    The order in `modules` is important, because if a feature occurs in\n    multiple modules, the last one will be chosen.\n    In this way you can easily override certain features in one module\n    by features in an other module of your choice.\n\n    Default: `['']`\n\n    So if you leave it out, CF will just search the paths specified\n    in `locations`.\n\nsilent: string, optional \"auto\"\n    Verbosity level: \"verbose\", \"auto\", \"terse\", or \"deep\"\n\n_withGc: boolean, optional False\n    If False, it disables the Python garbage collector before\n    loading features. Used to experiment with performance.\n\n\n!!! note \"`otext@` in modules\"\n    If modules contain features with a name starting with `otext@`, then the format\n    definitions in these features will be added to the format definitions in the\n    regular `otext` feature (which is a `tf.parameters.WARP` feature).\n    In this way, modules that define new features for text representation,\n    also can add new formats to the Text-API.\n\nReturns\n-------\nobject\n    An object from which you can call up all the of methods of the core API.",
                "parsed": []
              },
              "bases": [],
              "methods": {
                "__init__": {
                  "name": "__init__",
                  "kind": "function",
                  "signature": "(self, locations: str | Iterable[str] | None = None, modules: str | Iterable[str] | None = None, silent: str = {'cls': 'ExprName', 'member': None, 'name': 'SILENT_D'}, _withGc: bool = False)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "locations",
                      "type": "str | Iterable[str] | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "modules",
                      "type": "str | Iterable[str] | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "silent",
                      "type": "str",
                      "default": {
                        "cls": "ExprName",
                        "member": null,
                        "name": "SILENT_D"
                      },
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "_withGc",
                      "type": "bool",
                      "default": "False",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "_detect_cfm": {
                  "name": "_detect_cfm",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "Check if .cfm directory exists for the corpus.",
                    "description": "Check if .cfm directory exists for the corpus.\n\nReturns\n-------\nPath | None\n    Path to the .cfm/{CFM_VERSION}/ directory if it exists, else None.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "Path | None"
                  },
                  "decorators": []
                },
                "_feature_meta_from_cfm": {
                  "name": "_feature_meta_from_cfm",
                  "kind": "function",
                  "signature": "(self, mmap_mgr: MmapManager, fname: str)",
                  "docstring": {
                    "summary": "Get feature metadata from .cfm directory.",
                    "description": "Get feature metadata from .cfm directory.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "mmap_mgr",
                      "type": "MmapManager",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "fname",
                      "type": "str",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "dict[(str, str)]"
                  },
                  "decorators": []
                },
                "_gather_precomputed_data": {
                  "name": "_gather_precomputed_data",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "Gather already-loaded data to pass to the Compiler.",
                    "description": "Gather already-loaded data to pass to the Compiler.\n\nReturns\n-------\ndict | None\n    Dictionary of precomputed data, or None if data hasn't been loaded\n    or if not ALL features are loaded (to avoid partial compilation).",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "dict[(str, Any)] | None"
                  },
                  "decorators": []
                },
                "_getWriteLoc": {
                  "name": "_getWriteLoc",
                  "kind": "function",
                  "signature": "(self, location: str | None = None, module: str | None = None)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "location",
                      "type": "str | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "module",
                      "type": "str | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "_loadComputedFromCfm": {
                  "name": "_loadComputedFromCfm",
                  "kind": "function",
                  "signature": "(self, api: Api, mmap_mgr: MmapManager)",
                  "docstring": {
                    "summary": "Load computed data (C.*) from .cfm format.",
                    "description": "Load computed data (C.*) from .cfm format.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "api",
                      "type": "Api",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "mmap_mgr",
                      "type": "MmapManager",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "_loadEdgeFeatureFromCfm": {
                  "name": "_loadEdgeFeatureFromCfm",
                  "kind": "function",
                  "signature": "(self, api: Api, mmap_mgr: MmapManager, fname: str)",
                  "docstring": {
                    "summary": "Load an edge feature from .cfm format.",
                    "description": "Load an edge feature from .cfm format.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "api",
                      "type": "Api",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "mmap_mgr",
                      "type": "MmapManager",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "fname",
                      "type": "str",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "_loadFeature": {
                  "name": "_loadFeature",
                  "kind": "function",
                  "signature": "(self, fName: str, optional: bool = False)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "fName",
                      "type": "str",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "optional",
                      "type": "bool",
                      "default": "False",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "_loadNodeFeatureFromCfm": {
                  "name": "_loadNodeFeatureFromCfm",
                  "kind": "function",
                  "signature": "(self, api: Api, mmap_mgr: MmapManager, fname: str)",
                  "docstring": {
                    "summary": "Load a node feature from .cfm format.",
                    "description": "Load a node feature from .cfm format.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "api",
                      "type": "Api",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "mmap_mgr",
                      "type": "MmapManager",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "fname",
                      "type": "str",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "_makeApi": {
                  "name": "_makeApi",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "Api | None"
                  },
                  "decorators": []
                },
                "_makeApiFromCfm": {
                  "name": "_makeApiFromCfm",
                  "kind": "function",
                  "signature": "(self, mmap_mgr: MmapManager)",
                  "docstring": {
                    "summary": "Build API from memory-mapped .cfm data.",
                    "description": "Build API from memory-mapped .cfm data.\n\nOnly loads WARP features (otype, oslots) and computed data.\nUse loadAll() to load all features.\n\nParameters\n----------\nmmap_mgr : MmapManager\n    Manager for memory-mapped arrays\n\nReturns\n-------\nApi | None\n    A new Api if built successfully, else None.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "mmap_mgr",
                      "type": "MmapManager",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "Api | None"
                  },
                  "decorators": []
                },
                "_makeIndex": {
                  "name": "_makeIndex",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "_precompute": {
                  "name": "_precompute",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "_register_feature_meta": {
                  "name": "_register_feature_meta",
                  "kind": "function",
                  "signature": "(self, fname: str, meta: dict[(str, str)], is_edge: bool = False)",
                  "docstring": {
                    "summary": "Register feature metadata in self.features for API compatibility.",
                    "description": "Register feature metadata in self.features for API compatibility.\n\nWhen loading from .cfm format, we need to populate self.features\nso that CF.features[name].metaData works the same as .tf loading.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "fname",
                      "type": "str",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "meta",
                      "type": "dict[(str, str)]",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "is_edge",
                      "type": "bool",
                      "default": "False",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "_setupOtypeSupport": {
                  "name": "_setupOtypeSupport",
                  "kind": "function",
                  "signature": "(self, otype_feature: OtypeFeature, otype_arr, type_list: list[str], max_slot: int, max_node: int)",
                  "docstring": {
                    "summary": "Setup the support dict for otype.s() method.",
                    "description": "Setup the support dict for otype.s() method.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "otype_feature",
                      "type": "OtypeFeature",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "otype_arr",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "type_list",
                      "type": "list[str]",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "max_slot",
                      "type": "int",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "max_node",
                      "type": "int",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "_updateApi": {
                  "name": "_updateApi",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "compile": {
                  "name": "compile",
                  "kind": "function",
                  "signature": "(self, output_dir: str | None = None, silent: str = {'cls': 'ExprName', 'member': None, 'name': 'SILENT_D'})",
                  "docstring": {
                    "summary": "Compile .tf files to .cfm mmap format.",
                    "description": "Compile .tf files to .cfm mmap format.\n\nCompiles Text-Fabric source files into the Context Fabric memory-mapped\nformat for faster loading and shared memory across processes.\n\nIf data has already been loaded via load(), the precomputed data will be\npassed to the Compiler to avoid re-parsing .tf files and re-running\nprecomputation.\n\nParameters\n----------\noutput_dir : str, optional\n    Output directory for .cfm files. Defaults to {source}/.cfm/{CFM_VERSION}/\nsilent : str\n    Silence level\n\nReturns\n-------\nbool\n    True if compilation succeeded",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "output_dir",
                      "type": "str | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "silent",
                      "type": "str",
                      "default": {
                        "cls": "ExprName",
                        "member": null,
                        "name": "SILENT_D"
                      },
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "bool"
                  },
                  "decorators": []
                },
                "explore": {
                  "name": "explore",
                  "kind": "function",
                  "signature": "(self, silent: str = {'cls': 'ExprName', 'member': None, 'name': 'SILENT_D'}, show: bool = True)",
                  "docstring": {
                    "summary": "Makes categorization of all features in the dataset.",
                    "description": "Makes categorization of all features in the dataset.\n\nParameters\n----------\nsilent: string, optional \"auto\"\n    Verbosity level: \"verbose\", \"auto\", \"terse\", or \"deep\"\nshow: boolean, optional True\n    If `False`, the resulting dictionary is delivered in `CF.featureSets`;\n    if `True`, the dictionary is returned as function result.\n\nReturns\n-------\ndict | None\n    A dictionary  with keys `nodes`, `edges`, `configs`, `computeds`.\n    Under each key there is the set of feature names in that category.\n    How this dictionary is delivered, depends on the parameter *show*.\n\nNotes\n-----\n!!! explanation \"`configs`\"\n    These are configuration features, with metadata only, no data. E.g. `otext`.\n\n!!! explanation \"`computeds`\"\n    These are blocks of pre-computed data, available under the `C` API,\n    see `cfabric.computed.Computeds`.\n\nThe sets do not indicate whether a feature is loaded or not.\nThere are other functions that give you the loaded features:\n`cfabric.api.Api.Fall` for nodes and `cfabric.api.Api.Eall` for edges.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "silent",
                      "type": "str",
                      "default": {
                        "cls": "ExprName",
                        "member": null,
                        "name": "SILENT_D"
                      },
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "show",
                      "type": "bool",
                      "default": "True",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "dict[(str, tuple[(str, ...)])] | None"
                  },
                  "decorators": []
                },
                "load": {
                  "name": "load",
                  "kind": "function",
                  "signature": "(self, features: str | Iterable[str], add: bool = False, silent: str = {'cls': 'ExprName', 'member': None, 'name': 'SILENT_D'})",
                  "docstring": {
                    "summary": "Loads features from disk into RAM memory.",
                    "description": "Loads features from disk into RAM memory.\n\nAutomatically uses memory-mapped .cfm format when available for faster\nloading and reduced memory usage. Falls back to .tf format otherwise.\n\nParameters\n----------\n\nfeatures: string | iterable\n    Either a string containing space separated feature names, or an\n    iterable of feature names.\n    The feature names are just the names of `.tf` files\n    without directory information and without extension.\nadd: boolean, optional False\n    The features will be added to the same currently loaded features, managed\n    by the current API.\n    Meant to be able to dynamically load features without reloading lots\n    of features for nothing.\nsilent: string, optional \"auto\"\n    Verbosity level: \"verbose\", \"auto\", \"terse\", or \"deep\"\n\nReturns\n-------\nboolean | object\n    If `add` is `True` a boolean indicating success is returned.\n    Otherwise, the result is a new `cfabric.api.Api`\n    if the feature could be loaded, else `False`.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "features",
                      "type": "str | Iterable[str]",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "add",
                      "type": "bool",
                      "default": "False",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "silent",
                      "type": "str",
                      "default": {
                        "cls": "ExprName",
                        "member": null,
                        "name": "SILENT_D"
                      },
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "Api | bool"
                  },
                  "decorators": []
                },
                "loadAll": {
                  "name": "loadAll",
                  "kind": "function",
                  "signature": "(self, silent: str = {'cls': 'ExprName', 'member': None, 'name': 'SILENT_D'})",
                  "docstring": {
                    "summary": "Load all loadable features.",
                    "description": "Load all loadable features.\n\nParameters\n----------\nsilent: string, optional \"auto\"\n    Verbosity level: \"verbose\", \"auto\", \"terse\", or \"deep\"",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "silent",
                      "type": "str",
                      "default": {
                        "cls": "ExprName",
                        "member": null,
                        "name": "SILENT_D"
                      },
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "Api | bool"
                  },
                  "decorators": []
                },
                "save": {
                  "name": "save",
                  "kind": "function",
                  "signature": "(self, nodeFeatures: NodeFeatureDict | None = None, edgeFeatures: EdgeFeatureDict | None = None, metaData: MetaDataDict | None = None, location: str | None = None, module: str | None = None, silent: str = {'cls': 'ExprName', 'member': None, 'name': 'SILENT_D'})",
                  "docstring": {
                    "summary": "Saves newly generated data to disk as CF features, nodes and / or edges.",
                    "description": "Saves newly generated data to disk as CF features, nodes and / or edges.\n\nIf you have collected feature data in dictionaries, keyed by the\nnames of the features, and valued by their feature data,\nthen you can save that data to `.tf` feature files on disk.\n\nIt is this easy to export new data as features:\ncollect the data and metadata of the features and feed it in an orderly way\nto `CF.save()` and there you go.\n\nParameters\n----------\nnodeFeatures: dict of dict\n    The data of a node feature is a dictionary with nodes as keys (integers!)\n    and strings or numbers as (feature) values.\n    This parameter holds all those dictionaries, keyed by feature name.\n\nedgeFeatures: dict of dict\n    The data of an edge feature is a dictionary with nodes as keys, and sets or\n    dictionaries as values. These sets should be sets of nodes (integers!),\n    and these dictionaries should have nodes as keys and strings or numbers\n    as values.\n    This parameter holds all those dictionaries, keyed by feature name.\n\nmetaData: dict of  dict\n    The meta data for every feature to be saved is a key-value dictionary.\n    This parameter holds all those dictionaries, keyed by feature name.\n\n    !!! explanation \"value types\"\n        The type of the feature values (`int` or `str`) should be specified\n        under key `valueType`.\n\n    !!! explanation \"edge values\"\n        If you save an edge feature, and there are values in that edge feature,\n        you have to say so, by specifying `edgeValues=True`\n        in the metadata for that feature.\n\n    !!! explanation \"generic metadata\"\n        This parameter may also contain fields under the empty name.\n        These fields will be added to all features in `nodeFeatures` and\n        `edgeFeatures`.\n\n    !!! explanation \"configuration features\"\n        If you need to write the *configuration* feature `otext`,\n        which is a metadata-only feature, just\n        add the metadata under key `otext` in this parameter and make sure\n        that `otext` is not a key in `nodeFeatures` nor in\n        `edgeFeatures`.\n        These fields will be written into the separate configuration\n        feature `otext`, with no data associated.\n\nlocation: dict\n    The (meta)data will be written to the very last directory that CF searched\n    when looking for features (this is determined by the\n    `locations` and `modules` parameters in `cfabric.fabric.Fabric`.\n\n    If both `locations` and `modules` are empty, writing will take place\n    in the current directory.\n\n    But you can override it:\n\n    If you pass `location=something`, CF will save in `something/mod`,\n    where `mod` is the last member of the `modules` parameter of CF.\n\nmodule: dict\n    This is an additional way of overriding the default location\n    where CF saves new features. See the *location* parameter.\n\n    If you pass `module=something`, CF will save in `loc/something`,\n    where `loc` is the last member of the `locations` parameter of CF.\n\n    If you pass `location=path1` and `module=path2`,\n    CF will save in `path1/path2`.\n\nsilent: string, optional \"auto\"\n    Verbosity level: \"verbose\", \"auto\", \"terse\", or \"deep\"",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "nodeFeatures",
                      "type": "NodeFeatureDict | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "edgeFeatures",
                      "type": "EdgeFeatureDict | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "metaData",
                      "type": "MetaDataDict | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "location",
                      "type": "str | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "module",
                      "type": "str | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "silent",
                      "type": "str",
                      "default": {
                        "cls": "ExprName",
                        "member": null,
                        "name": "SILENT_D"
                      },
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "bool"
                  },
                  "decorators": []
                }
              },
              "attributes": {
                "_withGc": {
                  "name": "_withGc",
                  "type": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "_withGc"
                  }
                },
                "banner": {
                  "name": "banner",
                  "type": "",
                  "docstring": {
                    "summary": "The banner Context-Fabric.",
                    "description": "The banner Context-Fabric.\n\nWill be shown just after start up, if the silence is not `deep`.",
                    "parsed": []
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "BANNER"
                  }
                },
                "features": {
                  "name": "features",
                  "type": "dict[(str, Data)]",
                  "docstring": {
                    "summary": "Dictionary of all features that CF has found, whether loaded or not.",
                    "description": "Dictionary of all features that CF has found, whether loaded or not.\n\nUnder each feature name is all info about that feature.\n\nThe best use of this is to get the metadata of features:\n\n    CF.features['fff'].metaData\n\nThis works for all features `fff` that have been found,\nwhether the feature is loaded or not.\n\nIf a feature is loaded, you can also use\n\n`F.fff.meta` of `E.fff.meta` depending on whether `fff` is a node feature\nor an edge feature.\n\n!!! caution \"Do not print!\"\n    If a feature is loaded, its data is also in the feature info.\n    This can be an enormous amount of information, and you can easily\n    overwhelm your notebook if you print it.",
                    "parsed": []
                  },
                  "value": {
                    "cls": "ExprDict",
                    "keys": [],
                    "values": []
                  }
                },
                "featuresRequested": {
                  "name": "featuresRequested",
                  "type": "list[str]",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprList",
                    "elements": []
                  }
                },
                "good": {
                  "name": "good",
                  "type": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": "True"
                },
                "locationRep": {
                  "name": "locationRep",
                  "type": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "arguments": [
                      {
                        "cls": "ExprGeneratorExp",
                        "element": {
                          "arguments": [
                            {
                              "cls": "ExprGeneratorExp",
                              "element": {
                                "cls": "ExprJoinedStr",
                                "values": [
                                  {
                                    "cls": "ExprFormatted",
                                    "value": {
                                      "cls": "ExprName",
                                      "member": null,
                                      "name": "lc"
                                    }
                                  },
                                  "/",
                                  {
                                    "cls": "ExprFormatted",
                                    "value": {
                                      "cls": "ExprName",
                                      "member": null,
                                      "name": "f"
                                    }
                                  }
                                ]
                              },
                              "generators": [
                                {
                                  "cls": "ExprComprehension",
                                  "conditions": [],
                                  "is_async": false,
                                  "iterable": {
                                    "cls": "ExprAttribute",
                                    "values": [
                                      {
                                        "cls": "ExprName",
                                        "member": null,
                                        "name": "self"
                                      },
                                      {
                                        "cls": "ExprName",
                                        "member": null,
                                        "name": "modules"
                                      }
                                    ]
                                  },
                                  "target": {
                                    "cls": "ExprName",
                                    "member": null,
                                    "name": "f"
                                  }
                                }
                              ]
                            }
                          ],
                          "cls": "ExprCall",
                          "function": {
                            "cls": "ExprAttribute",
                            "values": [
                              "'\\n\\t'",
                              {
                                "cls": "ExprName",
                                "member": null,
                                "name": "join"
                              }
                            ]
                          }
                        },
                        "generators": [
                          {
                            "cls": "ExprComprehension",
                            "conditions": [],
                            "is_async": false,
                            "iterable": {
                              "cls": "ExprAttribute",
                              "values": [
                                {
                                  "cls": "ExprName",
                                  "member": null,
                                  "name": "self"
                                },
                                {
                                  "cls": "ExprName",
                                  "member": null,
                                  "name": "locations"
                                }
                              ]
                            },
                            "target": {
                              "cls": "ExprName",
                              "member": null,
                              "name": "lc"
                            }
                          }
                        ]
                      }
                    ],
                    "cls": "ExprCall",
                    "function": {
                      "cls": "ExprAttribute",
                      "values": [
                        "'\\n\\t'",
                        {
                          "cls": "ExprName",
                          "member": null,
                          "name": "join"
                        }
                      ]
                    }
                  }
                },
                "locations": {
                  "name": "locations",
                  "type": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprList",
                    "elements": []
                  }
                },
                "modules": {
                  "name": "modules",
                  "type": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "modules"
                  }
                },
                "silent": {
                  "name": "silent",
                  "type": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "silent"
                  }
                },
                "version": {
                  "name": "version",
                  "type": "",
                  "docstring": {
                    "summary": "The version number of the CF library.",
                    "description": "The version number of the CF library.",
                    "parsed": []
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "VERSION"
                  }
                }
              }
            }
          },
          "functions": {},
          "modules": {},
          "aliases": {
            "Any": {
              "name": "Any",
              "target": "typing.Any"
            },
            "Api": {
              "name": "Api",
              "target": "cfabric.core.api.Api"
            },
            "BANNER": {
              "name": "BANNER",
              "target": "cfabric.core.config.BANNER"
            },
            "CFM_VERSION": {
              "name": "CFM_VERSION",
              "target": "cfabric.core.config.CFM_VERSION"
            },
            "CSRArray": {
              "name": "CSRArray",
              "target": "cfabric.storage.csr.CSRArray"
            },
            "Compiler": {
              "name": "Compiler",
              "target": "cfabric.io.compiler.Compiler"
            },
            "Computed": {
              "name": "Computed",
              "target": "cfabric.features.computed.Computed"
            },
            "Data": {
              "name": "Data",
              "target": "cfabric.io.loader.Data"
            },
            "EdgeFeature": {
              "name": "EdgeFeature",
              "target": "cfabric.features.edge.EdgeFeature"
            },
            "IntFeatureArray": {
              "name": "IntFeatureArray",
              "target": "cfabric.storage.string_pool.IntFeatureArray"
            },
            "Iterable": {
              "name": "Iterable",
              "target": "collections.abc.Iterable"
            },
            "LOCATIONS": {
              "name": "LOCATIONS",
              "target": "cfabric.utils.files.LOCATIONS"
            },
            "LevDownComputed": {
              "name": "LevDownComputed",
              "target": "cfabric.features.computed.LevDownComputed"
            },
            "LevUpComputed": {
              "name": "LevUpComputed",
              "target": "cfabric.features.computed.LevUpComputed"
            },
            "MEM_MSG": {
              "name": "MEM_MSG",
              "target": "cfabric.io.loader.MEM_MSG"
            },
            "MmapManager": {
              "name": "MmapManager",
              "target": "cfabric.storage.mmap_manager.MmapManager"
            },
            "NodeFeature": {
              "name": "NodeFeature",
              "target": "cfabric.features.node.NodeFeature"
            },
            "OSLOTS": {
              "name": "OSLOTS",
              "target": "cfabric.core.config.OSLOTS"
            },
            "OTEXT": {
              "name": "OTEXT",
              "target": "cfabric.core.config.OTEXT"
            },
            "OTYPE": {
              "name": "OTYPE",
              "target": "cfabric.core.config.OTYPE"
            },
            "OrderComputed": {
              "name": "OrderComputed",
              "target": "cfabric.features.computed.OrderComputed"
            },
            "OslotsFeature": {
              "name": "OslotsFeature",
              "target": "cfabric.features.warp.oslots.OslotsFeature"
            },
            "OtypeFeature": {
              "name": "OtypeFeature",
              "target": "cfabric.features.warp.otype.OtypeFeature"
            },
            "Path": {
              "name": "Path",
              "target": "pathlib.Path"
            },
            "RankComputed": {
              "name": "RankComputed",
              "target": "cfabric.features.computed.RankComputed"
            },
            "SILENT_D": {
              "name": "SILENT_D",
              "target": "cfabric.utils.logging.SILENT_D"
            },
            "StringPool": {
              "name": "StringPool",
              "target": "cfabric.storage.string_pool.StringPool"
            },
            "VERSION": {
              "name": "VERSION",
              "target": "cfabric.core.config.VERSION"
            },
            "addLocality": {
              "name": "addLocality",
              "target": "cfabric.core.api.addLocality"
            },
            "addNodes": {
              "name": "addNodes",
              "target": "cfabric.core.api.addNodes"
            },
            "addOtype": {
              "name": "addOtype",
              "target": "cfabric.core.api.addOtype"
            },
            "addSearch": {
              "name": "addSearch",
              "target": "cfabric.core.api.addSearch"
            },
            "addText": {
              "name": "addText",
              "target": "cfabric.core.api.addText"
            },
            "boundary": {
              "name": "boundary",
              "target": "cfabric.precompute.prepare.boundary"
            },
            "chain": {
              "name": "chain",
              "target": "itertools.chain"
            },
            "characters": {
              "name": "characters",
              "target": "cfabric.precompute.prepare.characters"
            },
            "check32": {
              "name": "check32",
              "target": "cfabric.utils.helpers.check32"
            },
            "collectFormats": {
              "name": "collectFormats",
              "target": "cfabric.utils.helpers.collectFormats"
            },
            "collections": {
              "name": "collections",
              "target": "collections"
            },
            "compile_corpus": {
              "name": "compile_corpus",
              "target": "cfabric.io.compiler.compile_corpus"
            },
            "configure_logging": {
              "name": "configure_logging",
              "target": "cfabric.utils.logging.configure_logging"
            },
            "console": {
              "name": "console",
              "target": "cfabric.utils.helpers.console"
            },
            "dirExists": {
              "name": "dirExists",
              "target": "cfabric.utils.files.dirExists"
            },
            "ex": {
              "name": "ex",
              "target": "cfabric.utils.files.expanduser"
            },
            "expandDir": {
              "name": "expandDir",
              "target": "cfabric.utils.files.expandDir"
            },
            "fitemize": {
              "name": "fitemize",
              "target": "cfabric.utils.helpers.fitemize"
            },
            "itemize": {
              "name": "itemize",
              "target": "cfabric.utils.helpers.itemize"
            },
            "levDown": {
              "name": "levDown",
              "target": "cfabric.precompute.prepare.levDown"
            },
            "levUp": {
              "name": "levUp",
              "target": "cfabric.precompute.prepare.levUp"
            },
            "levels": {
              "name": "levels",
              "target": "cfabric.precompute.prepare.levels"
            },
            "logging": {
              "name": "logging",
              "target": "logging"
            },
            "makeExamples": {
              "name": "makeExamples",
              "target": "cfabric.utils.helpers.makeExamples"
            },
            "normpath": {
              "name": "normpath",
              "target": "cfabric.utils.files.normpath"
            },
            "np": {
              "name": "np",
              "target": "numpy"
            },
            "order": {
              "name": "order",
              "target": "cfabric.precompute.prepare.order"
            },
            "rank": {
              "name": "rank",
              "target": "cfabric.precompute.prepare.rank"
            },
            "scanDir": {
              "name": "scanDir",
              "target": "cfabric.utils.files.scanDir"
            },
            "sections": {
              "name": "sections",
              "target": "cfabric.precompute.prepare.sections"
            },
            "sectionsFromApi": {
              "name": "sectionsFromApi",
              "target": "cfabric.precompute.prepare.sectionsFromApi"
            },
            "setDir": {
              "name": "setDir",
              "target": "cfabric.utils.files.setDir"
            },
            "set_logging_level": {
              "name": "set_logging_level",
              "target": "cfabric.utils.logging.set_logging_level"
            },
            "silentConvert": {
              "name": "silentConvert",
              "target": "cfabric.utils.logging.silentConvert"
            },
            "splitExt": {
              "name": "splitExt",
              "target": "cfabric.utils.files.splitExt"
            },
            "structure": {
              "name": "structure",
              "target": "cfabric.precompute.prepare.structure"
            }
          }
        }
      },
      "aliases": {
        "Api": {
          "name": "Api",
          "target": "cfabric.core.api.Api"
        },
        "BANNER": {
          "name": "BANNER",
          "target": "cfabric.core.config.BANNER"
        },
        "Fabric": {
          "name": "Fabric",
          "target": "cfabric.core.fabric.Fabric"
        },
        "NAME": {
          "name": "NAME",
          "target": "cfabric.core.config.NAME"
        },
        "OSLOTS": {
          "name": "OSLOTS",
          "target": "cfabric.core.config.OSLOTS"
        },
        "OTEXT": {
          "name": "OTEXT",
          "target": "cfabric.core.config.OTEXT"
        },
        "OTYPE": {
          "name": "OTYPE",
          "target": "cfabric.core.config.OTYPE"
        },
        "VERSION": {
          "name": "VERSION",
          "target": "cfabric.core.config.VERSION"
        },
        "WARP": {
          "name": "WARP",
          "target": "cfabric.core.config.WARP"
        }
      }
    },
    "describe": {
      "name": "describe",
      "kind": "module",
      "path": "",
      "docstring": {
        "summary": "Corpus description utilities for Context Fabric.",
        "description": "Corpus description utilities for Context Fabric.\n\nThis module provides centralized utilities for describing corpora,\nfeatures, and text representations. It generates exhaustive samples\nfor text format character coverage.\n\nUsage:\n    >>> from cfabric.describe import describe_corpus, describe_feature\n    >>> result = describe_corpus(api, \"BHSA\")\n    >>> feature_info = describe_feature(api, \"sp\")",
        "parsed": []
      },
      "classes": {
        "CorpusDescription": {
          "name": "CorpusDescription",
          "kind": "class",
          "path": "",
          "docstring": {
            "summary": "Complete corpus description.",
            "description": "Complete corpus description.\n\nAttributes:\n    name: Corpus name\n    node_types: List of node types with counts\n    sections: Section hierarchy information\n    text_representations: Text format information with samples\n    features: List of node feature metadata\n    edge_features: List of edge feature metadata",
            "parsed": []
          },
          "bases": [],
          "methods": {
            "__init__": {
              "name": "__init__",
              "kind": "function",
              "signature": "(self, name: str, node_types: list[dict[(str, Any)]] = {'arguments': [], 'cls': 'ExprCall', 'function': {'cls': 'ExprName', 'member': None, 'name': 'list'}}, sections: dict[(str, Any)] = {'arguments': [], 'cls': 'ExprCall', 'function': {'cls': 'ExprName', 'member': None, 'name': 'dict'}}, text_representations: TextRepresentationInfo = {'arguments': [], 'cls': 'ExprCall', 'function': {'body': {'arguments': [{'cls': 'ExprKeyword', 'function': {'cls': 'ExprName', 'member': None, 'name': 'TextRepresentationInfo'}, 'name': 'description', 'value': \"''\"}], 'cls': 'ExprCall', 'function': {'cls': 'ExprName', 'member': None, 'name': 'TextRepresentationInfo'}}, 'cls': 'ExprLambda', 'parameters': []}}, features: list[dict[(str, str)]] = {'arguments': [], 'cls': 'ExprCall', 'function': {'cls': 'ExprName', 'member': None, 'name': 'list'}}, edge_features: list[dict[(str, str)]] = {'arguments': [], 'cls': 'ExprCall', 'function': {'cls': 'ExprName', 'member': None, 'name': 'list'}})",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "self",
                  "type": "",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "name",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "node_types",
                  "type": "list[dict[(str, Any)]]",
                  "default": {
                    "arguments": [],
                    "cls": "ExprCall",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "list"
                    }
                  },
                  "kind": "positional or keyword"
                },
                {
                  "name": "sections",
                  "type": "dict[(str, Any)]",
                  "default": {
                    "arguments": [],
                    "cls": "ExprCall",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "dict"
                    }
                  },
                  "kind": "positional or keyword"
                },
                {
                  "name": "text_representations",
                  "type": "TextRepresentationInfo",
                  "default": {
                    "arguments": [],
                    "cls": "ExprCall",
                    "function": {
                      "body": {
                        "arguments": [
                          {
                            "cls": "ExprKeyword",
                            "function": {
                              "cls": "ExprName",
                              "member": null,
                              "name": "TextRepresentationInfo"
                            },
                            "name": "description",
                            "value": "''"
                          }
                        ],
                        "cls": "ExprCall",
                        "function": {
                          "cls": "ExprName",
                          "member": null,
                          "name": "TextRepresentationInfo"
                        }
                      },
                      "cls": "ExprLambda",
                      "parameters": []
                    }
                  },
                  "kind": "positional or keyword"
                },
                {
                  "name": "features",
                  "type": "list[dict[(str, str)]]",
                  "default": {
                    "arguments": [],
                    "cls": "ExprCall",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "list"
                    }
                  },
                  "kind": "positional or keyword"
                },
                {
                  "name": "edge_features",
                  "type": "list[dict[(str, str)]]",
                  "default": {
                    "arguments": [],
                    "cls": "ExprCall",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "list"
                    }
                  },
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "to_dict": {
              "name": "to_dict",
              "kind": "function",
              "signature": "(self)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "self",
                  "type": "",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "dict[(str, Any)]"
              },
              "decorators": []
            }
          },
          "attributes": {
            "edge_features": {
              "name": "edge_features",
              "type": "list[dict[(str, str)]]",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": {
                "arguments": [
                  {
                    "cls": "ExprKeyword",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "field"
                    },
                    "name": "default_factory",
                    "value": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "list"
                    }
                  }
                ],
                "cls": "ExprCall",
                "function": {
                  "cls": "ExprName",
                  "member": null,
                  "name": "field"
                }
              }
            },
            "features": {
              "name": "features",
              "type": "list[dict[(str, str)]]",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": {
                "arguments": [
                  {
                    "cls": "ExprKeyword",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "field"
                    },
                    "name": "default_factory",
                    "value": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "list"
                    }
                  }
                ],
                "cls": "ExprCall",
                "function": {
                  "cls": "ExprName",
                  "member": null,
                  "name": "field"
                }
              }
            },
            "name": {
              "name": "name",
              "type": "str",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": null
            },
            "node_types": {
              "name": "node_types",
              "type": "list[dict[(str, Any)]]",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": {
                "arguments": [
                  {
                    "cls": "ExprKeyword",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "field"
                    },
                    "name": "default_factory",
                    "value": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "list"
                    }
                  }
                ],
                "cls": "ExprCall",
                "function": {
                  "cls": "ExprName",
                  "member": null,
                  "name": "field"
                }
              }
            },
            "sections": {
              "name": "sections",
              "type": "dict[(str, Any)]",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": {
                "arguments": [
                  {
                    "cls": "ExprKeyword",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "field"
                    },
                    "name": "default_factory",
                    "value": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "dict"
                    }
                  }
                ],
                "cls": "ExprCall",
                "function": {
                  "cls": "ExprName",
                  "member": null,
                  "name": "field"
                }
              }
            },
            "text_representations": {
              "name": "text_representations",
              "type": "TextRepresentationInfo",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": {
                "arguments": [
                  {
                    "cls": "ExprKeyword",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "field"
                    },
                    "name": "default_factory",
                    "value": {
                      "body": {
                        "arguments": [
                          {
                            "cls": "ExprKeyword",
                            "function": {
                              "cls": "ExprName",
                              "member": null,
                              "name": "TextRepresentationInfo"
                            },
                            "name": "description",
                            "value": "''"
                          }
                        ],
                        "cls": "ExprCall",
                        "function": {
                          "cls": "ExprName",
                          "member": null,
                          "name": "TextRepresentationInfo"
                        }
                      },
                      "cls": "ExprLambda",
                      "parameters": []
                    }
                  }
                ],
                "cls": "ExprCall",
                "function": {
                  "cls": "ExprName",
                  "member": null,
                  "name": "field"
                }
              }
            }
          }
        },
        "CorpusOverview": {
          "name": "CorpusOverview",
          "kind": "class",
          "path": "",
          "docstring": {
            "summary": "Slim corpus overview (node types and sections only).",
            "description": "Slim corpus overview (node types and sections only).\n\nUse this for lightweight discovery. For full details including\ntext representations and feature lists, use CorpusDescription.",
            "parsed": []
          },
          "bases": [],
          "methods": {
            "__init__": {
              "name": "__init__",
              "kind": "function",
              "signature": "(self, name: str, node_types: list[dict[(str, Any)]] = {'arguments': [], 'cls': 'ExprCall', 'function': {'cls': 'ExprName', 'member': None, 'name': 'list'}}, sections: dict[(str, Any)] = {'arguments': [], 'cls': 'ExprCall', 'function': {'cls': 'ExprName', 'member': None, 'name': 'dict'}})",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "self",
                  "type": "",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "name",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "node_types",
                  "type": "list[dict[(str, Any)]]",
                  "default": {
                    "arguments": [],
                    "cls": "ExprCall",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "list"
                    }
                  },
                  "kind": "positional or keyword"
                },
                {
                  "name": "sections",
                  "type": "dict[(str, Any)]",
                  "default": {
                    "arguments": [],
                    "cls": "ExprCall",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "dict"
                    }
                  },
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "to_dict": {
              "name": "to_dict",
              "kind": "function",
              "signature": "(self)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "self",
                  "type": "",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "dict[(str, Any)]"
              },
              "decorators": []
            }
          },
          "attributes": {
            "name": {
              "name": "name",
              "type": "str",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": null
            },
            "node_types": {
              "name": "node_types",
              "type": "list[dict[(str, Any)]]",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": {
                "arguments": [
                  {
                    "cls": "ExprKeyword",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "field"
                    },
                    "name": "default_factory",
                    "value": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "list"
                    }
                  }
                ],
                "cls": "ExprCall",
                "function": {
                  "cls": "ExprName",
                  "member": null,
                  "name": "field"
                }
              }
            },
            "sections": {
              "name": "sections",
              "type": "dict[(str, Any)]",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": {
                "arguments": [
                  {
                    "cls": "ExprKeyword",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "field"
                    },
                    "name": "default_factory",
                    "value": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "dict"
                    }
                  }
                ],
                "cls": "ExprCall",
                "function": {
                  "cls": "ExprName",
                  "member": null,
                  "name": "field"
                }
              }
            }
          }
        },
        "FeatureCatalogEntry": {
          "name": "FeatureCatalogEntry",
          "kind": "class",
          "path": "",
          "docstring": {
            "summary": "Lightweight feature entry for catalog listing.",
            "description": "Lightweight feature entry for catalog listing.",
            "parsed": []
          },
          "bases": [],
          "methods": {
            "__init__": {
              "name": "__init__",
              "kind": "function",
              "signature": "(self, name: str, kind: str, value_type: str, description: str = '')",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "self",
                  "type": "",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "name",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "kind",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "value_type",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "description",
                  "type": "str",
                  "default": "''",
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "to_dict": {
              "name": "to_dict",
              "kind": "function",
              "signature": "(self)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "self",
                  "type": "",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "dict[(str, str)]"
              },
              "decorators": []
            }
          },
          "attributes": {
            "description": {
              "name": "description",
              "type": "str",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": "''"
            },
            "kind": {
              "name": "kind",
              "type": "str",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": null
            },
            "name": {
              "name": "name",
              "type": "str",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": null
            },
            "value_type": {
              "name": "value_type",
              "type": "str",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": null
            }
          }
        },
        "FeatureDescription": {
          "name": "FeatureDescription",
          "kind": "class",
          "path": "",
          "docstring": {
            "summary": "Detailed description of a feature.",
            "description": "Detailed description of a feature.\n\nAttributes:\n    name: Feature name\n    kind: 'node' or 'edge'\n    value_type: 'str', 'int', or '' for edges without values\n    description: Feature description from metadata\n    node_types: List of node types this feature applies to\n    unique_values: Number of unique values\n    sample_values: Top values by frequency\n    has_values: For edge features, whether edges have values\n    error: Error message if feature not found",
            "parsed": []
          },
          "bases": [],
          "methods": {
            "__init__": {
              "name": "__init__",
              "kind": "function",
              "signature": "(self, name: str, kind: str, value_type: str = '', description: str = '', node_types: list[str] = {'arguments': [], 'cls': 'ExprCall', 'function': {'cls': 'ExprName', 'member': None, 'name': 'list'}}, unique_values: int = 0, sample_values: list[dict[(str, Any)]] = {'arguments': [], 'cls': 'ExprCall', 'function': {'cls': 'ExprName', 'member': None, 'name': 'list'}}, has_values: bool | None = None, error: str | None = None)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "self",
                  "type": "",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "name",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "kind",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "value_type",
                  "type": "str",
                  "default": "''",
                  "kind": "positional or keyword"
                },
                {
                  "name": "description",
                  "type": "str",
                  "default": "''",
                  "kind": "positional or keyword"
                },
                {
                  "name": "node_types",
                  "type": "list[str]",
                  "default": {
                    "arguments": [],
                    "cls": "ExprCall",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "list"
                    }
                  },
                  "kind": "positional or keyword"
                },
                {
                  "name": "unique_values",
                  "type": "int",
                  "default": "0",
                  "kind": "positional or keyword"
                },
                {
                  "name": "sample_values",
                  "type": "list[dict[(str, Any)]]",
                  "default": {
                    "arguments": [],
                    "cls": "ExprCall",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "list"
                    }
                  },
                  "kind": "positional or keyword"
                },
                {
                  "name": "has_values",
                  "type": "bool | None",
                  "default": "None",
                  "kind": "positional or keyword"
                },
                {
                  "name": "error",
                  "type": "str | None",
                  "default": "None",
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "from_api": {
              "name": "from_api",
              "kind": "function",
              "signature": "(cls, api: Api, feature: str, sample_limit: int = 20)",
              "docstring": {
                "summary": "Create FeatureDescription from API.",
                "description": "Create FeatureDescription from API.\n\nParameters\n----------\napi : Api\n    Context Fabric API instance\nfeature : str\n    Feature name\nsample_limit : int\n    Maximum sample values to return",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "cls",
                  "type": "",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "api",
                  "type": "Api",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "feature",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "sample_limit",
                  "type": "int",
                  "default": "20",
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "FeatureDescription"
              },
              "decorators": [
                {
                  "endlineno": 136,
                  "lineno": 136,
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "classmethod"
                  }
                }
              ]
            },
            "to_dict": {
              "name": "to_dict",
              "kind": "function",
              "signature": "(self)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "self",
                  "type": "",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "dict[(str, Any)]"
              },
              "decorators": []
            }
          },
          "attributes": {
            "description": {
              "name": "description",
              "type": "str",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": "''"
            },
            "error": {
              "name": "error",
              "type": "str | None",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": "None"
            },
            "has_values": {
              "name": "has_values",
              "type": "bool | None",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": "None"
            },
            "kind": {
              "name": "kind",
              "type": "str",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": null
            },
            "name": {
              "name": "name",
              "type": "str",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": null
            },
            "node_types": {
              "name": "node_types",
              "type": "list[str]",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": {
                "arguments": [
                  {
                    "cls": "ExprKeyword",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "field"
                    },
                    "name": "default_factory",
                    "value": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "list"
                    }
                  }
                ],
                "cls": "ExprCall",
                "function": {
                  "cls": "ExprName",
                  "member": null,
                  "name": "field"
                }
              }
            },
            "sample_values": {
              "name": "sample_values",
              "type": "list[dict[(str, Any)]]",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": {
                "arguments": [
                  {
                    "cls": "ExprKeyword",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "field"
                    },
                    "name": "default_factory",
                    "value": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "list"
                    }
                  }
                ],
                "cls": "ExprCall",
                "function": {
                  "cls": "ExprName",
                  "member": null,
                  "name": "field"
                }
              }
            },
            "unique_values": {
              "name": "unique_values",
              "type": "int",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": "0"
            },
            "value_type": {
              "name": "value_type",
              "type": "str",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": "''"
            }
          }
        },
        "TextFormatInfo": {
          "name": "TextFormatInfo",
          "kind": "class",
          "path": "",
          "docstring": {
            "summary": "Information about a text format pair (orig/trans).",
            "description": "Information about a text format pair (orig/trans).",
            "parsed": []
          },
          "bases": [],
          "methods": {
            "__init__": {
              "name": "__init__",
              "kind": "function",
              "signature": "(self, name: str, original_spec: str, transliteration_spec: str, samples: list[TextFormatSample] = {'arguments': [], 'cls': 'ExprCall', 'function': {'cls': 'ExprName', 'member': None, 'name': 'list'}}, unique_characters: int = 0, total_samples: int = 0)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "self",
                  "type": "",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "name",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "original_spec",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "transliteration_spec",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "samples",
                  "type": "list[TextFormatSample]",
                  "default": {
                    "arguments": [],
                    "cls": "ExprCall",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "list"
                    }
                  },
                  "kind": "positional or keyword"
                },
                {
                  "name": "unique_characters",
                  "type": "int",
                  "default": "0",
                  "kind": "positional or keyword"
                },
                {
                  "name": "total_samples",
                  "type": "int",
                  "default": "0",
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "to_dict": {
              "name": "to_dict",
              "kind": "function",
              "signature": "(self)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "self",
                  "type": "",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "dict[(str, Any)]"
              },
              "decorators": []
            }
          },
          "attributes": {
            "name": {
              "name": "name",
              "type": "str",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": null
            },
            "original_spec": {
              "name": "original_spec",
              "type": "str",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": null
            },
            "samples": {
              "name": "samples",
              "type": "list[TextFormatSample]",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": {
                "arguments": [
                  {
                    "cls": "ExprKeyword",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "field"
                    },
                    "name": "default_factory",
                    "value": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "list"
                    }
                  }
                ],
                "cls": "ExprCall",
                "function": {
                  "cls": "ExprName",
                  "member": null,
                  "name": "field"
                }
              }
            },
            "total_samples": {
              "name": "total_samples",
              "type": "int",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": "0"
            },
            "transliteration_spec": {
              "name": "transliteration_spec",
              "type": "str",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": null
            },
            "unique_characters": {
              "name": "unique_characters",
              "type": "int",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": "0"
            }
          }
        },
        "TextFormatSample": {
          "name": "TextFormatSample",
          "kind": "class",
          "path": "",
          "docstring": {
            "summary": "A single text sample showing original and transliterated forms.",
            "description": "A single text sample showing original and transliterated forms.",
            "parsed": []
          },
          "bases": [],
          "methods": {
            "__init__": {
              "name": "__init__",
              "kind": "function",
              "signature": "(self, original: str, transliterated: str)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "self",
                  "type": "",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "original",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "transliterated",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "to_dict": {
              "name": "to_dict",
              "kind": "function",
              "signature": "(self)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "self",
                  "type": "",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "dict[(str, str)]"
              },
              "decorators": []
            }
          },
          "attributes": {
            "original": {
              "name": "original",
              "type": "str",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": null
            },
            "transliterated": {
              "name": "transliterated",
              "type": "str",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": null
            }
          }
        },
        "TextRepresentationInfo": {
          "name": "TextRepresentationInfo",
          "kind": "class",
          "path": "",
          "docstring": {
            "summary": "Complete text representation info for a corpus.",
            "description": "Complete text representation info for a corpus.",
            "parsed": []
          },
          "bases": [],
          "methods": {
            "__init__": {
              "name": "__init__",
              "kind": "function",
              "signature": "(self, description: str, formats: list[TextFormatInfo] = {'arguments': [], 'cls': 'ExprCall', 'function': {'cls': 'ExprName', 'member': None, 'name': 'list'}})",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "self",
                  "type": "",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "description",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "formats",
                  "type": "list[TextFormatInfo]",
                  "default": {
                    "arguments": [],
                    "cls": "ExprCall",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "list"
                    }
                  },
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "to_dict": {
              "name": "to_dict",
              "kind": "function",
              "signature": "(self)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "self",
                  "type": "",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "dict[(str, Any)]"
              },
              "decorators": []
            }
          },
          "attributes": {
            "description": {
              "name": "description",
              "type": "str",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": null
            },
            "formats": {
              "name": "formats",
              "type": "list[TextFormatInfo]",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": {
                "arguments": [
                  {
                    "cls": "ExprKeyword",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "field"
                    },
                    "name": "default_factory",
                    "value": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "list"
                    }
                  }
                ],
                "cls": "ExprCall",
                "function": {
                  "cls": "ExprName",
                  "member": null,
                  "name": "field"
                }
              }
            }
          }
        }
      },
      "functions": {
        "_build_text_representations": {
          "name": "_build_text_representations",
          "kind": "function",
          "signature": "(api: Api)",
          "docstring": {
            "summary": "Build text representations from otext metadata.",
            "description": "Build text representations from otext metadata.\n\nParses otext format specifications to find orig/trans pairs and\ngenerates diverse samples with exhaustive character coverage.\n\nParameters\n----------\napi : Api\n    Context Fabric API instance\n\nReturns\n-------\nTextRepresentationInfo\n    Text representation information with samples",
            "parsed": []
          },
          "parameters": [
            {
              "name": "api",
              "type": "Api",
              "default": null,
              "kind": "positional or keyword"
            }
          ],
          "returns": {
            "type": "TextRepresentationInfo"
          },
          "decorators": []
        },
        "_get_exhaustive_text_samples": {
          "name": "_get_exhaustive_text_samples",
          "kind": "function",
          "signature": "(api: Api, orig_format_name: str, trans_format_name: str, orig_format_spec: str = '')",
          "docstring": {
            "summary": "Get text samples with EXHAUSTIVE character coverage.",
            "description": "Get text samples with EXHAUSTIVE character coverage.\n\nSimple O(n) algorithm: single pass through nodes, greedily collecting\nsamples that introduce new characters. Guarantees complete coverage\nsince we visit all nodes.\n\nParameters\n----------\napi : Api\n    Context Fabric API instance\norig_format_name : str\n    Original script format name (e.g., \"lex-orig-plain\")\ntrans_format_name : str\n    Transliteration format name (e.g., \"lex-trans-plain\")\norig_format_spec : str\n    Unused, kept for API compatibility\n\nReturns\n-------\ntuple[list[TextFormatSample], set[str]]\n    List of samples and set of all covered characters",
            "parsed": []
          },
          "parameters": [
            {
              "name": "api",
              "type": "Api",
              "default": null,
              "kind": "positional or keyword"
            },
            {
              "name": "orig_format_name",
              "type": "str",
              "default": null,
              "kind": "positional or keyword"
            },
            {
              "name": "trans_format_name",
              "type": "str",
              "default": null,
              "kind": "positional or keyword"
            },
            {
              "name": "orig_format_spec",
              "type": "str",
              "default": "''",
              "kind": "positional or keyword"
            }
          ],
          "returns": {
            "type": "tuple[(list[TextFormatSample], set[str])]"
          },
          "decorators": []
        },
        "_parse_otext_format_pairs": {
          "name": "_parse_otext_format_pairs",
          "kind": "function",
          "signature": "(api: Api)",
          "docstring": {
            "summary": "Parse otext metadata to find orig/trans format pairs.",
            "description": "Parse otext metadata to find orig/trans format pairs.\n\nReturns list of (base_name, orig_name, trans_name, orig_spec, trans_spec)",
            "parsed": []
          },
          "parameters": [
            {
              "name": "api",
              "type": "Api",
              "default": null,
              "kind": "positional or keyword"
            }
          ],
          "returns": {
            "type": "list[tuple[(str, str, str, str, str)]]"
          },
          "decorators": []
        },
        "describe_corpus": {
          "name": "describe_corpus",
          "kind": "function",
          "signature": "(api: Api, name: str = '')",
          "docstring": {
            "summary": "Get complete corpus description.",
            "description": "Get complete corpus description.\n\nReturns node types, section structure, text representations with\nexhaustive character coverage, and feature catalogs.\n\nParameters\n----------\napi : Api\n    Context Fabric API instance\nname : str\n    Corpus name for identification\n\nReturns\n-------\nCorpusDescription\n    Complete description including node types, sections,\n    text representations, and feature lists",
            "parsed": []
          },
          "parameters": [
            {
              "name": "api",
              "type": "Api",
              "default": null,
              "kind": "positional or keyword"
            },
            {
              "name": "name",
              "type": "str",
              "default": "''",
              "kind": "positional or keyword"
            }
          ],
          "returns": {
            "type": "CorpusDescription"
          },
          "decorators": []
        },
        "describe_corpus_overview": {
          "name": "describe_corpus_overview",
          "kind": "function",
          "signature": "(api: Api, name: str = '')",
          "docstring": {
            "summary": "Get slim corpus overview (node types and sections only).",
            "description": "Get slim corpus overview (node types and sections only).\n\nUse this for lightweight discovery. For full details including\ntext representations, use describe_corpus().\n\nParameters\n----------\napi : Api\n    Context Fabric API instance\nname : str\n    Corpus name for identification\n\nReturns\n-------\nCorpusOverview\n    Slim overview with node types and sections",
            "parsed": []
          },
          "parameters": [
            {
              "name": "api",
              "type": "Api",
              "default": null,
              "kind": "positional or keyword"
            },
            {
              "name": "name",
              "type": "str",
              "default": "''",
              "kind": "positional or keyword"
            }
          ],
          "returns": {
            "type": "CorpusOverview"
          },
          "decorators": []
        },
        "describe_feature": {
          "name": "describe_feature",
          "kind": "function",
          "signature": "(api: Api, feature: str, sample_limit: int = 20)",
          "docstring": {
            "summary": "Get detailed description of a single feature.",
            "description": "Get detailed description of a single feature.\n\nParameters\n----------\napi : Api\n    Context Fabric API instance\nfeature : str\n    Feature name\nsample_limit : int\n    Maximum sample values to return\n\nReturns\n-------\nFeatureDescription\n    Feature details including samples and node types",
            "parsed": []
          },
          "parameters": [
            {
              "name": "api",
              "type": "Api",
              "default": null,
              "kind": "positional or keyword"
            },
            {
              "name": "feature",
              "type": "str",
              "default": null,
              "kind": "positional or keyword"
            },
            {
              "name": "sample_limit",
              "type": "int",
              "default": "20",
              "kind": "positional or keyword"
            }
          ],
          "returns": {
            "type": "FeatureDescription"
          },
          "decorators": []
        },
        "describe_features": {
          "name": "describe_features",
          "kind": "function",
          "signature": "(api: Api, features: list[str], sample_limit: int = 20)",
          "docstring": {
            "summary": "Get detailed descriptions for multiple features.",
            "description": "Get detailed descriptions for multiple features.\n\nParameters\n----------\napi : Api\n    Context Fabric API instance\nfeatures : list[str]\n    Feature names\nsample_limit : int\n    Maximum sample values per feature\n\nReturns\n-------\ndict[str, FeatureDescription]\n    Feature descriptions keyed by name",
            "parsed": []
          },
          "parameters": [
            {
              "name": "api",
              "type": "Api",
              "default": null,
              "kind": "positional or keyword"
            },
            {
              "name": "features",
              "type": "list[str]",
              "default": null,
              "kind": "positional or keyword"
            },
            {
              "name": "sample_limit",
              "type": "int",
              "default": "20",
              "kind": "positional or keyword"
            }
          ],
          "returns": {
            "type": "dict[(str, FeatureDescription)]"
          },
          "decorators": []
        },
        "describe_text_formats": {
          "name": "describe_text_formats",
          "kind": "function",
          "signature": "(api: Api)",
          "docstring": {
            "summary": "Get text format descriptions with exhaustive character coverage.",
            "description": "Get text format descriptions with exhaustive character coverage.\n\nParameters\n----------\napi : Api\n    Context Fabric API instance\n\nReturns\n-------\nTextRepresentationInfo\n    Text format information with samples",
            "parsed": []
          },
          "parameters": [
            {
              "name": "api",
              "type": "Api",
              "default": null,
              "kind": "positional or keyword"
            }
          ],
          "returns": {
            "type": "TextRepresentationInfo"
          },
          "decorators": []
        },
        "get_all_feature_otypes": {
          "name": "get_all_feature_otypes",
          "kind": "function",
          "signature": "(api: Api, samples_per_type: int = 100)",
          "docstring": {
            "summary": "Pre-compute otype mappings for all features.",
            "description": "Pre-compute otype mappings for all features.\n\nParameters\n----------\napi : Api\n    Context Fabric API instance\nsamples_per_type : int\n    Number of samples to check per node type\n\nReturns\n-------\ndict[str, list[str]]\n    Feature name to list of applicable node types",
            "parsed": []
          },
          "parameters": [
            {
              "name": "api",
              "type": "Api",
              "default": null,
              "kind": "positional or keyword"
            },
            {
              "name": "samples_per_type",
              "type": "int",
              "default": "100",
              "kind": "positional or keyword"
            }
          ],
          "returns": {
            "type": "dict[(str, list[str])]"
          },
          "decorators": []
        },
        "get_feature_otypes": {
          "name": "get_feature_otypes",
          "kind": "function",
          "signature": "(api: Api, feature: str, samples_per_type: int = 100)",
          "docstring": {
            "summary": "Determine which node types a feature applies to.",
            "description": "Determine which node types a feature applies to.\n\nUses C.levels.data to efficiently sample each node type range\nand check for non-null values.\n\nParameters\n----------\napi : Api\n    Context Fabric API instance\nfeature : str\n    Feature name\nsamples_per_type : int\n    Number of samples to check per node type\n\nReturns\n-------\nlist[str]\n    List of node types that have this feature",
            "parsed": []
          },
          "parameters": [
            {
              "name": "api",
              "type": "Api",
              "default": null,
              "kind": "positional or keyword"
            },
            {
              "name": "feature",
              "type": "str",
              "default": null,
              "kind": "positional or keyword"
            },
            {
              "name": "samples_per_type",
              "type": "int",
              "default": "100",
              "kind": "positional or keyword"
            }
          ],
          "returns": {
            "type": "list[str]"
          },
          "decorators": []
        },
        "list_features": {
          "name": "list_features",
          "kind": "function",
          "signature": "(api: Api, kind: str = 'all', node_types: list[str] | None = None)",
          "docstring": {
            "summary": "List features with optional filtering.",
            "description": "List features with optional filtering.\n\nReturns lightweight catalog for discovery. Use node_types to filter\nby object type. For full details with samples, use describe_feature().\n\nParameters\n----------\napi : Api\n    Context Fabric API instance\nkind : str\n    Filter by \"all\", \"node\", or \"edge\"\nnode_types : list[str] | None\n    Filter to features for these types (e.g., [\"word\"])\n\nReturns\n-------\nlist[FeatureCatalogEntry]\n    List of features with name, kind, value_type, description",
            "parsed": []
          },
          "parameters": [
            {
              "name": "api",
              "type": "Api",
              "default": null,
              "kind": "positional or keyword"
            },
            {
              "name": "kind",
              "type": "str",
              "default": "'all'",
              "kind": "positional or keyword"
            },
            {
              "name": "node_types",
              "type": "list[str] | None",
              "default": "None",
              "kind": "positional or keyword"
            }
          ],
          "returns": {
            "type": "list[FeatureCatalogEntry]"
          },
          "decorators": []
        }
      },
      "modules": {},
      "aliases": {
        "Any": {
          "name": "Any",
          "target": "typing.Any"
        },
        "Api": {
          "name": "Api",
          "target": "cfabric.core.api.Api"
        },
        "TYPE_CHECKING": {
          "name": "TYPE_CHECKING",
          "target": "typing.TYPE_CHECKING"
        },
        "annotations": {
          "name": "annotations",
          "target": "__future__.annotations"
        },
        "dataclass": {
          "name": "dataclass",
          "target": "dataclasses.dataclass"
        },
        "defaultdict": {
          "name": "defaultdict",
          "target": "collections.defaultdict"
        },
        "field": {
          "name": "field",
          "target": "dataclasses.field"
        }
      }
    },
    "downloader": {
      "name": "downloader",
      "kind": "module",
      "path": "",
      "docstring": {
        "summary": "Corpus downloader for Context-Fabric.",
        "description": "Corpus downloader for Context-Fabric.\n\nThis module provides functionality to download corpora from Hugging Face Hub.\n\nUsage:\n    >>> import cfabric\n    >>> path = cfabric.download('bhsa')\n    >>> CF = cfabric.Fabric(locations=path)\n\nSee corpus-distribution-plan.md for full documentation.",
        "parsed": []
      },
      "classes": {},
      "functions": {},
      "modules": {
        "download": {
          "name": "download",
          "kind": "module",
          "path": "",
          "docstring": {
            "summary": "Download functionality for Context-Fabric corpora.",
            "description": "Download functionality for Context-Fabric corpora.\n\nThis module provides the main download function for fetching corpora\nfrom Hugging Face Hub.",
            "parsed": []
          },
          "classes": {},
          "functions": {
            "download": {
              "name": "download",
              "kind": "function",
              "signature": "(corpus_id: str, revision: str | None = None, force: bool = False, compiled_only: bool = False)",
              "docstring": {
                "summary": "Download a corpus from Hugging Face Hub.",
                "description": "Download a corpus from Hugging Face Hub.\n\nArgs:\n    corpus_id: Either a short name from the registry (e.g., 'bhsa')\n        or a full HF repo ID (e.g., 'etcbc/cfabric-bhsa').\n    revision: Specific version (tag, branch, or commit hash).\n        If None, downloads the latest version.\n    force: Re-download even if cached locally.\n    compiled_only: Only download .cfm files (faster load, skip .tf source).\n\nReturns:\n    Path to the downloaded corpus directory.\n\nRaises:\n    ValueError: If corpus_id is not found and doesn't look like a repo ID.\n    ImportError: If huggingface_hub is not installed.\n\nExample:\n    >>> import cfabric\n    >>> path = cfabric.download('bhsa')\n    >>> CF = cfabric.Fabric(locations=path)\n\n    >>> # Or with full repo ID for community corpora\n    >>> path = cfabric.download('researcher/cfabric-my-corpus')\n\n    >>> # Pin to specific version\n    >>> path = cfabric.download('bhsa', revision='v2023.1')",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "corpus_id",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "revision",
                  "type": "str | None",
                  "default": "None",
                  "kind": "keyword-only"
                },
                {
                  "name": "force",
                  "type": "bool",
                  "default": "False",
                  "kind": "keyword-only"
                },
                {
                  "name": "compiled_only",
                  "type": "bool",
                  "default": "False",
                  "kind": "keyword-only"
                }
              ],
              "returns": {
                "type": "Path"
              },
              "decorators": []
            }
          },
          "modules": {},
          "aliases": {
            "Path": {
              "name": "Path",
              "target": "pathlib.Path"
            },
            "_resolve_corpus_id": {
              "name": "_resolve_corpus_id",
              "target": "cfabric.downloader.registry._resolve_corpus_id"
            },
            "annotations": {
              "name": "annotations",
              "target": "__future__.annotations"
            }
          }
        },
        "paths": {
          "name": "paths",
          "kind": "module",
          "path": "",
          "docstring": {
            "summary": "Path management for Context-Fabric corpus cache.",
            "description": "Path management for Context-Fabric corpus cache.\n\nThis module provides utilities for managing the local cache directory\nwhere downloaded corpora are stored.",
            "parsed": []
          },
          "classes": {},
          "functions": {
            "clear_cache": {
              "name": "clear_cache",
              "kind": "function",
              "signature": "(corpus_id: str | None = None)",
              "docstring": {
                "summary": "Clear downloaded corpus cache.",
                "description": "Clear downloaded corpus cache.\n\nArgs:\n    corpus_id: Specific corpus to clear, or None for all.\n        Note: This only clears the cfabric-specific cache.\n        To clear huggingface_hub cache, use their cache management.\n\nNote:\n    This is a stub - full implementation requires huggingface_hub\n    cache management integration.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "corpus_id",
                  "type": "str | None",
                  "default": "None",
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "get_cache_dir": {
              "name": "get_cache_dir",
              "kind": "function",
              "signature": "()",
              "docstring": {
                "summary": "Get the cfabric cache directory.",
                "description": "Get the cfabric cache directory.\n\nResolution order:\n    1. CFABRIC_CACHE environment variable\n    2. Platform-specific cache directory via platformdirs\n\nNote:\n    By default, huggingface_hub caches to ~/.cache/huggingface/\n    This function returns the cfabric-specific cache for any\n    additional local data.\n\nReturns:\n    Path to the cache directory.\n\nExample:\n    >>> from cfabric.downloader import get_cache_dir\n    >>> cache = get_cache_dir()\n    >>> print(cache)\n    /Users/username/.cache/cfabric",
                "parsed": []
              },
              "parameters": [],
              "returns": {
                "type": "Path"
              },
              "decorators": []
            }
          },
          "modules": {},
          "aliases": {
            "Path": {
              "name": "Path",
              "target": "pathlib.Path"
            },
            "annotations": {
              "name": "annotations",
              "target": "__future__.annotations"
            },
            "os": {
              "name": "os",
              "target": "os"
            }
          }
        },
        "registry": {
          "name": "registry",
          "kind": "module",
          "path": "",
          "docstring": {
            "summary": "Corpus registry for Context-Fabric.",
            "description": "Corpus registry for Context-Fabric.\n\nThis module maintains a registry of known corpora that can be\ndownloaded using short names.",
            "parsed": []
          },
          "classes": {},
          "functions": {
            "_resolve_corpus_id": {
              "name": "_resolve_corpus_id",
              "kind": "function",
              "signature": "(corpus_id: str)",
              "docstring": {
                "summary": "Resolve short name to full HF repo ID.",
                "description": "Resolve short name to full HF repo ID.\n\nArgs:\n    corpus_id: Either a short name from CORPUS_REGISTRY or a full\n        Hugging Face repo ID (format: username/repo-name).\n\nReturns:\n    Full Hugging Face repo ID.\n\nRaises:\n    ValueError: If corpus_id is not found in registry and doesn't\n        look like a full repo ID.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "corpus_id",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "str"
              },
              "decorators": []
            },
            "list_corpora": {
              "name": "list_corpora",
              "kind": "function",
              "signature": "()",
              "docstring": {
                "summary": "List registered corpora with metadata.",
                "description": "List registered corpora with metadata.\n\nReturns:\n    Dictionary mapping corpus short names to their metadata.\n\nExample:\n    >>> from cfabric.downloader import list_corpora\n    >>> for name, info in list_corpora().items():\n    ...     print(f\"{name}: {info['description']}\")",
                "parsed": []
              },
              "parameters": [],
              "returns": {
                "type": "dict[(str, dict[(str, str)])]"
              },
              "decorators": []
            }
          },
          "modules": {},
          "aliases": {
            "annotations": {
              "name": "annotations",
              "target": "__future__.annotations"
            }
          }
        }
      },
      "aliases": {
        "CORPUS_REGISTRY": {
          "name": "CORPUS_REGISTRY",
          "target": "cfabric.downloader.registry.CORPUS_REGISTRY"
        },
        "get_cache_dir": {
          "name": "get_cache_dir",
          "target": "cfabric.downloader.paths.get_cache_dir"
        },
        "list_corpora": {
          "name": "list_corpora",
          "target": "cfabric.downloader.registry.list_corpora"
        }
      }
    },
    "features": {
      "name": "features",
      "kind": "module",
      "path": "",
      "docstring": {
        "summary": "Feature data models for Context-Fabric.",
        "description": "Feature data models for Context-Fabric.\n\nThis module provides access to node features, edge features, and computed data.",
        "parsed": []
      },
      "classes": {},
      "functions": {},
      "modules": {
        "computed": {
          "name": "computed",
          "kind": "module",
          "path": "",
          "docstring": {
            "summary": "# Pre-computed data components",
            "description": "# Pre-computed data components\n\nIn order to make the API work, CF prepares some data and saves it in\nquick-load format. Most of this data are the features, but there is some extra\ndata needed for the special functions of the `cfabric.parameters.WARP` features and the\n`cfabric.locality.Locality` API.\n\nNormally, you do not use this data, but since it is there, it might be valuable,\nso we have made it accessible in the `cfabric.computed.Computeds`-API.\n\n!!! explanation \"Pre-computed data storage\"\n    Pre-computed data is stored in a `.cfm` directory (Context Fabric Mmap format)\n    inside the directory where the `otype` feature is encountered.\n\n    The `.cfm` format uses memory-mapped numpy arrays for:\n    - Shared memory across async workers\n    - Reduced memory footprint\n    - Near-zero startup time after initial compilation\n\n    Use `CF.compile()` to generate the `.cfm` directory from `.tf` source files.\n    Subsequent calls to `CF.load()` will automatically use the compiled format.",
            "parsed": []
          },
          "classes": {
            "BoundaryComputed": {
              "name": "BoundaryComputed",
              "kind": "class",
              "path": "",
              "docstring": {
                "summary": "C.boundary: first/last slot boundary data.",
                "description": "C.boundary: first/last slot boundary data.",
                "parsed": []
              },
              "bases": [
                "Computed"
              ],
              "methods": {},
              "attributes": {}
            },
            "Computed": {
              "name": "Computed",
              "kind": "class",
              "path": "",
              "docstring": {
                "summary": "Provides access to pre-computed data.",
                "description": "Provides access to pre-computed data.\n\nFor component `ccc` it is the result of `C.ccc` or `Cs('ccc')`.",
                "parsed": []
              },
              "bases": [],
              "methods": {
                "__init__": {
                  "name": "__init__",
                  "kind": "function",
                  "signature": "(self, api: Api, data: Any)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "api",
                      "type": "Api",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "data",
                      "type": "Any",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                }
              },
              "attributes": {
                "api": {
                  "name": "api",
                  "type": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "api"
                  }
                },
                "data": {
                  "name": "data",
                  "type": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "data"
                  }
                }
              }
            },
            "Computeds": {
              "name": "Computeds",
              "kind": "class",
              "path": "",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "bases": [],
              "methods": {},
              "attributes": {}
            },
            "LevDownComputed": {
              "name": "LevDownComputed",
              "kind": "class",
              "path": "",
              "docstring": {
                "summary": "C.levDown: embeddees of each node.",
                "description": "C.levDown: embeddees of each node.\n\nSupports CSRArray backend for mmap.\nOnly for non-slot nodes, so index is n - maxSlot - 1.\n\nFor faster embedding queries, call `preload()` to cache data in RAM.\nThis trades ~40MB memory for 3x faster `[[` relation queries.",
                "parsed": []
              },
              "bases": [
                "Computed"
              ],
              "methods": {
                "__getitem__": {
                  "name": "__getitem__",
                  "kind": "function",
                  "signature": "(self, n: int)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "n",
                      "type": "int",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "tuple[(int, ...)]"
                  },
                  "decorators": []
                },
                "preload": {
                  "name": "preload",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "Preload embedding data into RAM for faster queries.",
                    "description": "Preload embedding data into RAM for faster queries.\n\nThis caches the CSR data in memory, giving ~3x speedup on\nembedding queries (`[[` relation) at the cost of ~40MB RAM.\n\nCall `release()` to free the cached memory.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "release": {
                  "name": "release",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "Release cached RAM, returning to memory-mapped access.",
                    "description": "Release cached RAM, returning to memory-mapped access.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                }
              },
              "attributes": {
                "is_cached": {
                  "name": "is_cached",
                  "type": "bool",
                  "docstring": {
                    "summary": "Return True if data is cached in RAM.",
                    "description": "Return True if data is cached in RAM.",
                    "parsed": []
                  },
                  "value": null
                }
              }
            },
            "LevUpComputed": {
              "name": "LevUpComputed",
              "kind": "class",
              "path": "",
              "docstring": {
                "summary": "C.levUp: embedders of each node.",
                "description": "C.levUp: embedders of each node.\n\nSupports CSRArray backend for mmap.\n\nFor faster embedding queries, call `preload()` to cache data in RAM.\nThis trades ~60MB memory for 3x faster `]]` relation queries.",
                "parsed": []
              },
              "bases": [
                "Computed"
              ],
              "methods": {
                "__getitem__": {
                  "name": "__getitem__",
                  "kind": "function",
                  "signature": "(self, n: int)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "n",
                      "type": "int",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "tuple[(int, ...)]"
                  },
                  "decorators": []
                },
                "preload": {
                  "name": "preload",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "Preload embedding data into RAM for faster queries.",
                    "description": "Preload embedding data into RAM for faster queries.\n\nThis caches the CSR data in memory, giving ~3x speedup on\nembedding queries (`]]` relation) at the cost of ~60MB RAM.\n\nCall `release()` to free the cached memory.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "release": {
                  "name": "release",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "Release cached RAM, returning to memory-mapped access.",
                    "description": "Release cached RAM, returning to memory-mapped access.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                }
              },
              "attributes": {
                "is_cached": {
                  "name": "is_cached",
                  "type": "bool",
                  "docstring": {
                    "summary": "Return True if data is cached in RAM.",
                    "description": "Return True if data is cached in RAM.",
                    "parsed": []
                  },
                  "value": null
                }
              }
            },
            "LevelsComputed": {
              "name": "LevelsComputed",
              "kind": "class",
              "path": "",
              "docstring": {
                "summary": "C.levels: node type hierarchy data.",
                "description": "C.levels: node type hierarchy data.",
                "parsed": []
              },
              "bases": [
                "Computed"
              ],
              "methods": {},
              "attributes": {}
            },
            "OrderComputed": {
              "name": "OrderComputed",
              "kind": "class",
              "path": "",
              "docstring": {
                "summary": "C.order: nodes in canonical order.",
                "description": "C.order: nodes in canonical order.\n\nSupports numpy array backend for mmap.\ndata[i] gives node at position i.",
                "parsed": []
              },
              "bases": [
                "Computed"
              ],
              "methods": {
                "__getitem__": {
                  "name": "__getitem__",
                  "kind": "function",
                  "signature": "(self, i: int)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "i",
                      "type": "int",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "int"
                  },
                  "decorators": []
                },
                "__iter__": {
                  "name": "__iter__",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "Iterator[int]"
                  },
                  "decorators": []
                },
                "__len__": {
                  "name": "__len__",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "int"
                  },
                  "decorators": []
                }
              },
              "attributes": {}
            },
            "RankComputed": {
              "name": "RankComputed",
              "kind": "class",
              "path": "",
              "docstring": {
                "summary": "C.rank: canonical position of each node.",
                "description": "C.rank: canonical position of each node.\n\nSupports numpy array backend for mmap.\ndata[n-1] gives rank of node n.",
                "parsed": []
              },
              "bases": [
                "Computed"
              ],
              "methods": {
                "__getitem__": {
                  "name": "__getitem__",
                  "kind": "function",
                  "signature": "(self, n: int)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "n",
                      "type": "int",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "int"
                  },
                  "decorators": []
                }
              },
              "attributes": {}
            }
          },
          "functions": {},
          "modules": {},
          "aliases": {
            "Any": {
              "name": "Any",
              "target": "typing.Any"
            },
            "Api": {
              "name": "Api",
              "target": "cfabric.core.api.Api"
            },
            "CSRArray": {
              "name": "CSRArray",
              "target": "cfabric.storage.csr.CSRArray"
            },
            "Iterator": {
              "name": "Iterator",
              "target": "collections.abc.Iterator"
            },
            "TYPE_CHECKING": {
              "name": "TYPE_CHECKING",
              "target": "typing.TYPE_CHECKING"
            },
            "annotations": {
              "name": "annotations",
              "target": "__future__.annotations"
            }
          }
        },
        "edge": {
          "name": "edge",
          "kind": "module",
          "path": "",
          "docstring": {
            "summary": "Mappings from edges to values.",
            "description": "Mappings from edges to values.\n\nEvery edge feature is logically a mapping from pairs of nodes to values,\nstring or integer.\n\nA feature object gives you methods that you can pass a node and that returns\nits value for that node.\n\nIt is easiest to think of all edge features as a dictionary keyed by nodes.\nThe values are either sets or dictionaries.\nIf the value is a set, then the elements are the second node in the pair\nand the value is `None`.\nIf the value is a dictionary, then the keys are the second node in the pair,\nand the value is the value that the edge feature assigns to this pair.\n\nHowever, some features have an optimised representation, and do not have\na dictionary underneath.\n\nBut you can still iterate over the data of a feature as if it were a\ndictionary: `cfabric.edgefeature.EdgeFeature.items`\n\nThis module supports two storage backends:\n- Dict-based storage (.tf loading): dict[int, set|dict]\n- CSR mmap-based storage (.cfm loading): CSRArray or CSRArrayWithValues",
            "parsed": []
          },
          "classes": {
            "EdgeFeature": {
              "name": "EdgeFeature",
              "kind": "class",
              "path": "",
              "docstring": {
                "summary": "Provides access to (edge) feature data.",
                "description": "Provides access to (edge) feature data.\n\nFor feature `fff` it is the result of `E.fff` or `Es('fff')`.\n\nThis class supports two storage backends:\n- Dict-based (.tf loading): dict[int, set|dict]\n- Mmap (.cfm loading): CSRArray or CSRArrayWithValues for memory-mapped access\n\nThe backend is auto-detected based on the data type passed to __init__.",
                "parsed": []
              },
              "bases": [],
              "methods": {
                "__init__": {
                  "name": "__init__",
                  "kind": "function",
                  "signature": "(self, api: Api, metaData: dict[(str, Any)], data: dict[(int, set[int] | dict[(int, Any)])] | CSRArray | CSRArrayWithValues | tuple[(Any, Any)], doValues: bool, dataInv: CSRArray | CSRArrayWithValues | None = None)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "api",
                      "type": "Api",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "metaData",
                      "type": "dict[(str, Any)]",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "data",
                      "type": "dict[(int, set[int] | dict[(int, Any)])] | CSRArray | CSRArrayWithValues | tuple[(Any, Any)]",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "doValues",
                      "type": "bool",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "dataInv",
                      "type": "CSRArray | CSRArrayWithValues | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "_convert_dict_sentinels": {
                  "name": "_convert_dict_sentinels",
                  "kind": "function",
                  "signature": "(self, d: dict[(int, Any)])",
                  "docstring": {
                    "summary": "Convert all sentinel values in a dict to None.",
                    "description": "Convert all sentinel values in a dict to None.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "d",
                      "type": "dict[(int, Any)]",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "dict[(int, Any)]"
                  },
                  "decorators": []
                },
                "_convert_sentinel_to_none": {
                  "name": "_convert_sentinel_to_none",
                  "kind": "function",
                  "signature": "(self, val: Any)",
                  "docstring": {
                    "summary": "Convert sentinel value back to None for int edge values.",
                    "description": "Convert sentinel value back to None for int edge values.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "val",
                      "type": "Any",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "Any"
                  },
                  "decorators": []
                },
                "_get_forward_edges": {
                  "name": "_get_forward_edges",
                  "kind": "function",
                  "signature": "(self, n: int)",
                  "docstring": {
                    "summary": "Get raw forward edges for node n.",
                    "description": "Get raw forward edges for node n.\n\nReturns:\n    For edges without values: set or numpy array of target nodes\n    For edges with values: dict with sentinel values converted to None",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "n",
                      "type": "int",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "set[int] | dict[(int, Any)] | Any | None"
                  },
                  "decorators": []
                },
                "_get_inverse_edges": {
                  "name": "_get_inverse_edges",
                  "kind": "function",
                  "signature": "(self, n: int)",
                  "docstring": {
                    "summary": "Get raw inverse edges for node n.",
                    "description": "Get raw inverse edges for node n.\n\nReturns:\n    For edges without values: set or numpy array of source nodes\n    For edges with values: dict with sentinel values converted to None",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "n",
                      "type": "int",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "set[int] | dict[(int, Any)] | Any | None"
                  },
                  "decorators": []
                },
                "_has_forward_edges": {
                  "name": "_has_forward_edges",
                  "kind": "function",
                  "signature": "(self, n: int)",
                  "docstring": {
                    "summary": "Check if node n has any forward edges.",
                    "description": "Check if node n has any forward edges.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "n",
                      "type": "int",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "bool"
                  },
                  "decorators": []
                },
                "_has_inverse_edges": {
                  "name": "_has_inverse_edges",
                  "kind": "function",
                  "signature": "(self, n: int)",
                  "docstring": {
                    "summary": "Check if node n has any inverse edges.",
                    "description": "Check if node n has any inverse edges.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "n",
                      "type": "int",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "bool"
                  },
                  "decorators": []
                },
                "_materialize_forward": {
                  "name": "_materialize_forward",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "Convert forward CSR data to dict format.",
                    "description": "Convert forward CSR data to dict format.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "dict[(int, set[int] | dict[(int, Any)])]"
                  },
                  "decorators": []
                },
                "_materialize_inverse": {
                  "name": "_materialize_inverse",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "Convert inverse CSR data to dict format.",
                    "description": "Convert inverse CSR data to dict format.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "dict[(int, set[int] | dict[(int, Any)])]"
                  },
                  "decorators": []
                },
                "b": {
                  "name": "b",
                  "kind": "function",
                  "signature": "(self, n: int)",
                  "docstring": {
                    "summary": "Query *both* incoming edges to, and outgoing edges from a node.",
                    "description": "Query *both* incoming edges to, and outgoing edges from a node.\n\nThe edges are those pairs of nodes specified in the feature data,\nwhose first or second node is the `n`.\n\nParameters\n----------\nnode: integer\n    The node **from** which the edges in question start or\n    **to** which the edges in question connect.\n\nReturns\n-------\nset | dict\n    The nodes where the edges **to** a certain node start.\n    The members of the result are just nodes, if this feature does not\n    assign values to edges.\n    Otherwise the members are tuples of the start node and the\n    value that the feature assigns to this pair of nodes.\n\n    If there are no edges to the node, the empty tuple is returned,\n    rather than `None`.\n\nNotes\n-----\n!!! hint \"symmetric closure\"\n    This method gives the *symmetric closure* of a set of edges:\n    if there is an edge between `n` and `m`, this method will deliver\n    its value, no matter the direction of the edge.\n\n!!! example \"symmetric edges\"\n    Some edge sets are semantically symmetric, for example *similarity*.\n    If `n` is similar to `m`, then `m` is similar to `n`.\n\n    But if you store such an edge feature completely,\n    half of the data is redundant.\n    By virtue of this method you do not have to do that, you only need to store\n    one of the edges between `n` and `m` (it does not matter which one),\n    and `E.fff.b(n)` will nevertheless produce the complete results.\n\n!!! caution \"conflicting values\"\n    If your set of edges is not symmetric, and edges carry values, it might\n    very well be the case that edges between the same pair of nodes carry\n    different values for the two directions.\n\n    In that case, this method gives precedence to the edges that\n    *depart* from the node to those that go *to* the node.\n\n!!! example \"conflicting values\"\n    Suppose we have\n\n        n == value=4 ==> m\n        m == value=6 ==> n\n\n    then\n\n        E.b(n) = (m, 4)\n        E.b(m) = (n, 6)",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "n",
                      "type": "int",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "tuple[(int, ...)] | tuple[(tuple[(int, Any)], ...)]"
                  },
                  "decorators": []
                },
                "f": {
                  "name": "f",
                  "kind": "function",
                  "signature": "(self, n: int)",
                  "docstring": {
                    "summary": "Get outgoing edges *from* a node.",
                    "description": "Get outgoing edges *from* a node.\n\nThe edges are those pairs of nodes specified in the feature data,\nwhose first node is the `n`.\n\nParameters\n----------\nnode: integer\n    The node **from** which the edges in question start.\n\nReturns\n-------\nset | tuple\n    The nodes reached by the edges **from** a certain node.\n    The members of the result are just nodes, if this feature does not\n    assign values to edges.\n    Otherwise the members are tuples of the destination node and the\n    value that the feature assigns to this pair of nodes.\n\n    If there are no edges from the node, the empty tuple is returned,\n    rather than `None`.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "n",
                      "type": "int",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "tuple[(int, ...)] | tuple[(tuple[(int, Any)], ...)]"
                  },
                  "decorators": []
                },
                "freqList": {
                  "name": "freqList",
                  "kind": "function",
                  "signature": "(self, nodeTypesFrom: set[str] | None = None, nodeTypesTo: set[str] | None = None)",
                  "docstring": {
                    "summary": "Frequency list of the values of this feature.",
                    "description": "Frequency list of the values of this feature.\n\nInspect the values of this feature and see how often they occur.\n\nIf the feature does not assign values, return the number of node pairs\nin this edge.\n\nIf the edge feature does have values, inspect them and see\nhow often they occur.\nThe result is a list of pairs `(value, frequency)`, ordered by `frequency`,\nhighest frequencies first.\n\nParameters\n----------\nnodeTypesFrom: set of string, optional None\n    If you pass a set of node types here, only the values for edges\n    that start *from* a node with such a type will be counted.\nnodeTypesTo: set of string, optional None\n    If you pass a set of node types here, only the values for edges\n    that go *to* a node with such a type will be counted.\n\nReturns\n-------\ntuple of 2-tuple\n    A tuple of `(value, frequency)`, items, ordered by `frequency`,\n    highest frequencies first.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "nodeTypesFrom",
                      "type": "set[str] | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "nodeTypesTo",
                      "type": "set[str] | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "tuple[(tuple[(Any, int)], ...)] | int"
                  },
                  "decorators": []
                },
                "items": {
                  "name": "items",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "A generator that yields the items of the feature, seen as a mapping.",
                    "description": "A generator that yields the items of the feature, seen as a mapping.\n\nThis gives you a rather efficient way to iterate over\njust the feature data.\n\nIf you need this repeatedly, or you need the whole dictionary,\nyou can store the result as follows:\n\n   data = dict(E.fff.items())",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "Iterator[tuple[(int, set[int] | dict[(int, Any)])]]"
                  },
                  "decorators": []
                },
                "t": {
                  "name": "t",
                  "kind": "function",
                  "signature": "(self, n: int)",
                  "docstring": {
                    "summary": "Get incoming edges *to* a node.",
                    "description": "Get incoming edges *to* a node.\n\nThe edges are those pairs of nodes specified in the feature data,\nwhose second node is the `n`.\n\nParameters\n----------\nnode: integer\n    The node **to** which the edges in question connect.\n\nReturns\n-------\nset | tuple\n    The nodes where the edges **to** a certain node start.\n    The members of the result are just nodes, if this feature does not\n    assign values to edges.\n    Otherwise the members are tuples of the start node and the\n    value that the feature assigns to this pair of nodes.\n\n    If there are no edges to the node, the empty tuple is returned,\n    rather than `None`.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "n",
                      "type": "int",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "tuple[(int, ...)] | tuple[(tuple[(int, Any)], ...)]"
                  },
                  "decorators": []
                }
              },
              "attributes": {
                "_data": {
                  "name": "_data",
                  "type": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "data"
                  }
                },
                "_dataInv": {
                  "name": "_dataInv",
                  "type": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "dataInv"
                  }
                },
                "_is_mmap": {
                  "name": "_is_mmap",
                  "type": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": "True"
                },
                "_none_sentinel": {
                  "name": "_none_sentinel",
                  "type": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "arguments": [
                      "'none_sentinel'"
                    ],
                    "cls": "ExprCall",
                    "function": {
                      "cls": "ExprAttribute",
                      "values": [
                        {
                          "cls": "ExprName",
                          "member": null,
                          "name": "metaData"
                        },
                        {
                          "cls": "ExprName",
                          "member": null,
                          "name": "get"
                        }
                      ]
                    }
                  }
                },
                "api": {
                  "name": "api",
                  "type": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "api"
                  }
                },
                "data": {
                  "name": "data",
                  "type": "dict[(int, set[int] | dict[(int, Any)])]",
                  "docstring": {
                    "summary": "Get forward edge data.",
                    "description": "Get forward edge data.\n\nFor dict-based backend (.tf), returns the dict directly.\nFor mmap backend (.cfm), materializes CSR to dict (for backward compatibility).",
                    "parsed": []
                  },
                  "value": null
                },
                "dataInv": {
                  "name": "dataInv",
                  "type": "dict[(int, set[int] | dict[(int, Any)])]",
                  "docstring": {
                    "summary": "Get inverse edge data.",
                    "description": "Get inverse edge data.\n\nFor dict-based backend (.tf), returns the dict directly.\nFor mmap backend (.cfm), materializes CSR to dict (for backward compatibility).",
                    "parsed": []
                  },
                  "value": null
                },
                "doValues": {
                  "name": "doValues",
                  "type": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "doValues"
                  }
                },
                "meta": {
                  "name": "meta",
                  "type": "",
                  "docstring": {
                    "summary": "Metadata of the feature.",
                    "description": "Metadata of the feature.\n\nThis is the information found in the lines starting with `@`\nin the `.tf` feature file.",
                    "parsed": []
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "metaData"
                  }
                }
              }
            },
            "EdgeFeatures": {
              "name": "EdgeFeatures",
              "kind": "class",
              "path": "",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "bases": [],
              "methods": {},
              "attributes": {}
            }
          },
          "functions": {},
          "modules": {},
          "aliases": {
            "Any": {
              "name": "Any",
              "target": "typing.Any"
            },
            "Api": {
              "name": "Api",
              "target": "cfabric.core.api.Api"
            },
            "CSRArray": {
              "name": "CSRArray",
              "target": "cfabric.storage.csr.CSRArray"
            },
            "CSRArrayWithValues": {
              "name": "CSRArrayWithValues",
              "target": "cfabric.storage.csr.CSRArrayWithValues"
            },
            "Iterator": {
              "name": "Iterator",
              "target": "collections.abc.Iterator"
            },
            "TYPE_CHECKING": {
              "name": "TYPE_CHECKING",
              "target": "typing.TYPE_CHECKING"
            },
            "annotations": {
              "name": "annotations",
              "target": "__future__.annotations"
            },
            "collections": {
              "name": "collections",
              "target": "collections"
            },
            "makeInverse": {
              "name": "makeInverse",
              "target": "cfabric.utils.helpers.makeInverse"
            },
            "makeInverseVal": {
              "name": "makeInverseVal",
              "target": "cfabric.utils.helpers.makeInverseVal"
            },
            "safe_rank_key": {
              "name": "safe_rank_key",
              "target": "cfabric.utils.helpers.safe_rank_key"
            }
          }
        },
        "node": {
          "name": "node",
          "kind": "module",
          "path": "",
          "docstring": {
            "summary": "# Mappings from nodes to values.",
            "description": "# Mappings from nodes to values.\n\nEvery node feature is logically a mapping from nodes to values,\nstring or integer.\n\nA feature object gives you methods that you can pass a node and that returns\nits value for that node.\n\nIt is easiest to think of all node features as a dictionary keyed by nodes.\n\nHowever, some features have an optimised representation, and do not have\na dictionary underneath.\n\nBut you can still iterate over the data of a feature as if it were a\ndictionary: `cfabric.nodefeature.NodeFeature.items`",
            "parsed": []
          },
          "classes": {
            "NodeFeature": {
              "name": "NodeFeature",
              "kind": "class",
              "path": "",
              "docstring": {
                "summary": "Provides access to (node) feature data.",
                "description": "Provides access to (node) feature data.\n\nFor feature `fff` it is the result of `F.fff` or `Fs('fff')`.\n\nSupports both dict-based storage (.tf loading) and mmap-based backends (.cfm loading)\n(StringPool for string features, IntFeatureArray for int features).",
                "parsed": []
              },
              "bases": [],
              "methods": {
                "__init__": {
                  "name": "__init__",
                  "kind": "function",
                  "signature": "(self, api: Api, metaData: dict[(str, str)], data: dict[(int, str | int)] | StringPool | IntFeatureArray)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "api",
                      "type": "Api",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "metaData",
                      "type": "dict[(str, str)]",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "data",
                      "type": "dict[(int, str | int)] | StringPool | IntFeatureArray",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "_materialize": {
                  "name": "_materialize",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "Convert mmap storage to dict (cached).",
                    "description": "Convert mmap storage to dict (cached).\n\nReturns\n-------\ndict\n    Dictionary mapping nodes to their values.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "dict[(int, str | int)]"
                  },
                  "decorators": []
                },
                "freqList": {
                  "name": "freqList",
                  "kind": "function",
                  "signature": "(self, nodeTypes: set[str] | None = None)",
                  "docstring": {
                    "summary": "Frequency list of the values of this feature.",
                    "description": "Frequency list of the values of this feature.\n\nInspect the values of this feature and see how often they occur.\n\nParameters\n----------\nnodeTypes: set of string, optional None\n    If you pass a set of node types, only the values for nodes\n    within those types will be counted.\n\nReturns\n-------\ntuple of 2-tuple\n    A tuple of `(value, frequency)`, items, ordered by `frequency`,\n    highest frequencies first.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "nodeTypes",
                      "type": "set[str] | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "tuple[(tuple[(str | int, int)], ...)]"
                  },
                  "decorators": []
                },
                "items": {
                  "name": "items",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "A generator that yields the items of the feature, seen as a mapping.",
                    "description": "A generator that yields the items of the feature, seen as a mapping.\n\nIt does not yield entries for nodes without values,\nso this gives you a rather efficient way to iterate over\njust the feature data, instead of over all nodes.\n\nIf you need this repeatedly, or you need the whole dictionary,\nyou can store the result as follows:\n\n   data = dict(F.fff.items())",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "Iterator[tuple[(int, str | int)]]"
                  },
                  "decorators": []
                },
                "s": {
                  "name": "s",
                  "kind": "function",
                  "signature": "(self, val: str | int)",
                  "docstring": {
                    "summary": "Query all nodes having a specified feature value.",
                    "description": "Query all nodes having a specified feature value.\n\nThis is an other way to walk through nodes than using\n`cfabric.nodes.Nodes.walk`.\n\nParameters\n----------\nvalue: integer | string\n    The feature value that all resulting nodes have.\n\nReturns\n-------\ntuple of integer\n    All nodes that have this value for this feature,\n    sorted in the canonical order.\n    (`cfabric.nodes`)",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "val",
                      "type": "str | int",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "tuple[(int, ...)]"
                  },
                  "decorators": []
                },
                "v": {
                  "name": "v",
                  "kind": "function",
                  "signature": "(self, n: int)",
                  "docstring": {
                    "summary": "Get the value of a feature for a node.",
                    "description": "Get the value of a feature for a node.\n\nParameters\n----------\nn: integer\n    The node in question\n\nReturns\n-------\ninteger | string | None\n    The value of the feature for that node, if it is defined, else `None`.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "n",
                      "type": "int",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "str | int | None"
                  },
                  "decorators": []
                }
              },
              "attributes": {
                "_cached_data": {
                  "name": "_cached_data",
                  "type": "dict[(int, str | int)] | None",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": "None"
                },
                "_data": {
                  "name": "_data",
                  "type": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "data"
                  }
                },
                "_is_mmap": {
                  "name": "_is_mmap",
                  "type": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "arguments": [
                      {
                        "cls": "ExprName",
                        "member": null,
                        "name": "data"
                      },
                      {
                        "cls": "ExprTuple",
                        "elements": [
                          {
                            "cls": "ExprName",
                            "member": null,
                            "name": "StringPool"
                          },
                          {
                            "cls": "ExprName",
                            "member": null,
                            "name": "IntFeatureArray"
                          }
                        ],
                        "implicit": false
                      }
                    ],
                    "cls": "ExprCall",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "isinstance"
                    }
                  }
                },
                "api": {
                  "name": "api",
                  "type": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "api"
                  }
                },
                "data": {
                  "name": "data",
                  "type": "dict[(int, str | int)]",
                  "docstring": {
                    "summary": "Get data as dict (for backward compatibility).",
                    "description": "Get data as dict (for backward compatibility).\n\nNote: For mmap backends, this materializes the data into memory.\nUse v() for efficient single lookups.\n\nReturns\n-------\ndict\n    The feature data as a dictionary mapping nodes to values.",
                    "parsed": []
                  },
                  "value": null
                },
                "meta": {
                  "name": "meta",
                  "type": "",
                  "docstring": {
                    "summary": "Metadata of the feature.",
                    "description": "Metadata of the feature.\n\nThis is the information found in the lines starting with `@`\nin the `.tf` feature file.",
                    "parsed": []
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "metaData"
                  }
                }
              }
            },
            "NodeFeatures": {
              "name": "NodeFeatures",
              "kind": "class",
              "path": "",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "bases": [],
              "methods": {},
              "attributes": {}
            }
          },
          "functions": {},
          "modules": {},
          "aliases": {
            "Any": {
              "name": "Any",
              "target": "typing.Any"
            },
            "Api": {
              "name": "Api",
              "target": "cfabric.core.api.Api"
            },
            "IntFeatureArray": {
              "name": "IntFeatureArray",
              "target": "cfabric.storage.string_pool.IntFeatureArray"
            },
            "Iterator": {
              "name": "Iterator",
              "target": "collections.abc.Iterator"
            },
            "StringPool": {
              "name": "StringPool",
              "target": "cfabric.storage.string_pool.StringPool"
            },
            "TYPE_CHECKING": {
              "name": "TYPE_CHECKING",
              "target": "typing.TYPE_CHECKING"
            },
            "annotations": {
              "name": "annotations",
              "target": "__future__.annotations"
            },
            "collections": {
              "name": "collections",
              "target": "collections"
            },
            "safe_rank_key": {
              "name": "safe_rank_key",
              "target": "cfabric.utils.helpers.safe_rank_key"
            }
          }
        },
        "warp": {
          "name": "warp",
          "kind": "module",
          "path": "",
          "docstring": {
            "summary": "Warp features for Context-Fabric.",
            "description": "Warp features for Context-Fabric.\n\nWarp features (otype, oslots) are fundamental structural features\nthat define the node type hierarchy and slot containment.",
            "parsed": []
          },
          "classes": {},
          "functions": {},
          "modules": {
            "oslots": {
              "name": "oslots",
              "kind": "module",
              "path": "",
              "docstring": {
                "summary": "# Access to `oslots` feature data.",
                "description": "# Access to `oslots` feature data.\n\nIn general, features are stored as dictionaries, but this specific feature\nhas an optimised representation. Since it is a large feature and present\nin any CF dataset, this pays off.\n\nSupports two backends:\n- Dict-based tuple format (.tf loading): data = (slots_tuple, maxSlot, maxNode)\n- CSR array format (.cfm loading): data = CSRArray instance",
                "parsed": []
              },
              "classes": {
                "OslotsFeature": {
                  "name": "OslotsFeature",
                  "kind": "class",
                  "path": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "bases": [],
                  "methods": {
                    "__init__": {
                      "name": "__init__",
                      "kind": "function",
                      "signature": "(self, api: Api, metaData: dict[(str, str)], data: tuple[(tuple[(tuple[(int, ...)], ...)], int, int)] | CSRArray, maxSlot: int | None = None, maxNode: int | None = None)",
                      "docstring": {
                        "summary": "Initialize OslotsFeature with either dict-based or CSR backend.",
                        "description": "Initialize OslotsFeature with either dict-based or CSR backend.\n\nParameters\n----------\napi : object\n    The API object\nmetaData : dict\n    Feature metadata\ndata : tuple or CSRArray\n    Either:\n    - Dict-based (.tf): tuple (slots_tuple, maxSlot, maxNode)\n    - CSR: CSRArray instance containing slot data for non-slot nodes\nmaxSlot : int, optional\n    When using CSR backend, the maximum slot node number.\n    Required when data is a CSRArray.\nmaxNode : int, optional\n    When using CSR backend, the maximum node number.\n    Required when data is a CSRArray.",
                        "parsed": []
                      },
                      "parameters": [
                        {
                          "name": "self",
                          "type": "",
                          "default": null,
                          "kind": "positional or keyword"
                        },
                        {
                          "name": "api",
                          "type": "Api",
                          "default": null,
                          "kind": "positional or keyword"
                        },
                        {
                          "name": "metaData",
                          "type": "dict[(str, str)]",
                          "default": null,
                          "kind": "positional or keyword"
                        },
                        {
                          "name": "data",
                          "type": "tuple[(tuple[(tuple[(int, ...)], ...)], int, int)] | CSRArray",
                          "default": null,
                          "kind": "positional or keyword"
                        },
                        {
                          "name": "maxSlot",
                          "type": "int | None",
                          "default": "None",
                          "kind": "positional or keyword"
                        },
                        {
                          "name": "maxNode",
                          "type": "int | None",
                          "default": "None",
                          "kind": "positional or keyword"
                        }
                      ],
                      "returns": {
                        "type": "None"
                      },
                      "decorators": []
                    },
                    "items": {
                      "name": "items",
                      "kind": "function",
                      "signature": "(self)",
                      "docstring": {
                        "summary": "A generator that yields the non-slot nodes with their slots.",
                        "description": "A generator that yields the non-slot nodes with their slots.",
                        "parsed": []
                      },
                      "parameters": [
                        {
                          "name": "self",
                          "type": "",
                          "default": null,
                          "kind": "positional or keyword"
                        }
                      ],
                      "returns": {
                        "type": "Iterator[tuple[(int, tuple[(int, ...)])]]"
                      },
                      "decorators": []
                    },
                    "s": {
                      "name": "s",
                      "kind": "function",
                      "signature": "(self, n: int)",
                      "docstring": {
                        "summary": "Get the slots of a (non-slot) node.",
                        "description": "Get the slots of a (non-slot) node.\n\nParameters\n----------\nnode: integer\n    The node whose slots must be retrieved.\n\nReturns\n-------\ntuple\n    The slot nodes of the node in question, in canonical order.\n    (`cfabric.nodes`)\n\n    For slot nodes `n` it is the tuple `(n,)`.\n\n    All non-slot nodes are linked to at least one slot.",
                        "parsed": []
                      },
                      "parameters": [
                        {
                          "name": "self",
                          "type": "",
                          "default": null,
                          "kind": "positional or keyword"
                        },
                        {
                          "name": "n",
                          "type": "int",
                          "default": null,
                          "kind": "positional or keyword"
                        }
                      ],
                      "returns": {
                        "type": "tuple[(int, ...)]"
                      },
                      "decorators": []
                    }
                  },
                  "attributes": {
                    "_data": {
                      "name": "_data",
                      "type": "tuple[(tuple[(int, ...)], ...)] | CSRArray",
                      "docstring": {
                        "summary": "",
                        "description": "",
                        "sections": {}
                      },
                      "value": null
                    },
                    "_is_mmap": {
                      "name": "_is_mmap",
                      "type": "bool",
                      "docstring": {
                        "summary": "",
                        "description": "",
                        "sections": {}
                      },
                      "value": {
                        "arguments": [
                          {
                            "cls": "ExprName",
                            "member": null,
                            "name": "data"
                          },
                          {
                            "cls": "ExprName",
                            "member": null,
                            "name": "CSRArray"
                          }
                        ],
                        "cls": "ExprCall",
                        "function": {
                          "cls": "ExprName",
                          "member": null,
                          "name": "isinstance"
                        }
                      }
                    },
                    "api": {
                      "name": "api",
                      "type": "Api",
                      "docstring": {
                        "summary": "",
                        "description": "",
                        "sections": {}
                      },
                      "value": {
                        "cls": "ExprName",
                        "member": null,
                        "name": "api"
                      }
                    },
                    "data": {
                      "name": "data",
                      "type": "tuple[(tuple[(int, ...)], ...)] | CSRArray",
                      "docstring": {
                        "summary": "Access to raw slots data.",
                        "description": "Access to raw slots data.\n\nFor dict-based backend (.tf), returns the slots tuple.\nFor CSR backend (.cfm), returns the CSRArray.",
                        "parsed": []
                      },
                      "value": null
                    },
                    "maxNode": {
                      "name": "maxNode",
                      "type": "int | None",
                      "docstring": {
                        "summary": "",
                        "description": "",
                        "sections": {}
                      },
                      "value": null
                    },
                    "maxSlot": {
                      "name": "maxSlot",
                      "type": "int | None",
                      "docstring": {
                        "summary": "",
                        "description": "",
                        "sections": {}
                      },
                      "value": null
                    },
                    "meta": {
                      "name": "meta",
                      "type": "dict[(str, str)]",
                      "docstring": {
                        "summary": "Metadata of the feature.",
                        "description": "Metadata of the feature.\n\nThis is the information found in the lines starting with `@`\nin the `.tf` feature file.",
                        "parsed": []
                      },
                      "value": {
                        "cls": "ExprName",
                        "member": null,
                        "name": "metaData"
                      }
                    }
                  }
                }
              },
              "functions": {},
              "modules": {},
              "aliases": {
                "Api": {
                  "name": "Api",
                  "target": "cfabric.core.api.Api"
                },
                "CSRArray": {
                  "name": "CSRArray",
                  "target": "cfabric.storage.csr.CSRArray"
                },
                "Iterator": {
                  "name": "Iterator",
                  "target": "collections.abc.Iterator"
                },
                "TYPE_CHECKING": {
                  "name": "TYPE_CHECKING",
                  "target": "typing.TYPE_CHECKING"
                },
                "annotations": {
                  "name": "annotations",
                  "target": "__future__.annotations"
                }
              }
            },
            "otype": {
              "name": "otype",
              "kind": "module",
              "path": "",
              "docstring": {
                "summary": "# Access to `otype` feature data.",
                "description": "# Access to `otype` feature data.\n\nIn general, features are stored as dictionaries, but this specific feature\nhas an optimised representation. Since it is a large feature and present\nin any CF dataset, this pays off.\n\nSupports two backends:\n- Dict-based tuple format (.tf loading): data = (type_tuple, maxSlot, maxNode, slotType)\n- Mmap numpy array (.cfm loading): data = numpy uint8/uint16 array, with type_list parameter",
                "parsed": []
              },
              "classes": {
                "OtypeFeature": {
                  "name": "OtypeFeature",
                  "kind": "class",
                  "path": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "bases": [],
                  "methods": {
                    "__init__": {
                      "name": "__init__",
                      "kind": "function",
                      "signature": "(self, api: Api, metaData: dict[(str, str)], data: tuple[(tuple[(str, ...)], int, int, str)] | , type_list: list[str] | dict[(str, Any)] | None = None)",
                      "docstring": {
                        "summary": "Initialize OtypeFeature with either dict-based or mmap backend.",
                        "description": "Initialize OtypeFeature with either dict-based or mmap backend.\n\nParameters\n----------\napi : object\n    The API object\nmetaData : dict\n    Feature metadata\ndata : tuple or np.ndarray\n    Either:\n    - Dict-based (.tf): tuple (type_tuple, maxSlot, maxNode, slotType)\n    - Mmap: numpy uint8/uint16 array of type indices for non-slot nodes\ntype_list : list, optional\n    When using mmap backend, maps type indices to type strings.\n    Required when data is a numpy array.",
                        "parsed": []
                      },
                      "parameters": [
                        {
                          "name": "self",
                          "type": "",
                          "default": null,
                          "kind": "positional or keyword"
                        },
                        {
                          "name": "api",
                          "type": "Api",
                          "default": null,
                          "kind": "positional or keyword"
                        },
                        {
                          "name": "metaData",
                          "type": "dict[(str, str)]",
                          "default": null,
                          "kind": "positional or keyword"
                        },
                        {
                          "name": "data",
                          "type": "tuple[(tuple[(str, ...)], int, int, str)] | ",
                          "default": null,
                          "kind": "positional or keyword"
                        },
                        {
                          "name": "type_list",
                          "type": "list[str] | dict[(str, Any)] | None",
                          "default": "None",
                          "kind": "positional or keyword"
                        }
                      ],
                      "returns": {
                        "type": "None"
                      },
                      "decorators": []
                    },
                    "items": {
                      "name": "items",
                      "kind": "function",
                      "signature": "(self)",
                      "docstring": {
                        "summary": "As in `cfabric.nodefeature.NodeFeature.items`.",
                        "description": "As in `cfabric.nodefeature.NodeFeature.items`.",
                        "parsed": []
                      },
                      "parameters": [
                        {
                          "name": "self",
                          "type": "",
                          "default": null,
                          "kind": "positional or keyword"
                        }
                      ],
                      "returns": {
                        "type": "Iterator[tuple[(int, str)]]"
                      },
                      "decorators": []
                    },
                    "s": {
                      "name": "s",
                      "kind": "function",
                      "signature": "(self, val: str)",
                      "docstring": {
                        "summary": "Query all nodes having a specified node type.",
                        "description": "Query all nodes having a specified node type.\n\nThis is an other way to walk through nodes than using\n`cfabric.nodes.Nodes.walk`.\n\nParameters\n----------\nval: integer | string\n    The node type that all resulting nodes have.\n\nReturns\n-------\ntuple of integer\n    All nodes that have this node type, sorted in the canonical order.\n    (`cfabric.nodes`)",
                        "parsed": []
                      },
                      "parameters": [
                        {
                          "name": "self",
                          "type": "",
                          "default": null,
                          "kind": "positional or keyword"
                        },
                        {
                          "name": "val",
                          "type": "str",
                          "default": null,
                          "kind": "positional or keyword"
                        }
                      ],
                      "returns": {
                        "type": "tuple[(int, ...)]"
                      },
                      "decorators": []
                    },
                    "sInterval": {
                      "name": "sInterval",
                      "kind": "function",
                      "signature": "(self, val: str)",
                      "docstring": {
                        "summary": "The interval of nodes having a specified node type.",
                        "description": "The interval of nodes having a specified node type.\n\nThe nodes are organized in intervals of nodes with the same type.\nFor each type there is only one such interval.\nThe first interval, `1:maxSlot + 1` is reserved for the slot type.\n\nParameters\n----------\nval: integer | string\n    The node type in question.\n\nReturns\n-------\n2-tuple of integer\n    The start and end node of the interval of nodes with this type.",
                        "parsed": []
                      },
                      "parameters": [
                        {
                          "name": "self",
                          "type": "",
                          "default": null,
                          "kind": "positional or keyword"
                        },
                        {
                          "name": "val",
                          "type": "str",
                          "default": null,
                          "kind": "positional or keyword"
                        }
                      ],
                      "returns": {
                        "type": "tuple[(int, int)] | tuple[()]"
                      },
                      "decorators": []
                    },
                    "v": {
                      "name": "v",
                      "kind": "function",
                      "signature": "(self, n: int)",
                      "docstring": {
                        "summary": "Get the node type of a node.",
                        "description": "Get the node type of a node.\n\nParameters\n----------\nn: integer\n    The node in question\n\nReturns\n-------\nstring\n    The node type of that node. All nodes have a node type, and it is\n    always a string.",
                        "parsed": []
                      },
                      "parameters": [
                        {
                          "name": "self",
                          "type": "",
                          "default": null,
                          "kind": "positional or keyword"
                        },
                        {
                          "name": "n",
                          "type": "int",
                          "default": null,
                          "kind": "positional or keyword"
                        }
                      ],
                      "returns": {
                        "type": "str | None"
                      },
                      "decorators": []
                    }
                  },
                  "attributes": {
                    "_data": {
                      "name": "_data",
                      "type": "tuple[(str, ...)] | ",
                      "docstring": {
                        "summary": "",
                        "description": "",
                        "sections": {}
                      },
                      "value": null
                    },
                    "_is_mmap": {
                      "name": "_is_mmap",
                      "type": "bool",
                      "docstring": {
                        "summary": "",
                        "description": "",
                        "sections": {}
                      },
                      "value": {
                        "arguments": [
                          {
                            "cls": "ExprName",
                            "member": null,
                            "name": "data"
                          },
                          {
                            "cls": "ExprAttribute",
                            "values": [
                              {
                                "cls": "ExprName",
                                "member": null,
                                "name": "np"
                              },
                              {
                                "cls": "ExprName",
                                "member": null,
                                "name": "ndarray"
                              }
                            ]
                          }
                        ],
                        "cls": "ExprCall",
                        "function": {
                          "cls": "ExprName",
                          "member": null,
                          "name": "isinstance"
                        }
                      }
                    },
                    "_type_list": {
                      "name": "_type_list",
                      "type": "list[str] | None",
                      "docstring": {
                        "summary": "",
                        "description": "",
                        "sections": {}
                      },
                      "value": null
                    },
                    "all": {
                      "name": "all",
                      "type": "tuple[(str, ...)] | None",
                      "docstring": {
                        "summary": "List of all node types from big to small.",
                        "description": "List of all node types from big to small.",
                        "parsed": []
                      },
                      "value": "None"
                    },
                    "api": {
                      "name": "api",
                      "type": "Api",
                      "docstring": {
                        "summary": "",
                        "description": "",
                        "sections": {}
                      },
                      "value": {
                        "cls": "ExprName",
                        "member": null,
                        "name": "api"
                      }
                    },
                    "data": {
                      "name": "data",
                      "type": "tuple[(str, ...)] | ",
                      "docstring": {
                        "summary": "Access to raw type data.",
                        "description": "Access to raw type data.\n\nFor dict-based backend (.tf), returns the type tuple.\nFor mmap backend (.cfm), returns the numpy array.",
                        "parsed": []
                      },
                      "value": null
                    },
                    "maxNode": {
                      "name": "maxNode",
                      "type": "int | None",
                      "docstring": {
                        "summary": "",
                        "description": "",
                        "sections": {}
                      },
                      "value": null
                    },
                    "maxSlot": {
                      "name": "maxSlot",
                      "type": "int | None",
                      "docstring": {
                        "summary": "",
                        "description": "",
                        "sections": {}
                      },
                      "value": null
                    },
                    "meta": {
                      "name": "meta",
                      "type": "dict[(str, str)]",
                      "docstring": {
                        "summary": "Metadata of the feature.",
                        "description": "Metadata of the feature.\n\nThis is the information found in the lines starting with `@`\nin the `.tf` feature file.",
                        "parsed": []
                      },
                      "value": {
                        "cls": "ExprName",
                        "member": null,
                        "name": "metaData"
                      }
                    },
                    "slotType": {
                      "name": "slotType",
                      "type": "str | None",
                      "docstring": {
                        "summary": "",
                        "description": "",
                        "sections": {}
                      },
                      "value": null
                    },
                    "support": {
                      "name": "support",
                      "type": "dict[(str, tuple[(int, int)])]",
                      "docstring": {
                        "summary": "Support dict for s() method: type -> (min_node, max_node).",
                        "description": "Support dict for s() method: type -> (min_node, max_node).",
                        "parsed": []
                      },
                      "value": {
                        "cls": "ExprDict",
                        "keys": [],
                        "values": []
                      }
                    }
                  }
                }
              },
              "functions": {},
              "modules": {},
              "aliases": {
                "Any": {
                  "name": "Any",
                  "target": "typing.Any"
                },
                "Api": {
                  "name": "Api",
                  "target": "cfabric.core.api.Api"
                },
                "Iterator": {
                  "name": "Iterator",
                  "target": "collections.abc.Iterator"
                },
                "TYPE_CHECKING": {
                  "name": "TYPE_CHECKING",
                  "target": "typing.TYPE_CHECKING"
                },
                "annotations": {
                  "name": "annotations",
                  "target": "__future__.annotations"
                },
                "np": {
                  "name": "np",
                  "target": "numpy"
                },
                "safe_rank_key": {
                  "name": "safe_rank_key",
                  "target": "cfabric.utils.helpers.safe_rank_key"
                }
              }
            }
          },
          "aliases": {
            "OslotsFeature": {
              "name": "OslotsFeature",
              "target": "cfabric.features.warp.oslots.OslotsFeature"
            },
            "OtypeFeature": {
              "name": "OtypeFeature",
              "target": "cfabric.features.warp.otype.OtypeFeature"
            }
          }
        }
      },
      "aliases": {
        "Computed": {
          "name": "Computed",
          "target": "cfabric.features.computed.Computed"
        },
        "Computeds": {
          "name": "Computeds",
          "target": "cfabric.features.computed.Computeds"
        },
        "EdgeFeature": {
          "name": "EdgeFeature",
          "target": "cfabric.features.edge.EdgeFeature"
        },
        "EdgeFeatures": {
          "name": "EdgeFeatures",
          "target": "cfabric.features.edge.EdgeFeatures"
        },
        "LevDownComputed": {
          "name": "LevDownComputed",
          "target": "cfabric.features.computed.LevDownComputed"
        },
        "LevUpComputed": {
          "name": "LevUpComputed",
          "target": "cfabric.features.computed.LevUpComputed"
        },
        "NodeFeature": {
          "name": "NodeFeature",
          "target": "cfabric.features.node.NodeFeature"
        },
        "NodeFeatures": {
          "name": "NodeFeatures",
          "target": "cfabric.features.node.NodeFeatures"
        },
        "OrderComputed": {
          "name": "OrderComputed",
          "target": "cfabric.features.computed.OrderComputed"
        },
        "OslotsFeature": {
          "name": "OslotsFeature",
          "target": "cfabric.features.warp.oslots.OslotsFeature"
        },
        "OtypeFeature": {
          "name": "OtypeFeature",
          "target": "cfabric.features.warp.otype.OtypeFeature"
        },
        "RankComputed": {
          "name": "RankComputed",
          "target": "cfabric.features.computed.RankComputed"
        }
      }
    },
    "io": {
      "name": "io",
      "kind": "module",
      "path": "",
      "docstring": {
        "summary": "Data loading and compilation for Context-Fabric.",
        "description": "Data loading and compilation for Context-Fabric.\n\nThis module provides functionality to load .tf files and compile\nto/from the memory-mapped .cfm format.",
        "parsed": []
      },
      "classes": {},
      "functions": {},
      "modules": {
        "compiler": {
          "name": "compiler",
          "kind": "module",
          "path": "",
          "docstring": {
            "summary": "Compile .tf source files to .cfm mmap format.",
            "description": "Compile .tf source files to .cfm mmap format.\n\nThis module provides the Compiler class that converts Text-Fabric (.tf) source\nfiles into the Context Fabric memory-mapped (.cfm) format. The cfm format uses\nnumpy arrays with memory mapping for efficient multi-process access.",
            "parsed": []
          },
          "classes": {
            "Compiler": {
              "name": "Compiler",
              "kind": "class",
              "path": "",
              "docstring": {
                "summary": "Compile .tf source files to CF mmap format.",
                "description": "Compile .tf source files to CF mmap format.\n\nThe compiler reads .tf plain text feature files and converts them to\nmemory-mapped numpy arrays organized in the .cfm directory structure.\n\nUsage\n-----\ncompiler = Compiler(source_dir='/path/to/tf/files')\nsuccess = compiler.compile(output_dir='/path/to/output/.cfm/1/')\n\nParameters\n----------\nsource_dir : str\n    Path to directory containing .tf source files",
                "parsed": []
              },
              "bases": [],
              "methods": {
                "__init__": {
                  "name": "__init__",
                  "kind": "function",
                  "signature": "(self, source_dir: str)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "source_dir",
                      "type": "str",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "_compile_edge_features": {
                  "name": "_compile_edge_features",
                  "kind": "function",
                  "signature": "(self, output_dir: Path)",
                  "docstring": {
                    "summary": "Compile all edge features.",
                    "description": "Compile all edge features.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "output_dir",
                      "type": "Path",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "_compile_edge_no_values": {
                  "name": "_compile_edge_no_values",
                  "kind": "function",
                  "signature": "(self, feature_name: str, data: dict[(int, set[int])], output_dir: Path, metadata: dict[(str, str)])",
                  "docstring": {
                    "summary": "Compile an edge feature without values.",
                    "description": "Compile an edge feature without values.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "feature_name",
                      "type": "str",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "data",
                      "type": "dict[(int, set[int])]",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "output_dir",
                      "type": "Path",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "metadata",
                      "type": "dict[(str, str)]",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "_compile_edge_with_values": {
                  "name": "_compile_edge_with_values",
                  "kind": "function",
                  "signature": "(self, feature_name: str, data: dict[(int, dict[(int, Any)])], output_dir: Path, metadata: dict[(str, str)])",
                  "docstring": {
                    "summary": "Compile an edge feature with values.",
                    "description": "Compile an edge feature with values.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "feature_name",
                      "type": "str",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "data",
                      "type": "dict[(int, dict[(int, Any)])]",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "output_dir",
                      "type": "Path",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "metadata",
                      "type": "dict[(str, str)]",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "_compile_from_disk": {
                  "name": "_compile_from_disk",
                  "kind": "function",
                  "signature": "(self, output_dir: Path)",
                  "docstring": {
                    "summary": "Compile by loading .tf files from disk (original flow).",
                    "description": "Compile by loading .tf files from disk (original flow).",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "output_dir",
                      "type": "Path",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "bool"
                  },
                  "decorators": []
                },
                "_compile_from_precomputed": {
                  "name": "_compile_from_precomputed",
                  "kind": "function",
                  "signature": "(self, output_dir: Path, precomputed: dict[(str, Any)])",
                  "docstring": {
                    "summary": "Compile using pre-computed data from Fabric.load().",
                    "description": "Compile using pre-computed data from Fabric.load().",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "output_dir",
                      "type": "Path",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "precomputed",
                      "type": "dict[(str, Any)]",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "bool"
                  },
                  "decorators": []
                },
                "_compile_int_feature": {
                  "name": "_compile_int_feature",
                  "kind": "function",
                  "signature": "(self, feature_name: str, data: dict[(int, int)], output_dir: Path, metadata: dict[(str, str)])",
                  "docstring": {
                    "summary": "Compile an integer-valued node feature.",
                    "description": "Compile an integer-valued node feature.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "feature_name",
                      "type": "str",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "data",
                      "type": "dict[(int, int)]",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "output_dir",
                      "type": "Path",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "metadata",
                      "type": "dict[(str, str)]",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "_compile_node_features": {
                  "name": "_compile_node_features",
                  "kind": "function",
                  "signature": "(self, output_dir: Path)",
                  "docstring": {
                    "summary": "Compile all node features.",
                    "description": "Compile all node features.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "output_dir",
                      "type": "Path",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "_compile_oslots": {
                  "name": "_compile_oslots",
                  "kind": "function",
                  "signature": "(self, output_dir: Path)",
                  "docstring": {
                    "summary": "Compile oslots to CSR format.",
                    "description": "Compile oslots to CSR format.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "output_dir",
                      "type": "Path",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "bool"
                  },
                  "decorators": []
                },
                "_compile_otype": {
                  "name": "_compile_otype",
                  "kind": "function",
                  "signature": "(self, output_dir: Path)",
                  "docstring": {
                    "summary": "Compile otype to numpy format.",
                    "description": "Compile otype to numpy format.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "output_dir",
                      "type": "Path",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "bool"
                  },
                  "decorators": []
                },
                "_compile_str_feature": {
                  "name": "_compile_str_feature",
                  "kind": "function",
                  "signature": "(self, feature_name: str, data: dict[(int, str)], output_dir: Path, metadata: dict[(str, str)])",
                  "docstring": {
                    "summary": "Compile a string-valued node feature.",
                    "description": "Compile a string-valued node feature.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "feature_name",
                      "type": "str",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "data",
                      "type": "dict[(int, str)]",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "output_dir",
                      "type": "Path",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "metadata",
                      "type": "dict[(str, str)]",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "_create_directories": {
                  "name": "_create_directories",
                  "kind": "function",
                  "signature": "(self, output_dir: Path)",
                  "docstring": {
                    "summary": "Create the .cfm directory structure.",
                    "description": "Create the .cfm directory structure.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "output_dir",
                      "type": "Path",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "_load_features": {
                  "name": "_load_features",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "Load all non-WARP features from the source directory.",
                    "description": "Load all non-WARP features from the source directory.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "_load_oslots": {
                  "name": "_load_oslots",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "Load and parse the oslots feature.",
                    "description": "Load and parse the oslots feature.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "bool"
                  },
                  "decorators": []
                },
                "_load_otext": {
                  "name": "_load_otext",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "Load the otext configuration feature.",
                    "description": "Load the otext configuration feature.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "_load_otype": {
                  "name": "_load_otype",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "Load and parse the otype feature.",
                    "description": "Load and parse the otype feature.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "bool"
                  },
                  "decorators": []
                },
                "_parse_tf_file": {
                  "name": "_parse_tf_file",
                  "kind": "function",
                  "signature": "(self, path: Path)",
                  "docstring": {
                    "summary": "Parse a .tf file.",
                    "description": "Parse a .tf file.\n\nReturns\n-------\ntuple\n    (metadata, data, is_edge, edge_has_values, is_config)",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "path",
                      "type": "Path",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "tuple[(dict[(str, str)], dict[(int, Any)], bool, bool, bool)]"
                  },
                  "decorators": []
                },
                "_precompute": {
                  "name": "_precompute",
                  "kind": "function",
                  "signature": "(self, output_dir: Path)",
                  "docstring": {
                    "summary": "Run precomputation steps and save results.",
                    "description": "Run precomputation steps and save results.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "output_dir",
                      "type": "Path",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "bool"
                  },
                  "decorators": []
                },
                "_write_meta": {
                  "name": "_write_meta",
                  "kind": "function",
                  "signature": "(self, output_dir: Path)",
                  "docstring": {
                    "summary": "Write corpus metadata to meta.json.",
                    "description": "Write corpus metadata to meta.json.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "output_dir",
                      "type": "Path",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "_write_precomputed": {
                  "name": "_write_precomputed",
                  "kind": "function",
                  "signature": "(self, output_dir: Path, precomputed: dict[(str, Any)])",
                  "docstring": {
                    "summary": "Write pre-computed data to .cfm format.",
                    "description": "Write pre-computed data to .cfm format.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "output_dir",
                      "type": "Path",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "precomputed",
                      "type": "dict[(str, Any)]",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "bool"
                  },
                  "decorators": []
                },
                "compile": {
                  "name": "compile",
                  "kind": "function",
                  "signature": "(self, output_dir: str | Path | None = None, precomputed: dict[(str, Any)] | None = None)",
                  "docstring": {
                    "summary": "Compile all .tf files to .cfm format.",
                    "description": "Compile all .tf files to .cfm format.\n\nParameters\n----------\noutput_dir : str, optional\n    Output directory. Defaults to {source_dir}/.cfm/{CFM_VERSION}/\nprecomputed : dict, optional\n    Pre-computed data from Fabric.load() to avoid re-parsing .tf files.\n    If provided, skips loading from disk and uses this data instead.\n    Expected keys:\n    - 'otype': tuple (otype_list, maxSlot, maxNode, slotType)\n    - 'oslots': tuple (oslots_list, maxSlot, maxNode)\n    - 'otext_meta': dict of otext metadata\n    - 'feature_meta': dict mapping feature names to metadata dicts\n    - 'levels': list of (type, avgSlots, minNode, maxNode) tuples\n    - 'order': list of node IDs in canonical order\n    - 'rank': list of ranks indexed by node ID\n    - 'levUp': list of tuples (embedders for each node)\n    - 'levDown': list of tuples (embedded children for each node)\n    - 'node_features': dict mapping feature names to {node: value} dicts\n    - 'edge_features': dict mapping feature names to (data, has_values) tuples\n\nReturns\n-------\nbool\n    True if compilation succeeded",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "output_dir",
                      "type": "str | Path | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "precomputed",
                      "type": "dict[(str, Any)] | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "bool"
                  },
                  "decorators": []
                }
              },
              "attributes": {
                "_edge_features": {
                  "name": "_edge_features",
                  "type": "dict[(str, tuple[(dict[(int, Any)], bool)])]",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprDict",
                    "keys": [],
                    "values": []
                  }
                },
                "_feature_meta": {
                  "name": "_feature_meta",
                  "type": "dict[(str, dict[(str, str)])]",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprDict",
                    "keys": [],
                    "values": []
                  }
                },
                "_levdown_data": {
                  "name": "_levdown_data",
                  "type": "list[tuple[(int, ...)]] | None",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": "None"
                },
                "_levels_data": {
                  "name": "_levels_data",
                  "type": "list[tuple[(str, float, int, int)]] | None",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": "None"
                },
                "_levup_data": {
                  "name": "_levup_data",
                  "type": "list[tuple[(int, ...)]] | None",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": "None"
                },
                "_node_features": {
                  "name": "_node_features",
                  "type": "dict[(str, dict[(int, str | int)])]",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprDict",
                    "keys": [],
                    "values": []
                  }
                },
                "_order_data": {
                  "name": "_order_data",
                  "type": "list[int] | None",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": "None"
                },
                "_oslots_data": {
                  "name": "_oslots_data",
                  "type": "tuple[(tuple[(tuple[(int, ...)], ...)], int, int)] | None",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": "None"
                },
                "_otext_meta": {
                  "name": "_otext_meta",
                  "type": "dict[(str, str)]",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprDict",
                    "keys": [],
                    "values": []
                  }
                },
                "_otype_data": {
                  "name": "_otype_data",
                  "type": "tuple[(tuple[(str, ...)], int, int, str)] | None",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": "None"
                },
                "_rank_data": {
                  "name": "_rank_data",
                  "type": "list[int] | None",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": "None"
                },
                "error": {
                  "name": "error",
                  "type": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprAttribute",
                    "values": [
                      {
                        "cls": "ExprName",
                        "member": null,
                        "name": "logger"
                      },
                      {
                        "cls": "ExprName",
                        "member": null,
                        "name": "error"
                      }
                    ]
                  }
                },
                "info": {
                  "name": "info",
                  "type": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprAttribute",
                    "values": [
                      {
                        "cls": "ExprName",
                        "member": null,
                        "name": "logger"
                      },
                      {
                        "cls": "ExprName",
                        "member": null,
                        "name": "info"
                      }
                    ]
                  }
                },
                "max_node": {
                  "name": "max_node",
                  "type": "int",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": "0"
                },
                "max_slot": {
                  "name": "max_slot",
                  "type": "int",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": "0"
                },
                "node_types": {
                  "name": "node_types",
                  "type": "list[str]",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprList",
                    "elements": []
                  }
                },
                "slot_type": {
                  "name": "slot_type",
                  "type": "str",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": "''"
                },
                "source_dir": {
                  "name": "source_dir",
                  "type": "Path",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "arguments": [
                      {
                        "cls": "ExprName",
                        "member": null,
                        "name": "source_dir"
                      }
                    ],
                    "cls": "ExprCall",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "Path"
                    }
                  }
                },
                "type_order": {
                  "name": "type_order",
                  "type": "list[str]",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprList",
                    "elements": []
                  }
                },
                "warning": {
                  "name": "warning",
                  "type": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprAttribute",
                    "values": [
                      {
                        "cls": "ExprName",
                        "member": null,
                        "name": "logger"
                      },
                      {
                        "cls": "ExprName",
                        "member": null,
                        "name": "warning"
                      }
                    ]
                  }
                }
              }
            }
          },
          "functions": {
            "_check_sentinel_collision": {
              "name": "_check_sentinel_collision",
              "kind": "function",
              "signature": "(values: Iterable[Any], sentinel: int, feature_name: str, feature_kind: str)",
              "docstring": {
                "summary": "Check if data contains the sentinel value and warn if so.",
                "description": "Check if data contains the sentinel value and warn if so.\n\nParameters\n----------\nvalues : iterable\n    Values to check for sentinel collision\nsentinel : int\n    The sentinel value used for None/missing\nfeature_name : str\n    Name of the feature (for warning message)\nfeature_kind : str\n    'node' or 'edge' (for warning message)\n\nReturns\n-------\nbool\n    True if sentinel collision was found, False otherwise",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "values",
                  "type": "Iterable[Any]",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "sentinel",
                  "type": "int",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "feature_name",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "feature_kind",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "bool"
              },
              "decorators": []
            },
            "compile_corpus": {
              "name": "compile_corpus",
              "kind": "function",
              "signature": "(source_dir: str, output_dir: str | None = None)",
              "docstring": {
                "summary": "Convenience function to compile a .tf corpus to CFM format.",
                "description": "Convenience function to compile a .tf corpus to CFM format.\n\nParameters\n----------\nsource_dir : str\n    Path to directory containing .tf source files\noutput_dir : str, optional\n    Output directory. Defaults to {source_dir}/.cfm/{CFM_VERSION}/\n\nReturns\n-------\nbool\n    True if compilation succeeded",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "source_dir",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "output_dir",
                  "type": "str | None",
                  "default": "None",
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "bool"
              },
              "decorators": []
            }
          },
          "modules": {},
          "aliases": {
            "Any": {
              "name": "Any",
              "target": "typing.Any"
            },
            "CFM_VERSION": {
              "name": "CFM_VERSION",
              "target": "cfabric.core.config.CFM_VERSION"
            },
            "CSRArray": {
              "name": "CSRArray",
              "target": "cfabric.storage.csr.CSRArray"
            },
            "CSRArrayWithValues": {
              "name": "CSRArrayWithValues",
              "target": "cfabric.storage.csr.CSRArrayWithValues"
            },
            "INDEX_DTYPE": {
              "name": "INDEX_DTYPE",
              "target": "cfabric.core.config.INDEX_DTYPE"
            },
            "IntFeatureArray": {
              "name": "IntFeatureArray",
              "target": "cfabric.storage.string_pool.IntFeatureArray"
            },
            "Iterable": {
              "name": "Iterable",
              "target": "collections.abc.Iterable"
            },
            "MISSING_STR_INDEX": {
              "name": "MISSING_STR_INDEX",
              "target": "cfabric.core.config.MISSING_STR_INDEX"
            },
            "NDArray": {
              "name": "NDArray",
              "target": "numpy.typing.NDArray"
            },
            "NODE_DTYPE": {
              "name": "NODE_DTYPE",
              "target": "cfabric.core.config.NODE_DTYPE"
            },
            "OSLOTS": {
              "name": "OSLOTS",
              "target": "cfabric.core.config.OSLOTS"
            },
            "OTEXT": {
              "name": "OTEXT",
              "target": "cfabric.core.config.OTEXT"
            },
            "OTYPE": {
              "name": "OTYPE",
              "target": "cfabric.core.config.OTYPE"
            },
            "Path": {
              "name": "Path",
              "target": "pathlib.Path"
            },
            "StringPool": {
              "name": "StringPool",
              "target": "cfabric.storage.string_pool.StringPool"
            },
            "TYPE_CHECKING": {
              "name": "TYPE_CHECKING",
              "target": "typing.TYPE_CHECKING"
            },
            "TYPE_DTYPE": {
              "name": "TYPE_DTYPE",
              "target": "cfabric.core.config.TYPE_DTYPE"
            },
            "WARP": {
              "name": "WARP",
              "target": "cfabric.core.config.WARP"
            },
            "annotations": {
              "name": "annotations",
              "target": "__future__.annotations"
            },
            "datetime": {
              "name": "datetime",
              "target": "datetime.datetime"
            },
            "dirMake": {
              "name": "dirMake",
              "target": "cfabric.utils.files.dirMake"
            },
            "fileExists": {
              "name": "fileExists",
              "target": "cfabric.utils.files.fileExists"
            },
            "fileOpen": {
              "name": "fileOpen",
              "target": "cfabric.utils.files.fileOpen"
            },
            "json": {
              "name": "json",
              "target": "json"
            },
            "logging": {
              "name": "logging",
              "target": "logging"
            },
            "makeInverse": {
              "name": "makeInverse",
              "target": "cfabric.utils.helpers.makeInverse"
            },
            "makeInverseVal": {
              "name": "makeInverseVal",
              "target": "cfabric.utils.helpers.makeInverseVal"
            },
            "np": {
              "name": "np",
              "target": "numpy"
            },
            "prepare": {
              "name": "prepare",
              "target": "cfabric.precompute.prepare"
            },
            "setFromSpec": {
              "name": "setFromSpec",
              "target": "cfabric.utils.helpers.setFromSpec"
            },
            "timezone": {
              "name": "timezone",
              "target": "datetime.timezone"
            },
            "valueFromTf": {
              "name": "valueFromTf",
              "target": "cfabric.utils.helpers.valueFromTf"
            }
          }
        },
        "loader": {
          "name": "loader",
          "kind": "module",
          "path": "",
          "docstring": {
            "summary": "",
            "description": "",
            "sections": {}
          },
          "classes": {
            "Data": {
              "name": "Data",
              "kind": "class",
              "path": "",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "bases": [],
              "methods": {
                "__init__": {
                  "name": "__init__",
                  "kind": "function",
                  "signature": "(self, path: str, edgeValues: bool = False, data: dict[(int, Any)] | tuple[(Any, ...)] | None = None, isEdge: bool | None = None, isConfig: bool | None = None, metaData: dict[(str, str | None)] | None = None, method: Callable[(..., Any)] | None = None, dependencies: list['Data' | Any] | None = None)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "path",
                      "type": "str",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "edgeValues",
                      "type": "bool",
                      "default": "False",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "data",
                      "type": "dict[(int, Any)] | tuple[(Any, ...)] | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "isEdge",
                      "type": "bool | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "isConfig",
                      "type": "bool | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "metaData",
                      "type": "dict[(str, str | None)] | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "method",
                      "type": "Callable[(..., Any)] | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "dependencies",
                      "type": "list['Data' | Any] | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "_compute": {
                  "name": "_compute",
                  "kind": "function",
                  "signature": "(self, metaOnly: bool = False)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "metaOnly",
                      "type": "bool",
                      "default": "False",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "bool"
                  },
                  "decorators": []
                },
                "_getModified": {
                  "name": "_getModified",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "Get the modification time of the source file.",
                    "description": "Get the modification time of the source file.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "float | None"
                  },
                  "decorators": []
                },
                "_readDataTf": {
                  "name": "_readDataTf",
                  "kind": "function",
                  "signature": "(self, fh: 'TextIOWrapper', firstI: int)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "fh",
                      "type": "'TextIOWrapper'",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "firstI",
                      "type": "int",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "bool"
                  },
                  "decorators": []
                },
                "_readTf": {
                  "name": "_readTf",
                  "kind": "function",
                  "signature": "(self, metaOnly: bool = False)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "metaOnly",
                      "type": "bool",
                      "default": "False",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "bool"
                  },
                  "decorators": []
                },
                "_setDataType": {
                  "name": "_setDataType",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "_writeDataTf": {
                  "name": "_writeDataTf",
                  "kind": "function",
                  "signature": "(self, fh: 'TextIOWrapper', nodeRanges: bool = False)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "fh",
                      "type": "'TextIOWrapper'",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "nodeRanges",
                      "type": "bool",
                      "default": "False",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "bool"
                  },
                  "decorators": []
                },
                "_writeTf": {
                  "name": "_writeTf",
                  "kind": "function",
                  "signature": "(self, dirName: str | None = None, fileName: str | None = None, overwrite: bool = True, extension: str | None = None, metaOnly: bool = False, nodeRanges: bool = False)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "dirName",
                      "type": "str | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "fileName",
                      "type": "str | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "overwrite",
                      "type": "bool",
                      "default": "True",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "extension",
                      "type": "str | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "metaOnly",
                      "type": "bool",
                      "default": "False",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "nodeRanges",
                      "type": "bool",
                      "default": "False",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "bool"
                  },
                  "decorators": []
                },
                "load": {
                  "name": "load",
                  "kind": "function",
                  "signature": "(self, metaOnly: bool = False, silent: str | bool | None = {'cls': 'ExprName', 'member': None, 'name': 'SILENT_D'}, _withGc: bool = False)",
                  "docstring": {
                    "summary": "Load a feature from .tf source file.",
                    "description": "Load a feature from .tf source file.\n\nFor faster loading, use CF.load_cfm() which loads from pre-compiled\nmemory-mapped .cfm format instead.\n\n_withGc: boolean, optional False\n    Ignored, kept for API compatibility.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "metaOnly",
                      "type": "bool",
                      "default": "False",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "silent",
                      "type": "str | bool | None",
                      "default": {
                        "cls": "ExprName",
                        "member": null,
                        "name": "SILENT_D"
                      },
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "_withGc",
                      "type": "bool",
                      "default": "False",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "bool"
                  },
                  "decorators": []
                },
                "save": {
                  "name": "save",
                  "kind": "function",
                  "signature": "(self, overwrite: bool = False, nodeRanges: bool = False, silent: str | bool | None = {'cls': 'ExprName', 'member': None, 'name': 'SILENT_D'})",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "overwrite",
                      "type": "bool",
                      "default": "False",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "nodeRanges",
                      "type": "bool",
                      "default": "False",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "silent",
                      "type": "str | bool | None",
                      "default": {
                        "cls": "ExprName",
                        "member": null,
                        "name": "SILENT_D"
                      },
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "bool"
                  },
                  "decorators": []
                },
                "unload": {
                  "name": "unload",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                }
              },
              "attributes": {
                "data": {
                  "name": "data",
                  "type": "dict[(int, Any)] | tuple[(Any, ...)] | None",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "data"
                  }
                },
                "dataError": {
                  "name": "dataError",
                  "type": "bool",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": "False"
                },
                "dataLoaded": {
                  "name": "dataLoaded",
                  "type": "float | bool",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": "False"
                },
                "dataType": {
                  "name": "dataType",
                  "type": "str",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": "'str'"
                },
                "dependencies": {
                  "name": "dependencies",
                  "type": "list['Data' | Any] | None",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "dependencies"
                  }
                },
                "dirName": {
                  "name": "dirName",
                  "type": "str",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "dirName"
                  }
                },
                "edgeValues": {
                  "name": "edgeValues",
                  "type": "bool",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "edgeValues"
                  }
                },
                "extension": {
                  "name": "extension",
                  "type": "str",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "extension"
                  }
                },
                "fileName": {
                  "name": "fileName",
                  "type": "str",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "fileName"
                  }
                },
                "isConfig": {
                  "name": "isConfig",
                  "type": "bool | None",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "isConfig"
                  }
                },
                "isEdge": {
                  "name": "isEdge",
                  "type": "bool | None",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "isEdge"
                  }
                },
                "metaData": {
                  "name": "metaData",
                  "type": "dict[(str, str | None)]",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "metaData"
                  }
                },
                "method": {
                  "name": "method",
                  "type": "Callable[(..., Any)] | None",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "method"
                  }
                },
                "path": {
                  "name": "path",
                  "type": "str",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "path"
                  }
                }
              }
            }
          },
          "functions": {},
          "modules": {},
          "aliases": {
            "Any": {
              "name": "Any",
              "target": "typing.Any"
            },
            "Callable": {
              "name": "Callable",
              "target": "typing.Callable"
            },
            "OSLOTS": {
              "name": "OSLOTS",
              "target": "cfabric.core.config.OSLOTS"
            },
            "OTEXT": {
              "name": "OTEXT",
              "target": "cfabric.core.config.OTEXT"
            },
            "OTYPE": {
              "name": "OTYPE",
              "target": "cfabric.core.config.OTYPE"
            },
            "SILENT_D": {
              "name": "SILENT_D",
              "target": "cfabric.utils.logging.SILENT_D"
            },
            "TYPE_CHECKING": {
              "name": "TYPE_CHECKING",
              "target": "typing.TYPE_CHECKING"
            },
            "TextIOWrapper": {
              "name": "TextIOWrapper",
              "target": "io.TextIOWrapper"
            },
            "annotations": {
              "name": "annotations",
              "target": "__future__.annotations"
            },
            "array": {
              "name": "array",
              "target": "array"
            },
            "check32": {
              "name": "check32",
              "target": "cfabric.utils.helpers.check32"
            },
            "collections": {
              "name": "collections",
              "target": "collections"
            },
            "console": {
              "name": "console",
              "target": "cfabric.utils.helpers.console"
            },
            "dirMake": {
              "name": "dirMake",
              "target": "cfabric.utils.files.dirMake"
            },
            "fileExists": {
              "name": "fileExists",
              "target": "cfabric.utils.files.fileExists"
            },
            "fileOpen": {
              "name": "fileOpen",
              "target": "cfabric.utils.files.fileOpen"
            },
            "logging": {
              "name": "logging",
              "target": "logging"
            },
            "mTime": {
              "name": "mTime",
              "target": "cfabric.utils.files.mTime"
            },
            "rangesFromSet": {
              "name": "rangesFromSet",
              "target": "cfabric.utils.helpers.rangesFromSet"
            },
            "setFromSpec": {
              "name": "setFromSpec",
              "target": "cfabric.utils.helpers.setFromSpec"
            },
            "silentConvert": {
              "name": "silentConvert",
              "target": "cfabric.utils.logging.silentConvert"
            },
            "specFromRanges": {
              "name": "specFromRanges",
              "target": "cfabric.utils.helpers.specFromRanges"
            },
            "splitExt": {
              "name": "splitExt",
              "target": "cfabric.utils.files.splitExt"
            },
            "splitPath": {
              "name": "splitPath",
              "target": "cfabric.utils.files.splitPath"
            },
            "tfFromValue": {
              "name": "tfFromValue",
              "target": "cfabric.utils.helpers.tfFromValue"
            },
            "time": {
              "name": "time",
              "target": "time"
            },
            "utcnow": {
              "name": "utcnow",
              "target": "cfabric.utils.helpers.utcnow"
            },
            "ux": {
              "name": "ux",
              "target": "cfabric.utils.files.unexpanduser"
            },
            "valueFromTf": {
              "name": "valueFromTf",
              "target": "cfabric.utils.helpers.valueFromTf"
            }
          }
        }
      },
      "aliases": {
        "Compiler": {
          "name": "Compiler",
          "target": "cfabric.io.compiler.Compiler"
        },
        "Data": {
          "name": "Data",
          "target": "cfabric.io.loader.Data"
        },
        "MEM_MSG": {
          "name": "MEM_MSG",
          "target": "cfabric.io.loader.MEM_MSG"
        },
        "compile_corpus": {
          "name": "compile_corpus",
          "target": "cfabric.io.compiler.compile_corpus"
        }
      }
    },
    "navigation": {
      "name": "navigation",
      "kind": "module",
      "path": "",
      "docstring": {
        "summary": "Corpus navigation for Context-Fabric.",
        "description": "Corpus navigation for Context-Fabric.\n\nThis module provides the N, L, and T APIs for navigating nodes,\nlocalities, and text.",
        "parsed": []
      },
      "classes": {},
      "functions": {},
      "modules": {
        "locality": {
          "name": "locality",
          "kind": "module",
          "path": "",
          "docstring": {
            "summary": "# Local navigation between nodes.",
            "description": "# Local navigation between nodes.",
            "parsed": []
          },
          "classes": {
            "Locality": {
              "name": "Locality",
              "kind": "class",
              "path": "",
              "docstring": {
                "summary": "Methods by which you can navigate from a node to its neighbourhood.",
                "description": "Methods by which you can navigate from a node to its neighbourhood.\n\nNeighbours are: nodes that have slots in common, embedders and embeddees,\nprevious and next siblings.\n\n!!! note \"L\"\n    The Locality API is exposed as `L` or `Locality`.\n\n!!! note \"`otype` parameter\"\n    In all of the following `L`-functions, if the `otype` parameter is passed,\n    the result is filtered and only nodes with\n    `otype=nodeType` or `otype in nodeTypes` are retained.\n\n    `otype` can be a string (a single node type)  or a (frozen)set of node types.\n\n!!! caution \"Results of the `L.` functions are tuples, not single nodes\"\n      Even if an `L`-function returns a single node, it is packed in a *tuple*.\n      So to get the node itself, you have to index the tuple:\n\n          L.u(node)[0]\n\n!!! caution \"Locality and node types\"\n    When using `cfabric.nodes.Nodes.sortNodes` and the `L` methods,\n    note the following.\n\n    Suppose you have node types `verse` and `sentence`, and usually a\n    verse has multiple sentences, but not vice versa. Then you expect that\n\n    *   `L.d(verseNode)` will contain sentence nodes,\n    *   `L.d(sentenceNode)` will **not** contain verse nodes.\n\n    But if there is a verse with exactly one sentence, and both have exactly the\n    same words, then that is a case where:\n\n    *   `L.d(verseNode)` will contain `sentenceNode`,\n    *   `L.d(sentenceNode)` will contain `verseNode`.",
                "parsed": []
              },
              "bases": [],
              "methods": {
                "__init__": {
                  "name": "__init__",
                  "kind": "function",
                  "signature": "(self, api: Api)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "api",
                      "type": "Api",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "d": {
                  "name": "d",
                  "kind": "function",
                  "signature": "(self, n: int, otype: str | set[str] | frozenset[str] | None = None)",
                  "docstring": {
                    "summary": "Produces an ordered tuple of *downward* nodes.",
                    "description": "Produces an ordered tuple of *downward* nodes.\n\nDownward nodes of a node are embedded nodes in that node.\nOne node is embedded in an other if all slots of the former are contained\nin the slots of the latter.\n\nParameters\n----------\n\nnode: integer\n    The node whose embeddees will be delivered.\notype: string or set of strings\n    See `Locality`.\n\nReturns\n-------\ntuple of integer\n    The tuple nodes is sorted in the canonical order (`cfabric.nodes`),\n    left and big embeddees before right and small embeddees.\n\n    The result never includes `n` itself.\n    But other nodes linked to the same set of slots as `n`\n    may count as embeddee nodes.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "n",
                      "type": "int",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "otype",
                      "type": "str | set[str] | frozenset[str] | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "tuple[(int, ...)]"
                  },
                  "decorators": []
                },
                "i": {
                  "name": "i",
                  "kind": "function",
                  "signature": "(self, n: int, otype: str | set[str] | frozenset[str] | None = None)",
                  "docstring": {
                    "summary": "Produces an ordered tuple of *intersecting* nodes",
                    "description": "Produces an ordered tuple of *intersecting* nodes\n\nIntersecting nodes of a node have slots in common with that node.\n\nParameters\n----------\n\nnode: dict\n    The node whose intersectors will be delivered.\notype: string or set of strings\n    See `Locality`.\n\nReturns\n-------\ntuple of integer\n    The tuple nodes is sorted in the\n    canonical order (`cfabric.nodes`).\n\n    The result never includes `n` itself.\n    But other nodes linked to the same set of slots as `n`\n    may count as intersector nodes.\n\n    Slots themselves can be intersectors.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "n",
                      "type": "int",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "otype",
                      "type": "str | set[str] | frozenset[str] | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "tuple[(int, ...)]"
                  },
                  "decorators": []
                },
                "n": {
                  "name": "n",
                  "kind": "function",
                  "signature": "(self, n: int, otype: str | set[str] | frozenset[str] | None = None)",
                  "docstring": {
                    "summary": "Produces an ordered tuple of *next* nodes.",
                    "description": "Produces an ordered tuple of *next* nodes.\n\nOne node is next to an other if the first slot of the former just follows\nthe last slot of the latter.\n\nParameters\n----------\n\nnode: integer\n    The node whose next nodes will be delivered.\notype: string or set of strings\n    See `Locality`.\n\nReturns\n-------\ntuple of integer\n    The tuple nodes is sorted in the canonical order (`cfabric.nodes`),\n    left and big embeddees before right and small embeddees.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "n",
                      "type": "int",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "otype",
                      "type": "str | set[str] | frozenset[str] | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "tuple[(int, ...)]"
                  },
                  "decorators": []
                },
                "p": {
                  "name": "p",
                  "kind": "function",
                  "signature": "(self, n: int, otype: str | set[str] | frozenset[str] | None = None)",
                  "docstring": {
                    "summary": "Produces an ordered tuple of *previous* nodes.",
                    "description": "Produces an ordered tuple of *previous* nodes.\n\nOne node is previous to an other if the last slot of the former just precedes\nthe first slots of the latter.\n\nParameters\n----------\n\nnode: integer\n    The node whose previous nodes will be delivered.\notype: string or set of strings\n    See `Locality`.\n\nReturns\n-------\ntuple of integer\n    The tuple nodes is sorted in the canonical order (`cfabric.nodes`),\n    but *reversed*: right and small embedders before left and big embedders.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "n",
                      "type": "int",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "otype",
                      "type": "str | set[str] | frozenset[str] | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "tuple[(int, ...)]"
                  },
                  "decorators": []
                },
                "u": {
                  "name": "u",
                  "kind": "function",
                  "signature": "(self, n: int, otype: str | set[str] | frozenset[str] | None = None)",
                  "docstring": {
                    "summary": "Produces an ordered tuple of *upward* nodes.",
                    "description": "Produces an ordered tuple of *upward* nodes.\n\nUpward nodes of a node are embedders of that node.\nOne node embeds an other if all slots of the latter are contained in the slots\nof the former.\n\nParameters\n----------\n\nnode: integer\n    The node whose embedders will be delivered.\notype: string or set of strings\n    See `Locality`.\n\nReturns\n-------\ntuple of integer\n    The tuple nodes is sorted in the canonical order (`cfabric.nodes`),\n    but *reversed*: right and small embedders before left and big embedders.\n\n    The result never includes `n` itself.\n    But other nodes linked to the same set of slots as `n`\n    may count as embedder nodes.\n\n    Slots themselves are never embedders.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "n",
                      "type": "int",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "otype",
                      "type": "str | set[str] | frozenset[str] | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "tuple[(int, ...)]"
                  },
                  "decorators": []
                }
              },
              "attributes": {
                "api": {
                  "name": "api",
                  "type": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "api"
                  }
                }
              }
            }
          },
          "functions": {},
          "modules": {},
          "aliases": {
            "Api": {
              "name": "Api",
              "target": "cfabric.core.api.Api"
            },
            "TYPE_CHECKING": {
              "name": "TYPE_CHECKING",
              "target": "typing.TYPE_CHECKING"
            },
            "annotations": {
              "name": "annotations",
              "target": "__future__.annotations"
            }
          }
        },
        "nodes": {
          "name": "nodes",
          "kind": "module",
          "path": "",
          "docstring": {
            "summary": "# Node organization",
            "description": "# Node organization\n\nThis module is about ordering nodes in terms of the slot nodes they are attached to.\n\n## Canonical Order\n\nNodes are linked to subsets of slots, and there is a canonical ordering\non subsets of integers that is inherited by the nodes.\n\nThe canonical order is a way to sort the nodes in your corpus in such a way\nthat you can enumerate all nodes in the order you encounter them if you\nwalk through your corpus.\n\nFormally\n:   A node `A` comes before a node `B` if `A` contains the smallest slot\n    that occurs in only one of `A` and `B`.\n\nBriefly this means:\n\n*   embedder nodes come before the nodes that lie embedded in them;\n*   earlier stuff comes before later stuff,\n*   if a verse coincides with a sentence, the verse comes before the sentence,\n    because verses generally contain sentences and not the other way round;\n*   if two objects are intersecting, but none embeds the other, the one with the\n    smallest slot that does not occur in the other, comes first.\n\n!!! note \"first things first, big things first\"\n    That means, roughly, that you start with a\n    book node (Genesis), then a chapter node (Genesis 1), then a verse node, Genesis\n    1:1, then a sentence node, then a clause node, a phrase node, and the first word\n    node. Then follow all word nodes in the first phrase, then the phrase node of\n    the second phrase, followed by the word nodes in that phrase. When ever you\n    enter a higher structure, you will first get the node corresponding to that\n    structure, and after that the nodes corresponding to the building blocks of that\n    structure.\n\nThis concept follows the intuition that slot sets with smaller elements come\nbefore slot set with bigger elements, and embedding slot sets come before\nembedded slot sets. Hence, if you enumerate a set of nodes that happens to\nconstitute a tree hierarchy based on slot set embedding, and you enumerate those\nnodes in the slot set order, you will walk the tree in pre-order.\n\nThis order is a modification of the one as described in (Doedens 1994, 3.6.3).\n\n![fabric](../images/DoedensLO.png)\n\n> Doedens, Crist-Jan (1994), *Text Databases. One Database Model and Several\n> Retrieval Languages*, number 14 in Language and Computers, Editions Rodopi,\n> Amsterdam, Netherlands and Atlanta, USA. ISBN: 90-5183-729-1,\n> [Google books](https://books.google.nl/books?id=9ggOBRz1dO4C).\n> The order as defined by Doedens corresponds to walking trees in post-order.\n\nFor a lot of processing, it is handy to have the stack of embedding elements\navailable when working with an element. That is the advantage of pre-order over\npost-order. It is very much like SAX parsing in the XML world.",
            "parsed": []
          },
          "classes": {
            "Nodes": {
              "name": "Nodes",
              "kind": "class",
              "path": "",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "bases": [],
              "methods": {
                "__init__": {
                  "name": "__init__",
                  "kind": "function",
                  "signature": "(self, api: Api)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "api",
                      "type": "Api",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "makeSortKeyChunk": {
                  "name": "makeSortKeyChunk",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "tuple[(Callable[([tuple[(int, tuple[(int, int)])]], int)], Callable[([tuple[(int, tuple[(int, int)])]], int)])]"
                  },
                  "decorators": []
                },
                "sortNodes": {
                  "name": "sortNodes",
                  "kind": "function",
                  "signature": "(self, nodeSet: Iterable[int])",
                  "docstring": {
                    "summary": "Delivers a tuple of nodes sorted by the *canonical ordering*.",
                    "description": "Delivers a tuple of nodes sorted by the *canonical ordering*.\n\nParameters\n----------\nnodeSet: iterable\n    An iterable of nodes to be sorted.\n\nReturns\n-------\nlist\n    The sorted nodes as list\n\nSee Also\n--------\ncfabric.nodes: canonical ordering",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "nodeSet",
                      "type": "Iterable[int]",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "list[int]"
                  },
                  "decorators": []
                },
                "walk": {
                  "name": "walk",
                  "kind": "function",
                  "signature": "(self, nodes: Iterable[int] | None = None, events: bool = False)",
                  "docstring": {
                    "summary": "Generates all nodes in the *canonical order*.\n(`cfabric.nodes`)",
                    "description": "Generates all nodes in the *canonical order*.\n(`cfabric.nodes`)\n\nBy `walk()` you traverse all nodes of your corpus\nin a very natural order. See `cfabric.nodes`.\n\nThe order is much like walking a tree in pre-order: first parents,\nthen children from left to right.\n\nThe thing is: in general the nodes do not form a tree, but a more\nliberal structure: a graph.\n\nBut even then we can order the nodes in such a way that nodes that embed\nslots from other nodes come before those other nodes, provided those other\nnodes start later.\n\nWhen we generate those nodes and consume them, we now when each node starts,\nbut we loose track of where exactly they end.\n\nTo remedy that, you can call this function with `events=True`.\nIn that case, a stream of events is generated, where each event has the\nform `(node, False)` or `(node, True)`, where `False` means: beginning of\nnode and `True` means: end of node.\n\nIn case of slot nodes, only one event per slot is generated: `(node, None)`.\n\n!!! hint \"More ways of walking\"\n    Under `cfabric.nodefeature.NodeFeatures` there is another convenient way\n    to walk through subsets of nodes.\n\nParameters\n----------\nnodes: iterable of integer, optional None\n    If `None`, walks through all nodes of the corpus in canonical order.\n    Otherwise, walks through the given nodes in canonical order.\nevents: boolean, optional False\n    If True, wraps the generated nodes in event tuples as described above.\n\nReturns\n-------\nnodes: integer\n    One at a time.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "nodes",
                      "type": "Iterable[int] | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "events",
                      "type": "bool",
                      "default": "False",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "Generator[(int | tuple[(int, bool | None)], None, None)]"
                  },
                  "decorators": []
                }
              },
              "attributes": {
                "api": {
                  "name": "api",
                  "type": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "api"
                  }
                },
                "otypeRank": {
                  "name": "otypeRank",
                  "type": "dict[(str, int)]",
                  "docstring": {
                    "summary": "Dictionary that provides a ranking of the node types.",
                    "description": "Dictionary that provides a ranking of the node types.\n\nThe node types are ordered in `C.levels.data`, and if you reverse that list,\nyou get the rank of a type by looking at the position in which that type occurs.\n\nThe `slotType` has rank 0 (`otypeRank[F.otype.slotType] == 0`),\nand the more comprehensive a type is, the higher its rank.",
                    "parsed": []
                  },
                  "value": {
                    "cls": "ExprDictComp",
                    "generators": [
                      {
                        "cls": "ExprComprehension",
                        "conditions": [],
                        "is_async": false,
                        "iterable": {
                          "arguments": [
                            {
                              "arguments": [
                                {
                                  "cls": "ExprAttribute",
                                  "values": [
                                    {
                                      "cls": "ExprName",
                                      "member": null,
                                      "name": "C"
                                    },
                                    {
                                      "cls": "ExprName",
                                      "member": null,
                                      "name": "levels"
                                    },
                                    {
                                      "cls": "ExprName",
                                      "member": null,
                                      "name": "data"
                                    }
                                  ]
                                }
                              ],
                              "cls": "ExprCall",
                              "function": {
                                "cls": "ExprName",
                                "member": null,
                                "name": "reversed"
                              }
                            }
                          ],
                          "cls": "ExprCall",
                          "function": {
                            "cls": "ExprName",
                            "member": null,
                            "name": "enumerate"
                          }
                        },
                        "target": {
                          "cls": "ExprTuple",
                          "elements": [
                            {
                              "cls": "ExprName",
                              "member": null,
                              "name": "i"
                            },
                            {
                              "cls": "ExprName",
                              "member": null,
                              "name": "d"
                            }
                          ],
                          "implicit": true
                        }
                      }
                    ],
                    "key": {
                      "cls": "ExprSubscript",
                      "left": {
                        "cls": "ExprName",
                        "member": null,
                        "name": "d"
                      },
                      "slice": "0"
                    },
                    "value": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "i"
                    }
                  }
                },
                "sortKey": {
                  "name": "sortKey",
                  "type": "Callable[([int], int)]",
                  "docstring": {
                    "summary": "Sort key function for the canonical ordering between nodes.",
                    "description": "Sort key function for the canonical ordering between nodes.\n\n\n!!! hint \"usage\"\n    The following two pieces of code do the same thing:\n    `sortNodes(nodeSet)` and `sorted(nodeSet, key=sortKey)`.\n\nSee Also\n--------\ncfabric.nodes: canonical ordering\ncfabric.nodes.Nodes.sortNodes: sorting nodes",
                    "parsed": []
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "rank_key"
                  }
                },
                "sortKeyChunk": {
                  "name": "sortKeyChunk",
                  "type": "",
                  "docstring": {
                    "summary": "Sort key function for the canonical ordering between chunks of nodes.",
                    "description": "Sort key function for the canonical ordering between chunks of nodes.\n\n    sorted(chunks, key=sortKeyChunk)\n\nA chunk is a tuple consisting of a node and a subset of its slots.\nMostly, this subset of slots is contiguous (no gaps), and mostly it is\nmaximal: the slots immediately before and after the chunk do not belong to the node.\n\nBut the sort key also works if these conditions are not met.\n\nNotes\n-----\nThe use case for this function is that we have a bunch of nodes,\neach linked to a set of slots.\nFor each node, we have split its slot set in maximal contiguous parts, its chunks.\nNow we want to order those chunks in the canonical ordering.\n\nSee Also\n--------\ncfabric.nodes: canonical ordering",
                    "parsed": []
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "sortKeyChunk"
                  }
                },
                "sortKeyChunkLength": {
                  "name": "sortKeyChunkLength",
                  "type": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "sortKeyChunkLength"
                  }
                },
                "sortKeyTuple": {
                  "name": "sortKeyTuple",
                  "type": "Callable[([tuple[(int, ...)]], tuple[(int, ...)])]",
                  "docstring": {
                    "summary": "Sort key function for the canonical ordering between tuples of nodes.\nIt applies `sortKey` to each member of the tuple.\nHandy to sort search results. We can sort them in canonical order like this:",
                    "description": "Sort key function for the canonical ordering between tuples of nodes.\nIt applies `sortKey` to each member of the tuple.\nHandy to sort search results. We can sort them in canonical order like this:\n\n    sorted(results, key=lambda tup: tuple(sortKey(n) for n in tup))\n\nThis is exactly what `sortKeyTuple` does, but then a bit more efficient:\n\n    sorted(results, key=sortKeyTuple)\n\nSee Also\n--------\ncfabric.nodes: canonical ordering",
                    "parsed": []
                  },
                  "value": {
                    "body": {
                      "arguments": [
                        {
                          "cls": "ExprGeneratorExp",
                          "element": {
                            "arguments": [
                              {
                                "cls": "ExprName",
                                "member": null,
                                "name": "n"
                              }
                            ],
                            "cls": "ExprCall",
                            "function": {
                              "cls": "ExprName",
                              "member": null,
                              "name": "rank_key"
                            }
                          },
                          "generators": [
                            {
                              "cls": "ExprComprehension",
                              "conditions": [],
                              "is_async": false,
                              "iterable": {
                                "cls": "ExprName",
                                "member": null,
                                "name": "tup"
                              },
                              "target": {
                                "cls": "ExprName",
                                "member": null,
                                "name": "n"
                              }
                            }
                          ]
                        }
                      ],
                      "cls": "ExprCall",
                      "function": {
                        "cls": "ExprName",
                        "member": null,
                        "name": "tuple"
                      }
                    },
                    "cls": "ExprLambda",
                    "parameters": [
                      {
                        "annotation": null,
                        "cls": "ExprParameter",
                        "default": null,
                        "kind": "positional or keyword",
                        "name": "tup"
                      }
                    ]
                  }
                }
              }
            }
          },
          "functions": {},
          "modules": {},
          "aliases": {
            "Api": {
              "name": "Api",
              "target": "cfabric.core.api.Api"
            },
            "Callable": {
              "name": "Callable",
              "target": "collections.abc.Callable"
            },
            "Generator": {
              "name": "Generator",
              "target": "collections.abc.Generator"
            },
            "Iterable": {
              "name": "Iterable",
              "target": "collections.abc.Iterable"
            },
            "TYPE_CHECKING": {
              "name": "TYPE_CHECKING",
              "target": "typing.TYPE_CHECKING"
            },
            "annotations": {
              "name": "annotations",
              "target": "__future__.annotations"
            },
            "functools": {
              "name": "functools",
              "target": "functools"
            },
            "safe_rank_key": {
              "name": "safe_rank_key",
              "target": "cfabric.utils.helpers.safe_rank_key"
            }
          }
        },
        "text": {
          "name": "text",
          "kind": "module",
          "path": "",
          "docstring": {
            "summary": "# Text API",
            "description": "# Text API\n\nHere are the functions that enable you to get the actual text in the dataset.\nThere are several things to accomplish here, such as\n\n*   support the structure of the corpus\n*   support a rigid section system usable by the CF browser\n*   handle multilingual section labels;\n*   switch between various text representations.\n\nThe details of the Text API are dependent on the `cfabric.parameters.WARP` feature `otext`,\nwhich is a configuration feature.\n\n!!! hint \"T\"\n    The Text API is exposed as `T` or `Text`.\n\n!!! note \"`otext` is optional\"\n    If your dataset does not have an `otext` feature,\n    the Text API will not be build.\n    If it exists, but does not specify structure or sections,\n    those parts of the Text API will not be built.\n    Likewise for text representations.\n\n## Structure\n\nIf a corpus has sectional elements, such as\n`series`, `volume`, `book`, `part`, `document`, `chapter`, `fragment`, `verse`,\n`halfverse`, `line`, etc, then you can configure those elements as structural types.\n\nIf your CF dataset designer has done that, the `T.api` will provide a number\nof handy functions to navigate your corpus along its structure, programmatically.\n\nThe\n[banks](https://nbviewer.jupyter.org/github/annotation/banks/blob/master/programs/structure.ipynb)\nexample corpus shows a full example.\n\nStructure is defined in the `otext` feature, by means of the keys\n`structureTypes` and `structureFeatures`.\nThese are comma-separated lists of equal length.\n\n`structureTypes` specifies the node types\nthat act as structural types, in the order from biggest to smallest.\n\n`structureFeatures` specifies a feature that corresponds to each\nstructural type. This feature must contain the label of the structural\nelement, e.g. the title of a book, the number of a verse, etc.\n\nThe order of the section types is significant.\nSuppose you have a book with a single chapter. Is the chapter part of the book,\nor is the book part of the chapter?\nThe order decides. If `book` is mentioned in `structureTypes` before `chapter`\nthen the chapter is part of the book, and not the other way around.\n\nHowever, it is allowed to have nesting of elements of the same kind.\n\n!!! explanation \"Proper embedding not required\"\n    There are no assumptions on how exactly the structural elements lie\n    embedded in each other, and whether they consist of uninterrupted stretches\n    of material or not.\n\n    Suppose a we have a book with two disjoint chapters and there is a verse that\n    has material in both chapters. Then that verse is part of neither chapter,\n    but it is still part of the book.\n    If you go down from that book to its substructural elements, you find not only\n    its chapters, but also that verse.\n\n    So the great freedom with respect to structural elements also brings greater\n    responsibility when using that structure.\n\n## Sections\n\nIn `otext` the main section levels (usually `book`, `chapter`, `verse`) can be\ndefined. It loads the features it needs (so you do not have to specify those\nfeatures, unless you want to use them via `F`). And finally, it makes some\nfunctions available by which you can make handy use of that information.\n\n!!! explanation \"Section levels from a limited, rigid system\"\n    There are up to three section levels, and this is a hard coded boundary.\n    That makes this section system unsuitable to faithfully reflect the\n    rich sectioning that may be present in a corpus.\n\n    On the other hand, applications (such as CF apps) can access a predictable\n    sectioning system by which they can divide the material in practical portions.\n\n    The rule of thumb is:\n\n    Level 1 divides the corpus into top level units,\n    of which there might be (very) many. The CF browser has a control that\n    can deal with long lists.\n\n    Level 2 divides a level 1 section into a division that can be loaded into\n    a webpage, without overwhelming the browser.\n    Even better, it should be just one or a few screenfuls of text, when\n    represented in `plain` view.\n\n    Level 3 divides a level 2 section into divisions that roughly corresponds to lines.\n    Such lines typically take up one screenful if represented in `pretty` view.\n\n!!! explanation \"Section levels are generic\"\n    In this documentation, we call the main section level `book`, the second level\n    `chapter`, and the third level `verse`. CF, however, is completely\n    agnostic about how these levels are called. It is prepared to distinguish three\n    section levels, but how they are called, must be configured in the dataset. The\n    task of the `otext` feature is to declare which node type and feature correspond\n    with which section level. CF assumes that the first section level may\n    have multilingual headings, but that section levels two and three have single\n    language headings (numbers of some kind).\n\n!!! explanation \"String versus number\"\n    Chapter and verse numbers will be considered to be strings or\n    integers, depending on whether your dataset has declared the corresponding\n    feature with `valueType` as `str` or as `int`.\n\n    Conceivably, other works might have chapter and verse numbers\n    like `XIV`, '3A', '4.5', and in those cases these numbers are obviously not\n    `int`.\n\n!!! explanation \"levels of node types\"\n    Usually, CF computes the hierarchy of node types correctly, in the\n    sense that node types that act as containers have a lower level than node types\n    that act as containees. So books have the lowest level, words the highest. See\n    [levels](#levels). However, if this level assignment turns out to be wrong for\n    your dataset, you can configure the right order in the `otext` feature, by means\n    of a key `levels` with value a comma separated list of levels. Example:\n\n        @levels=tablet,face,column,line,case,cluster,quad,comment,sign\n\n    If you only want to ensure that a certain type is smaller than other types,\n    you can add a key `levelConstraints` with a `;`-separated list of\n    constraints, where each constraint has the form\n\n    *smaller* `<` *bigger-1*, *bigger-2*, ...\n\n    Example:\n\n        @levelConstraints=note < chunk, p ; opener < chunk\n\n## Book names and languages\n\nThe names of the books may be available in multiple languages. The book names\nare stored in node features with names of the form `book@la`, where `la` is\nthe [ISO 639](https://en.wikipedia.org/wiki/ISO_639) two-letter code for that\nlanguage. CF will always load these features.\n\n## Text representation\n\nText can be represented in multiple ways. We provide a number of formats with\nstructured names.\n\nA format name is a string of keywords separated by `-`:\n\n*what*`-`*how*`-`*fullness*`-`*modifier*\n\nFor Hebrew any combination of the following could be useful formats:\n\nkeyword | value | meaning\n------- | ----- | -------\n*what* | `text` | words as they belong to the text\n*what* | `lex` | lexemes of the words\n*how* | `orig` | in the original script (Hebrew, Greek, Syriac) (all UNICODE)\n*how* | `trans` | in (latin) transliteration\n*how* | `phono` | in phonetic / phonological transcription\n*fullness* | `full` | complete with accents and all diacritical marks\n*fullness* | `plain` | with accents and diacritical marks stripped, in Hebrew only the consonants are left\n*modifier* | `ketiv` | (Hebrew): where there is ketiv / qere, follow ketiv instead of qere (default);\n\nThe default format is `text-orig-full`, we assume that every CF dataset defines\nthis format.\n\nA format is a template string, with fixed text and variable text.\nThe variable text comes from features.\nYou specify the interpolation of features by surrounding the feature name\nby `{ }`.\n\nFor example, if `letters` and `after` are features, this is a text format:\n\n```\n{letters}{after}\n```\n\nIf you need tabs and newlines in a format, specify them by `\\t` and `\\n`.\n\nYou can also conditionally choose between features, to\nsubstitute the value of another feature in case of empty values.\n\nFor example, if you want to use the `normal` feature to represent a word,\nbut if there is also a rare feature `special` that you want to use if it\nis defined for that word, you can make a format\n\n```\n{special/normal}\n```\n\nThis tries the feature `special` first, and if that is undefined, it takes\n`normal`.\n\n!!! caution \"undefined versus empty\"\n    The criterion to skip the value of feature `special` and use the value\n    of feature `normal` is that `special` either has no value, or its value is\n    `None` (CF essentially makes no difference between the two).\n    But if the value of `special` happens to be the empty string, it will be used!\n\n!!! hint \"longer chains\"\n    You can chain multiple features with `/`, as many as you want:\n\n        {veryspecial/special/often/normal}\n\nYou can also add a fixed default. If you want to display a `.` if\nneither `special` nor `normal` exist, you can say\n\n```\n{special/normal:.}\n```\n\nYou can also specify the empty string as the default:\n\n```\n{special/normal:}\n```\n\nHowever, you do not need to do that, because the default is the empty string\nby default!\n\nCF datasets may also define formats of the form\n\n`nodeType-default`\n\nwhere `nodeType` is a valid type of node in the dataset.\n\nThese formats will be invoked in cases where no explicit format is specified as\na fall back for some kind of nodes. See `T.text()` below.\n\nA node type may also be prepended to a format, with `#` as separator:\n\n`nodeType#textformat`\n\nIn general, a format can be applied to any kind of node, and it will\nlookup the features defined in its template for that node.\nBut some features have meaningful values for particular node types only.\n\nSo formats may indicate that they should be applied to nodes of a specific type.\nSee `T.text()` below.\n\nRemember that the formats are defined in the `otext` warp configuration feature of your\nset, not by CF.\n\n!!! note \"Freedom of names for formats\"\n    There is complete freedom of choosing names for text formats.\n    They do not have to complied with the above-mentioned scheme.\n\n!!! note \"layout in formats\"\n    So far, text formats only result in plain text.\n    A corpus app (`tf.advanced.app`) may define and implement extra text\n    formats which may invoke all HTML+CSS styling that you can think of.\n\n### The T.text() function\n\nThe way `cfabric.text.Text.text` responds to its parameters may look complicated,\nbut the rationale is that the defaults should be sensible.\n\nConsider the simplest call to this function: `T.text(node)`.\nThis will apply the default format to `node`.\nIf `node` is non-slot, then in most cases\nthe default format will be applied to the slots contained in `node`.\n\nBut for special node types, where the best representation\nis not obtained by descending down\nto the contained slot nodes, the dataset may define\nspecial default types that use other\nfeatures to furnish a decent representation.\n\n!!! explanation \"lexemes\"\n    In some corpora case this happens for the type of lexemes: `lex`.\n    Lexemes contain their occurrences\n    as slots, but the representation of a lexeme\n    is not the string of its occurrences, but\n    resides in a feature such as `voc_lex_utf8`\n    (vocalized lexeme in UNICODE).\n\n    If the dataset defines the format `lex-default={lex} `,\n    this is the only thing needed to regulate\n    the representation of a lexeme.\n\n    Hence, `T.text(lx)` results in the lexeme representation of `lx`.\n\n    But if you really want to print out all occurrences of lexeme `lx`,\n    you can say `T.text(lx, descend=True)`.\n\n!!! explanation \"words and signs\"\n    In some corpora the characters or signs are the slot level, and there is\n    a non slot level of words.\n    Some text formats are best defined on signs, others best on words.\n\n    For example, if words are associated with lexemes, stored in a word\n    feature `lex`, we can define a text format\n\n        lex-orig-full=word#{lex}\n\n    When you call `T.text(n)` for a non-slot, non-word node,\n    normally the node will be replaced by the slot nodes it contains,\n    before applying the template in the format.\n    But if you pass a format that specifies a different node type,\n    nodes will be replaced by contained nodes of that type. So\n\n        T.text(n, fmt='lex-orig-full')\n\n    will lookup all word nodes under `n` and apply the template `{lex}`\n    to them.\n\n!!! caution \"same and different behaviours\"\n    The consequences of the rules might be unexpected in some cases.\n    Here are a few observations:\n\n    *   formats like `phrase-default` can be implicitly invoked for phrase nodes,\n        but `descend=True` prevents that;\n    *   when a format targeted at phrases is invoked for phrase nodes,\n        `descend=True` will not cause the expansion of those nodes to slot nodes,\n        because the phrase node is already expanded\n        to the target type of the format;\n\n\n!!! hint \"memory aid\"\n    *   If `fmt` is explicitly passed, it will be the format used\n        no matter what, and it determines the level of the nodes to descend to;\n    *   Descending is the norm, it can only be prevented\n        by setting default formats for node types or\n        by passing `descend=False` to `T.text()`;\n    *   `descend=True` is stronger than type-specific default formats,\n        but weaker than explicitly passed formats;\n    *   **Pass `explain=True` for a dynamic explanation.**\n\n!!! note \"Non slot nodes allowed\"\n    In most cases, the nodes fed to `T.text()` are slots, and the formats are\n    templates that use features that are defined for slots.\n\n    But nothing prevents you to define a format\n    for non-slot nodes, and use features\n    defined for a non-slot node type.\n\n    If, for example, your slot type is *glyph*,\n    and you want a format that renders\n    lexemes, which are not defined for glyphs but for words,\n    you can just define a format in terms of word features.\n\n    It is your responsibility to take care to use the formats\n    for node types for which they make sense.\n\n!!! caution \"Escape white-space in formats\"\n    When defining formats in `otext.tf`,\n    if you need a newline or tab in the format,\n    specify it as `\\n` and `\\t`.\n    (i.e. a single backslash plus the character `n` or `t`.\n    In your editor you may have to type the backslash twice in order to put it\n    in the file once!)",
            "parsed": []
          },
          "classes": {
            "Text": {
              "name": "Text",
              "kind": "class",
              "path": "",
              "docstring": {
                "summary": "Low level text representation, including section headings.",
                "description": "Low level text representation, including section headings.\n\nIn addition to the methods that are directly defined, there are also\nmethods `xxxName()` and `xxxNode()` where `xxx` is whatever the node type of\nlevel 1 sections is.\n\n!!! note \"level 1 node types\"\n    In the BHSA the `xxx` is `book`, in the DSS it is `scroll`,\n    in Old Babylonian it is `document`, and in Uruk it is `tablet`.\n\n    Here we take the BHSA as example: `bookName()` and `bookNode()`\n\n        T.bookName(node, lang='en')\n        T.bookNode(name, lang='en')\n\n    with `node:int` the node in question, `name:str` the name in question,\n    and `lang='en'` the language of the book name.",
                "parsed": []
              },
              "bases": [],
              "methods": {
                "__init__": {
                  "name": "__init__",
                  "kind": "function",
                  "signature": "(self, api: Api)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "api",
                      "type": "Api",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "_compileFormat": {
                  "name": "_compileFormat",
                  "kind": "function",
                  "signature": "(self, rtpl: str, feats: list[tuple[(tuple[(str, ...)], str)]])",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "rtpl",
                      "type": "str",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "feats",
                      "type": "list[tuple[(tuple[(str, ...)], str)]]",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "Callable[([int], str)]"
                  },
                  "decorators": []
                },
                "_compileFormats": {
                  "name": "_compileFormats",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "_makeFunc": {
                  "name": "_makeFunc",
                  "kind": "function",
                  "signature": "(self, feat: tuple[(str, ...)], default: str)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "feat",
                      "type": "tuple[(str, ...)]",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "default",
                      "type": "str",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "Callable[([int], str)]"
                  },
                  "decorators": []
                },
                "_sec0Name": {
                  "name": "_sec0Name",
                  "kind": "function",
                  "signature": "(self, n: int, lang: str = 'en')",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "n",
                      "type": "int",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "lang",
                      "type": "str",
                      "default": "'en'",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "str"
                  },
                  "decorators": []
                },
                "_sec0Node": {
                  "name": "_sec0Node",
                  "kind": "function",
                  "signature": "(self, name: str | int, lang: str = 'en')",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "name",
                      "type": "str | int",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "lang",
                      "type": "str",
                      "default": "'en'",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "int | None"
                  },
                  "decorators": []
                },
                "down": {
                  "name": "down",
                  "kind": "function",
                  "signature": "(self, n: int)",
                  "docstring": {
                    "summary": "Gives the children of a structural node.",
                    "description": "Gives the children of a structural node.\n\nParameters\n----------\nn: integer\n    The node whose children to retrieve.\n\nReturns\n-------\nchildren: tuple of integers\n    The children are those structural nodes whose headings are one\n    longer than the one from `n`.\n\nNotes\n-----\n!!!hint \"Example\"\n    The children of `((book, Genesis), (chapter, 3))` are the nodes\n    with heading `((book, Genesis), (chapter, 3), (verse, 1))`, etc.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "n",
                      "type": "int",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "tuple[(int, ...)] | None"
                  },
                  "decorators": []
                },
                "headingFromNode": {
                  "name": "headingFromNode",
                  "kind": "function",
                  "signature": "(self, n: int)",
                  "docstring": {
                    "summary": "Gives the full heading of a structural node.",
                    "description": "Gives the full heading of a structural node.\n\nParameters\n----------\nn: integer\n    The node whose heading to retrieve.\n\nReturns\n-------\nheading: tuple of pairs\n    It is the tuple of pairs (node type, feature value)\n    for all ancestors of `n`.\n\nNotes\n-----\n!!!hint \"Example\"\n    E.g., the heading of the verse node corresponding to Genesis 3:16\n    is `((book, Genesis), (chapter, 3), (verse, 16))`.\n\n!!!hint \"Power tip\"\n    If you are interested in the complete mapping: it is stored in\n    the dictionary `hdFromNd`.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "n",
                      "type": "int",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "tuple[(tuple[(str, str | int)], ...)] | None"
                  },
                  "decorators": []
                },
                "nodeFromHeading": {
                  "name": "nodeFromHeading",
                  "kind": "function",
                  "signature": "(self, head: tuple[(tuple[(str, str | int)], ...)])",
                  "docstring": {
                    "summary": "Gives the node corresponding to a heading, provided it exists.",
                    "description": "Gives the node corresponding to a heading, provided it exists.\n\nParameters\n----------\nhead: tuple of pairs\n    See the result of `headingFromNode`.\n\nReturns\n-------\nnode: integer\n    If there is more than one node that corresponds to the heading,\n    only the last one in the corpus will be returned.\n    `hdMult` contains all such cases.\n\nNotes\n-----\n!!!hint \"Power tip\"\n    If you are interested in the complete mapping: it is stored in\n    the dictionary `ndFromHd`.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "head",
                      "type": "tuple[(tuple[(str, str | int)], ...)]",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "int | None"
                  },
                  "decorators": []
                },
                "nodeFromSection": {
                  "name": "nodeFromSection",
                  "kind": "function",
                  "signature": "(self, section: tuple[(str | int, ...)], lang: str = 'en')",
                  "docstring": {
                    "summary": "Given a section tuple, return the node of it.",
                    "description": "Given a section tuple, return the node of it.\n\nParameters\n----------\nsection: string\n    `section` consists of a book name (in language `lang`),\n    and a chapter number and a verse number\n    (both as strings or number depending on the value type of the\n    corresponding feature).\nlang: string, optional en\n    The language assumed for the section parts,\n    as far as they are language dependent.\n    Must be a 2-letter language code.\n\nReturns\n-------\nsection node: integer\n    If section labels for all three levels is present,\n    the result is a level 3 node.\n    If the level 3 label has been left out, the result is a level 2 node.\n    If both level 1 and level 2 labels have been left out,\n    the result is a level 1 node.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "section",
                      "type": "tuple[(str | int, ...)]",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "lang",
                      "type": "str",
                      "default": "'en'",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "int | None"
                  },
                  "decorators": []
                },
                "sectionFromNode": {
                  "name": "sectionFromNode",
                  "kind": "function",
                  "signature": "(self, n: int, lastSlot: bool = False, lang: str = 'en', fillup: bool = False, level: int | None = None)",
                  "docstring": {
                    "summary": "Gives the full heading of a section node.",
                    "description": "Gives the full heading of a section node.\n\nParameters\n----------\nn: integer\n    The node whose heading to retrieve.\nlastSlot: boolean, optional False\n    Whether the reference node will be the last slot contained by `n`\n    or the first slot.\nlang: string, optional en\n    The language assumed for the section parts,\n    as far as they are language dependent.\n    Must be a 2-letter language code.\nfillup: boolean, optional False\n    Whether to fill up the tuple with missing section elements.\nlevel: integer, optional None\n    If passed, only the first so many members of the tuple will be returned.\n\nReturns\n-------\nheading: tuple of pairs\n    If `n` is not a section node, a reference node `r` will be taken\n    according to the `lastSlot` parameter.\n\n    It is the tuple of integer / string values for section ancestors\n    of `r` and `r` itself,\n    where the `fillup` parameter plays the same role as in\n    `Text.sectionTuple`.\n\nNotes\n-----\n!!! hint \"crossing verse boundaries\"\n    Sometimes a sentence or clause in a verse continue into the next verse.\n    In those cases, this function will return different results for\n    `lastSlot=False` and `lastSlot=True`.\n\nWarnings\n--------\nNodes that lie outside any book, chapter, or verse\nwill get a `None` in the corresponding members of the returned tuple.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "n",
                      "type": "int",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "lastSlot",
                      "type": "bool",
                      "default": "False",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "lang",
                      "type": "str",
                      "default": "'en'",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "fillup",
                      "type": "bool",
                      "default": "False",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "level",
                      "type": "int | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "tuple[(str | int | None, ...)]"
                  },
                  "decorators": []
                },
                "sectionTuple": {
                  "name": "sectionTuple",
                  "kind": "function",
                  "signature": "(self, n: int, lastSlot: bool = False, fillup: bool = False)",
                  "docstring": {
                    "summary": "Gives a tuple of nodes that correspond to a section.",
                    "description": "Gives a tuple of nodes that correspond to a section.\n\nMore precisely, we retrieve the sections that contain a\nreference node, which is either the first slot or the last slot of the node\nin question.\n\nParameters\n----------\nn: integer\n    The node whose containing section to retrieve.\nlastSlot: boolean, optional False\n    Whether the reference node will be the last slot contained by `n`\n    or the first slot.\nfillup: boolean, optional False\n    Whether to fill up the tuple with missing section elements.\nReturns\n-------\nsection: tuple of integer\n    If `n` is not a section node, a reference node `r` will be taken\n    according to the `lastSlot` parameter.\n\n    If `fillup == False`:\n\n    If `r` is a level 0 section node,\n    `section` is the 1-element tuple `(r,)`.\n\n    If `r` is a level 1 section node,\n    *section* is a 2-element tuple, i.e.\n    the enclosing level 0 section node and `r` itself.\n\n    If `r` is a level 2 section node,\n    `section` is a 3-element tuple, i.e.\n    the enclosing level 0 and  1 section nodes and `r` itself.\n\n    If `fillup == True`, always a complete 3-tuple of a level 0, 1, and 2\n    section nodes is returned.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "n",
                      "type": "int",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "lastSlot",
                      "type": "bool",
                      "default": "False",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "fillup",
                      "type": "bool",
                      "default": "False",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "tuple[(int | str, ...)]"
                  },
                  "decorators": []
                },
                "splitDefaultFormat": {
                  "name": "splitDefaultFormat",
                  "kind": "function",
                  "signature": "(self, tpl: str)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "tpl",
                      "type": "str",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "str | None"
                  },
                  "decorators": []
                },
                "splitFormat": {
                  "name": "splitFormat",
                  "kind": "function",
                  "signature": "(self, tpl: str)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "tpl",
                      "type": "str",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "tuple[(str, str)]"
                  },
                  "decorators": []
                },
                "structure": {
                  "name": "structure",
                  "kind": "function",
                  "signature": "(self, node: int | None = None)",
                  "docstring": {
                    "summary": "Gives the structure of node and everything below it as a tuple.",
                    "description": "Gives the structure of node and everything below it as a tuple.\n\nParameters\n----------\nnode: integer, optional None\n    The node whose structure is asked for.\n    If *node* is None, the complete structure of the whole dataset is returned.\n\nReturns\n-------\nstructure: tuple\n    Nested tuple of nodes involved in the structure below a node.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "node",
                      "type": "int | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "tuple[(Any, ...)] | None"
                  },
                  "decorators": []
                },
                "structureInfo": {
                  "name": "structureInfo",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "Gives a summary of how structure has been configured in the dataset.",
                    "description": "Gives a summary of how structure has been configured in the dataset.\n\nIf there are headings that are the same for multiple structural nodes,\nyou'll get a warning here, and you are told how you can get all of those.\n\nIt also shows a short description of all structure-related methods\nof the `T` API.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "structurePretty": {
                  "name": "structurePretty",
                  "kind": "function",
                  "signature": "(self, node: int | None = None, fullHeading: bool = False)",
                  "docstring": {
                    "summary": "Gives the structure of node and everything below it as a string.",
                    "description": "Gives the structure of node and everything below it as a string.\n\nParameters\n----------\nnode: integer, optional None\n    The node whose structure is asked for.\n    If *node* is None, the complete structure of the whole dataset is returned.\nfullHeading: boolean, optional False\n    Normally, for each structural element, only its own subheading is added.\n    But if you want to see the full heading, consisting of the headings of a\n    node and all of its parents, pass `True` for this parameter.\n\nReturns\n-------\nstructure: string\n    Pretty representation as string with indentations of the structure\n    below a node.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "node",
                      "type": "int | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "fullHeading",
                      "type": "bool",
                      "default": "False",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "str | None"
                  },
                  "decorators": []
                },
                "text": {
                  "name": "text",
                  "kind": "function",
                  "signature": "(self, nodes: int | Iterable[int], fmt: str | None = None, descend: bool | None = None, func: Callable[([int], str)] | None = None, explain: bool = False, kwargs: Any = {})",
                  "docstring": {
                    "summary": "Gives the text that corresponds to a bunch of nodes.",
                    "description": "Gives the text that corresponds to a bunch of nodes.\n\nThe\n[banks](https://nbviewer.jupyter.org/github/annotation/banks/blob/master/programs/formats.ipynb)\nexample corpus shows examples.\n\nParameters\n----------\n\nnodes: dict\n    *nodes* can be a single node or an arbitrary iterable of nodes\n    of arbitrary types.\n    No attempt will be made to sort the nodes.\n    If you need order, it is better to sort the nodes first.\n\nfmt: boolean, optional None\n    The text-format of the text representation.\n\n    If it is not specified or `None`, each node will be formatted with\n    a node type specific format, defined as `nodeType-default`, if it\n    exists.\n\n    If there is no node specific format, the default format\n    `text-orig-full` will be used.\n\n    If `text-orig-full` is not defined, an error message will be issued,\n    and the nodes will be represented by their types and numbers.\n\n    If a value for `fmt` is passed, but it is not a format defined in the\n    `otext.tf` feature, there will be an error message and `None` is returned.\n\ndescend: boolean, optional None\n    Whether to descend to constituent nodes.\n\n    If `True`, nodes will be replaced by a sequence of their constituent nodes,\n    which have a type specified by the format chosen, or, if the format does\n    not specify such a type, the node will be replaced\n    by the slots contained in it.\n\n    If `False`, nodes will not be replaced.\n\n    If *descend* is not specified or None,\n    a node will be replaced by its constituent nodes,\n    unless its type is associated with the given format or,\n    if no format is given, by the default format of its type, or,\n    if there is no such format, by its slots.\n\n    !!! caution \"no nodes to descend to\"\n        If you call `T.text(n, fmt=myfmt)`\n        and `myfmt` is targeted to a node type that is\n        bigger than the node type of `n`,\n        then the so-called descending leads to an empty\n        sequence of nodes and hence to an empty string.\n\nexplain: boolean, optional False\n    The logic of this function is subtle.\n    If you call it and the results baffles you, pass `explain=True`\n    and it will explain what it is doing.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "nodes",
                      "type": "int | Iterable[int]",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "fmt",
                      "type": "str | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "descend",
                      "type": "bool | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "func",
                      "type": "Callable[([int], str)] | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "explain",
                      "type": "bool",
                      "default": "False",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "kwargs",
                      "type": "Any",
                      "default": "{}",
                      "kind": "variadic keyword"
                    }
                  ],
                  "returns": {
                    "type": "str"
                  },
                  "decorators": []
                },
                "top": {
                  "name": "top",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "Gives all top-level structural nodes in the dataset.\nThese are the nodes that are not embedded in a structural node of the same\nor a higher level.",
                    "description": "Gives all top-level structural nodes in the dataset.\nThese are the nodes that are not embedded in a structural node of the same\nor a higher level.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "tuple[(int, ...)] | None"
                  },
                  "decorators": []
                },
                "up": {
                  "name": "up",
                  "kind": "function",
                  "signature": "(self, n: int)",
                  "docstring": {
                    "summary": "Gives the parent of a structural node.",
                    "description": "Gives the parent of a structural node.\n\nParameters\n----------\nn: integer\n    The node whose parent to retrieve.\n\nReturns\n-------\nparent: integer\n    The parent is that structural node that whose heading you get from\n    the heading of `n` minus its last element.\n\nNotes\n-----\n!!!hint \"Example\"\n    The parent of `((book, Genesis), (chapter, 3), (verse, 16))`\n    is the node that has heading `((book, Genesis), (chapter, 3))`.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "n",
                      "type": "int",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "int | None"
                  },
                  "decorators": []
                }
              },
              "attributes": {
                "api": {
                  "name": "api",
                  "type": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "api"
                  }
                },
                "config": {
                  "name": "config",
                  "type": "dict[(str, str)]",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "config"
                  }
                },
                "defaultFormat": {
                  "name": "defaultFormat",
                  "type": "str",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "DEFAULT_FORMAT"
                  }
                },
                "defaultFormats": {
                  "name": "defaultFormats",
                  "type": "dict[(str, str)]",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprDict",
                    "keys": [],
                    "values": []
                  }
                },
                "formats": {
                  "name": "formats",
                  "type": "dict[(str, str | None)]",
                  "docstring": {
                    "summary": "The text representation formats that have been defined in your dataset.",
                    "description": "The text representation formats that have been defined in your dataset.",
                    "parsed": []
                  },
                  "value": {
                    "cls": "ExprDict",
                    "keys": [],
                    "values": []
                  }
                },
                "good": {
                  "name": "good",
                  "type": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "good"
                  }
                },
                "headings": {
                  "name": "headings",
                  "type": "tuple[(tuple[(str, str)], ...)]",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "body": {
                      "cls": "ExprTuple",
                      "elements": [],
                      "implicit": false
                    },
                    "cls": "ExprIfExp",
                    "orelse": {
                      "arguments": [
                        {
                          "arguments": [
                            {
                              "cls": "ExprAttribute",
                              "values": [
                                {
                                  "cls": "ExprName",
                                  "member": null,
                                  "name": "self"
                                },
                                {
                                  "cls": "ExprName",
                                  "member": null,
                                  "name": "structureTypes"
                                }
                              ]
                            },
                            {
                              "cls": "ExprAttribute",
                              "values": [
                                {
                                  "cls": "ExprName",
                                  "member": null,
                                  "name": "self"
                                },
                                {
                                  "cls": "ExprName",
                                  "member": null,
                                  "name": "structureFeats"
                                }
                              ]
                            }
                          ],
                          "cls": "ExprCall",
                          "function": {
                            "cls": "ExprName",
                            "member": null,
                            "name": "zip"
                          }
                        }
                      ],
                      "cls": "ExprCall",
                      "function": {
                        "cls": "ExprName",
                        "member": null,
                        "name": "tuple"
                      }
                    },
                    "test": {
                      "cls": "ExprCompare",
                      "comparators": [
                        "None"
                      ],
                      "left": {
                        "cls": "ExprName",
                        "member": null,
                        "name": "structure"
                      },
                      "operators": [
                        "is"
                      ]
                    }
                  }
                },
                "languages": {
                  "name": "languages",
                  "type": "dict[(str, dict[(str, str)])]",
                  "docstring": {
                    "summary": "A dictionary of the languages that are available for book names.",
                    "description": "A dictionary of the languages that are available for book names.",
                    "parsed": []
                  },
                  "value": {
                    "cls": "ExprDict",
                    "keys": [],
                    "values": []
                  }
                },
                "nameFromNode": {
                  "name": "nameFromNode",
                  "type": "dict[(str, dict[(int, str)])]",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprDict",
                    "keys": [],
                    "values": []
                  }
                },
                "nodeFromName": {
                  "name": "nodeFromName",
                  "type": "dict[(str, dict[(tuple[(str, str)], int)])]",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprDict",
                    "keys": [],
                    "values": []
                  }
                },
                "sectionFeats": {
                  "name": "sectionFeats",
                  "type": "tuple[(str, ...)]",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprAttribute",
                    "values": [
                      {
                        "cls": "ExprName",
                        "member": null,
                        "name": "CF"
                      },
                      {
                        "cls": "ExprName",
                        "member": null,
                        "name": "sectionFeats"
                      }
                    ]
                  }
                },
                "sectionFeatsWithLanguage": {
                  "name": "sectionFeatsWithLanguage",
                  "type": "set[str]",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "arguments": [
                      {
                        "cls": "ExprName",
                        "member": null,
                        "name": "CF"
                      },
                      "'sectionFeatsWithLanguage'",
                      {
                        "arguments": [],
                        "cls": "ExprCall",
                        "function": {
                          "cls": "ExprName",
                          "member": null,
                          "name": "set"
                        }
                      }
                    ],
                    "cls": "ExprCall",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "getattr"
                    }
                  }
                },
                "sectionFeatureTypes": {
                  "name": "sectionFeatureTypes",
                  "type": "list[str]",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprList",
                    "elements": []
                  }
                },
                "sectionFeatures": {
                  "name": "sectionFeatures",
                  "type": "list[dict[(int, str | int)]]",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprList",
                    "elements": []
                  }
                },
                "sectionTypeSet": {
                  "name": "sectionTypeSet",
                  "type": "set[str]",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "arguments": [
                      {
                        "cls": "ExprAttribute",
                        "values": [
                          {
                            "cls": "ExprName",
                            "member": null,
                            "name": "CF"
                          },
                          {
                            "cls": "ExprName",
                            "member": null,
                            "name": "sectionTypes"
                          }
                        ]
                      }
                    ],
                    "cls": "ExprCall",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "set"
                    }
                  }
                },
                "sectionTypes": {
                  "name": "sectionTypes",
                  "type": "tuple[(str, ...)]",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprAttribute",
                    "values": [
                      {
                        "cls": "ExprName",
                        "member": null,
                        "name": "CF"
                      },
                      {
                        "cls": "ExprName",
                        "member": null,
                        "name": "sectionTypes"
                      }
                    ]
                  }
                },
                "structureFeats": {
                  "name": "structureFeats",
                  "type": "tuple[(str, ...)]",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprAttribute",
                    "values": [
                      {
                        "cls": "ExprName",
                        "member": null,
                        "name": "CF"
                      },
                      {
                        "cls": "ExprName",
                        "member": null,
                        "name": "structureFeats"
                      }
                    ]
                  }
                },
                "structureTypeSet": {
                  "name": "structureTypeSet",
                  "type": "set[str]",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "arguments": [
                      {
                        "cls": "ExprAttribute",
                        "values": [
                          {
                            "cls": "ExprName",
                            "member": null,
                            "name": "self"
                          },
                          {
                            "cls": "ExprName",
                            "member": null,
                            "name": "structureTypes"
                          }
                        ]
                      }
                    ],
                    "cls": "ExprCall",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "set"
                    }
                  }
                },
                "structureTypes": {
                  "name": "structureTypes",
                  "type": "tuple[(str, ...)]",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprAttribute",
                    "values": [
                      {
                        "cls": "ExprName",
                        "member": null,
                        "name": "CF"
                      },
                      {
                        "cls": "ExprName",
                        "member": null,
                        "name": "structureTypes"
                      }
                    ]
                  }
                }
              }
            }
          },
          "functions": {},
          "modules": {},
          "aliases": {
            "Any": {
              "name": "Any",
              "target": "typing.Any"
            },
            "Api": {
              "name": "Api",
              "target": "cfabric.core.api.Api"
            },
            "Callable": {
              "name": "Callable",
              "target": "collections.abc.Callable"
            },
            "Iterable": {
              "name": "Iterable",
              "target": "collections.abc.Iterable"
            },
            "OTEXT": {
              "name": "OTEXT",
              "target": "cfabric.core.config.OTEXT"
            },
            "TYPE_CHECKING": {
              "name": "TYPE_CHECKING",
              "target": "typing.TYPE_CHECKING"
            },
            "annotations": {
              "name": "annotations",
              "target": "__future__.annotations"
            },
            "logging": {
              "name": "logging",
              "target": "logging"
            },
            "np": {
              "name": "np",
              "target": "numpy"
            }
          }
        }
      },
      "aliases": {
        "Locality": {
          "name": "Locality",
          "target": "cfabric.navigation.locality.Locality"
        },
        "Nodes": {
          "name": "Nodes",
          "target": "cfabric.navigation.nodes.Nodes"
        },
        "Text": {
          "name": "Text",
          "target": "cfabric.navigation.text.Text"
        }
      }
    },
    "precompute": {
      "name": "precompute",
      "kind": "module",
      "path": "",
      "docstring": {
        "summary": "Pre-computation logic for Context-Fabric.",
        "description": "Pre-computation logic for Context-Fabric.\n\nThis module provides functions to compute derived data structures\nsuch as levels, order, rank, and section boundaries.",
        "parsed": []
      },
      "classes": {},
      "functions": {},
      "modules": {
        "prepare": {
          "name": "prepare",
          "kind": "module",
          "path": "",
          "docstring": {
            "summary": "# Pre-compute data.",
            "description": "# Pre-compute data.\n\nFor CF to work efficiently, some derived data needs to be pre-computed.\nThe pre-computed data has a similar function as indexes in a database.\n\nPre-computation is triggered when `cfabric.fabric.Fabric` loads features, and\nthe order and nature of the steps is configured in\n`cfabric.fabric.PRECOMPUTE`.\n\nThe functions in this module implement those tasks.",
            "parsed": []
          },
          "classes": {},
          "functions": {
            "boundary": {
              "name": "boundary",
              "kind": "function",
              "signature": "(info: InfoFunc, error: ErrorFunc, otype: OtypeData, oslots: OslotsData, rank: RankData)",
              "docstring": {
                "summary": "Computes boundary data.",
                "description": "Computes boundary data.\n\nFor each slot, the nodes that start at that slot and the nodes that end\nat that slot are collected.\n\nBoundary data is used by the API functions\n`cfabric.locality.Locality.p`.\nand\n`cfabric.locality.Locality.n`.\n\nParameters\n----------\ninfo: function\n    Method to write informational messages to the console.\nerror: function\n    Method to write error messages to the console.\notype: iterable\n    The data of the `otype` feature.\noslots: iterable\n    The data of the `oslots` feature.\nrank: tuple\n    The data of the `rank` pre-computation step.\n\nReturns\n-------\ntuple\n    *   first: tuple of tuple\n        The `n`-th member is the tuple of nodes that start at slot `n`,\n        ordered in *reversed* canonical order (`cfabric.nodes`);\n    *   last: tuple of tuple\n        The `n`-th member is the tuple of nodes that end at slot `n`,\n        ordered in canonical order;\n\nNotes\n-----\n!!! hint \"why  reversed canonical order?\"\n    Just for symmetry.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "info",
                  "type": "InfoFunc",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "error",
                  "type": "ErrorFunc",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "otype",
                  "type": "OtypeData",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "oslots",
                  "type": "OslotsData",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "rank",
                  "type": "RankData",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "BoundaryData"
              },
              "decorators": []
            },
            "characters": {
              "name": "characters",
              "kind": "function",
              "signature": "(info: InfoFunc, error: ErrorFunc, otext: OtextData, tFormats: dict[(str, tuple[(str, ...)])], tFeats: tuple[(str, dict[(int, Any)] | None)] = ())",
              "docstring": {
                "summary": "Computes character data.",
                "description": "Computes character data.\n\nFor each text format, a frequency list of the characters in that format\nis made.\n\nParameters\n----------\ninfo: function\n    Method to write informational messages to the console.\nerror: function\n    Method to write error messages to the console.\notext: iterable\n    The data of the `otext` feature.\ntFormats: dict\n    Dictionary keyed by text format and valued by the tuple of features\n    used in that format.\ntFeats: iterable\n    Each `tFeat` is the name and the data of a text feature.\n    i.e. a feature used in text formats.\n\nReturns\n-------\ndict\n    Keyed by format valued by a frequency dict, which is\n    itself keyed by single characters and valued by the frequency\n    of that character in the whole corpus when rendered with that format.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "info",
                  "type": "InfoFunc",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "error",
                  "type": "ErrorFunc",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "otext",
                  "type": "OtextData",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "tFormats",
                  "type": "dict[(str, tuple[(str, ...)])]",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "tFeats",
                  "type": "tuple[(str, dict[(int, Any)] | None)]",
                  "default": "()",
                  "kind": "variadic positional"
                }
              ],
              "returns": {
                "type": "CharactersResult"
              },
              "decorators": []
            },
            "levDown": {
              "name": "levDown",
              "kind": "function",
              "signature": "(info: InfoFunc, error: ErrorFunc, otype: OtypeData, levUp: LevUpData, rank: RankData)",
              "docstring": {
                "summary": "Computes level-down data.",
                "description": "Computes level-down data.\n\nLevel-down data is used by the API function `cfabric.locality.Locality.d`.\n\nThis function computes the embedded nodes of a node by looking them up from\nthe level-down data.\n\nParameters\n----------\ninfo: function\n    Method to write informational messages to the console.\nerror: function\n    Method to write error messages to the console.\notype: iterable\n    The data of the `otype` feature.\nlevUp: iterable\n    The data of the `levUp` pre-computation step.\nrank: tuple\n    The data of the `rank` pre-computation step.\n\nReturns\n-------\ntuple\n    The `n`-th member is an tuple of the embedded nodes of `n + maxSlot`.\n    Those tuples are sorted in canonical order (`cfabric.nodes`).\n\n!!! hint \"Memory efficiency\"\n    Slot nodes do not have embedded nodes, so they do not have to occupy\n    space in this tuple. Hence the first member are the embedded nodes\n    of node `maxSlot + 1`.\n\n!!! caution \"Use with care\"\n    It is not advisable to use this data directly by `C.levDown.data`,\n    it is far better to use the `cfabric.locality.Locality.d` function.\n\n    Only when every bit of performance waste has to be squeezed out,\n    this raw data might be a deal.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "info",
                  "type": "InfoFunc",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "error",
                  "type": "ErrorFunc",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "otype",
                  "type": "OtypeData",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "levUp",
                  "type": "LevUpData",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "rank",
                  "type": "RankData",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "LevDownData"
              },
              "decorators": []
            },
            "levUp": {
              "name": "levUp",
              "kind": "function",
              "signature": "(info: InfoFunc, error: ErrorFunc, otype: OtypeData, oslots: OslotsData, rank: RankData)",
              "docstring": {
                "summary": "Computes level-up data.",
                "description": "Computes level-up data.\n\nLevel-up data is used by the API function `cfabric.locality.Locality.u`.\n\nThis function computes the embedders of a node by looking them up from\nthe level-up data.\n\nParameters\n----------\ninfo: function\n    Method to write informational messages to the console.\nerror: function\n    Method to write error messages to the console.\notype: iterable\n    The data of the `otype` feature.\noslots: iterable\n    The data of the `oslots` feature.\nrank: tuple\n    The data of the `rank` pre-computation step.\n\nReturns\n-------\ntuple\n    The `n`-th member is a tuple of the embedder nodes of `n`.\n    Those tuples are sorted in canonical order (`cfabric.nodes`).\n\nNotes\n-----\n!!! hint \"Memory efficiency\"\n    Many nodes have the same tuple of embedders.\n    Those embedder tuples will be reused for those nodes.\n\nWarnings\n--------\nIt is not advisable to use this data directly by `C.levUp.data`,\nit is far better to use the `cfabric.locality.Locality.u` function.\n\nOnly when every bit of performance waste has to be squeezed out,\nthis raw data might be a deal.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "info",
                  "type": "InfoFunc",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "error",
                  "type": "ErrorFunc",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "otype",
                  "type": "OtypeData",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "oslots",
                  "type": "OslotsData",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "rank",
                  "type": "RankData",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "LevUpData"
              },
              "decorators": []
            },
            "levels": {
              "name": "levels",
              "kind": "function",
              "signature": "(info: InfoFunc, error: ErrorFunc, otype: OtypeData, oslots: OslotsData, otext: OtextData)",
              "docstring": {
                "summary": "Computes level data.",
                "description": "Computes level data.\n\nFor each node type, compute the average number of slots occupied by its nodes,\nand order the node types on that.\n\nParameters\n----------\ninfo: function\n    Method to write informational messages to the console.\nerror: function\n    Method to write error messages to the console.\notype: iterable\n    The data of the `otype` feature.\noslots: iterable\n    The data of the `oslots` feature.\notext: iterable\n    The data of the `otext` feature.\n\nReturns\n-------\ntuple\n    An ordered tuple, each member with the information of a node type:\n\n    *   node type name\n    *   average number of slots contained in the nodes of this type\n    *   first node of this type\n    *   last node of this type\n\nThe order of the tuple is descending by average number of slots per node of that\ntype.\n\nNotes\n-----\n!!! explanation \"Level computation and customization\"\n    All node types have a level, defined by the average amount of slots object of\n    that type usually occupy. The bigger the average object, the lower the levels.\n    Books have the lowest level, words the highest level.\n\n    However, this can be overruled. Suppose you have a node type `phrase` and above\n    it a node type `cluster`, i.e. phrases are contained in clusters, but not vice\n    versa. If all phrases are contained in clusters, and some clusters have more\n    than one phrase, the automatic level ranking of node types works out well in\n    this case. But if clusters only have very small phrases, and the big phrases do\n    not occur in clusters, then the algorithm may assign a lower rank to clusters\n    than to phrases.\n\n    In general, it is too expensive to try to compute the levels in a sophisticated\n    way. In order to remedy cases where the algorithm assigns wrong levels, you can\n    add a `@levels` and / or `@levelsConstraint` key to the `otext`\n    configuration feature.\n    See `cfabric.text`.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "info",
                  "type": "InfoFunc",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "error",
                  "type": "ErrorFunc",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "otype",
                  "type": "OtypeData",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "oslots",
                  "type": "OslotsData",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "otext",
                  "type": "OtextData",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "LevelsData"
              },
              "decorators": []
            },
            "order": {
              "name": "order",
              "kind": "function",
              "signature": "(info: InfoFunc, error: ErrorFunc, otype: OtypeData, oslots: OslotsData, levels: LevelsData)",
              "docstring": {
                "summary": "Computes order data for the canonical ordering.",
                "description": "Computes order data for the canonical ordering.\n\nThe canonical ordering between nodes is defined in terms of the slots that\nnodes contain, and if that is not decisive, the rank of the node type is taken\ninto account, and if that is still not decisive, the node itself is taken into\naccount.\n\nParameters\n----------\ninfo: function\n    Method to write informational messages to the console.\nerror: function\n    Method to write error messages to the console.\notype: iterable\n    The data of the `otype` feature.\noslots: iterable\n    The data of the `oslots` feature.\nlevels: tuple\n    The data of the `levels` pre-computation step.\n\nReturns\n-------\ntuple\n    All nodes, slot and nonslot, in canonical order.\n\nSee Also\n--------\ncfabric.nodes: canonical ordering",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "info",
                  "type": "InfoFunc",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "error",
                  "type": "ErrorFunc",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "otype",
                  "type": "OtypeData",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "oslots",
                  "type": "OslotsData",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "levels",
                  "type": "LevelsData",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "OrderData"
              },
              "decorators": []
            },
            "rank": {
              "name": "rank",
              "kind": "function",
              "signature": "(info: InfoFunc, error: ErrorFunc, otype: OtypeData, order: OrderData)",
              "docstring": {
                "summary": "Computes rank data.",
                "description": "Computes rank data.\n\nThe rank of a node is its place in among the other nodes in the\ncanonical order (see `cfabric.nodes`).\n\nParameters\n----------\ninfo: function\n    Method to write informational messages to the console.\nerror: function\n    Method to write error messages to the console.\notype: iterable\n    The data of the `otype` feature.\norder: tuple\n    The data of the `order` feature.\n\nReturns\n-------\ntuple\n    The ranks of all nodes, slot and nonslot, with respect to the canonical order.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "info",
                  "type": "InfoFunc",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "error",
                  "type": "ErrorFunc",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "otype",
                  "type": "OtypeData",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "order",
                  "type": "OrderData",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "RankData"
              },
              "decorators": []
            },
            "sections": {
              "name": "sections",
              "kind": "function",
              "signature": "(info: InfoFunc, error: ErrorFunc, otype: OtypeData, oslots: OslotsData, otext: OtextData, levUp: LevUpData, levDown: LevDownData, levels: LevelsData, sFeats: dict[(int, Any)] = ())",
              "docstring": {
                "summary": "Computes section data.",
                "description": "Computes section data.\n\nCF datasets may define up to three section levels, roughly corresponding\nwith a volume, a chapter, a paragraph.\n\nIf the corpus has a richer section structure, it is also possible\na different, more flexible and more extensive nest of structural sections.\nSee `structure`.\n\nCF must be able to go from sections at one level to the sections\nat one level lower. It must also be able to map section headings\nto nodes. For this, the section features are needed, since they\ncontain the section headings.\n\nWe also map the sections to sequence numbers and back, at each level, e.g.\nin the Hebrew Bible `Genesis` is mapped to 1, `Exodus` to 2, etc.\nWe also do it for integer values components, and we make sure that the first section\nat each level gets sequence number `1`.\n\nParameters\n----------\ninfo: function\n    Method to write informational messages to the console.\nerror: function\n    Method to write error messages to the console.\notype: iterable\n    The data of the `otype` feature.\noslots: iterable\n    The data of the `oslots` feature.\notext: iterable\n    The data of the `otext` feature.\nlevUp: tuple\n    The data of the `levUp` pre-computation step.\nlevDown: tuple\n    The data of the `levDown` pre-computation step.\nlevels: tuple\n    The data of the `levels` pre-computation step.\nsFeats: iterable\n    Each `sFeat` is the data of a section feature.\n\nReturns\n-------\ndict\n    We have the following items:\n\n    *   `sec1`:\n        Mapping from section-level-1 nodes to mappings from\n        section-level-2 headings to section-level-2 nodes.\n    *   `sec2`:\n        Mapping from section-level-1 nodes to mappings from\n        section-level-2 headings to mappings from\n        section-level-3 headings to section-level-3 nodes.\n    *   `seqFromNode`:\n        Mapping from tuples of section nodes to tuples of sequence numbers.\n        Only if there are precisely 3 section levels, otherwise this is an\n        empty dictionary.\n    *   `nodeFromSeq`:\n        Mapping from tuples of section sequence numbers to tuples of nodes.\n        Only if there are precisely 3 section levels, otherwise this is an\n        empty dictionary.\n\nWarnings\n--------\nNote that the terms `book`, `chapter`, `verse` are not baked into CF.\nIt is the corpus data, especially the `otext` configuration feature that\nspells out the names of the sections.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "info",
                  "type": "InfoFunc",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "error",
                  "type": "ErrorFunc",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "otype",
                  "type": "OtypeData",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "oslots",
                  "type": "OslotsData",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "otext",
                  "type": "OtextData",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "levUp",
                  "type": "LevUpData",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "levDown",
                  "type": "LevDownData",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "levels",
                  "type": "LevelsData",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "sFeats",
                  "type": "dict[(int, Any)]",
                  "default": "()",
                  "kind": "variadic positional"
                }
              ],
              "returns": {
                "type": "SectionsResult"
              },
              "decorators": []
            },
            "sectionsFromApi": {
              "name": "sectionsFromApi",
              "kind": "function",
              "signature": "(api: Api, sectionTypes: list[str], sectionFeats: list[str])",
              "docstring": {
                "summary": "Compute sections data using API methods.",
                "description": "Compute sections data using API methods.\n\nThis is an alternative to `sections()` that works with the high-level API\nrather than raw data structures. Used when loading from .cfm format.\n\nParameters\n----------\napi : Api\n    The CF API object with F, L, Fs attributes\nsectionTypes : list\n    Section type names, e.g. ['book', 'chapter', 'verse']\nsectionFeats : list\n    Section feature names, e.g. ['book', 'chapter', 'verse']\n\nReturns\n-------\ndict\n    Same structure as sections(): {sec1, sec2, seqFromNode, nodeFromSeq}",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "api",
                  "type": "Api",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "sectionTypes",
                  "type": "list[str]",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "sectionFeats",
                  "type": "list[str]",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "SectionsResult | None"
              },
              "decorators": []
            },
            "structure": {
              "name": "structure",
              "kind": "function",
              "signature": "(info: InfoFunc, error: ErrorFunc, otype: OtypeData, oslots: OslotsData, otext: OtextData, rank: RankData, levUp: LevUpData, sFeats: dict[(int, Any)] = ())",
              "docstring": {
                "summary": "Computes structure data.",
                "description": "Computes structure data.\n\nIf the corpus has a rich section structure, it is possible to define\na flexible and extensive nest of structural sections.\n\nIndependent of this,\nCF datasets may also define up to three section levels,\nroughly corresponding with a volume, a chapter, a paragraph.\nSee `sections`.\n\nCF must be able to go from sections at one level to the sections\nat one level lower. It must also be able to map section headings\nto nodes. For this, the section features are needed, since they\ncontain the section headings.\n\nParameters\n----------\ninfo: function\n    Method to write informational messages to the console.\nerror: function\n    Method to write error messages to the console.\notype: iterable\n    The data of the `otype` feature.\noslots: iterable\n    The data of the `oslots` feature.\notext: iterable\n    The data of the `otext` feature.\nrank: tuple\n    The data of the `rank` pre-computation step.\nlevUp: tuple\n    The data of the `levUp` pre-computation step.\nsFeats: iterable\n    Each `sFeat` the data of a section feature.\n\nReturns\n-------\ntuple\n    *   `headingFromNode` (Mapping from nodes to section keys)\n    *   `nodeFromHeading` (Mapping from section keys to nodes)\n    *   `multiple`\n    *   `top`\n    *   `up`\n    *   `down`\n\nNotes\n-----\nA section key of a structural node is obtained by going a level up from\nthat node, retrieving the heading of that structural node, then going up again,\nand so on till a top node is reached. The tuple of headings obtained in this way\nis the  section key.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "info",
                  "type": "InfoFunc",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "error",
                  "type": "ErrorFunc",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "otype",
                  "type": "OtypeData",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "oslots",
                  "type": "OslotsData",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "otext",
                  "type": "OtextData",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "rank",
                  "type": "RankData",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "levUp",
                  "type": "LevUpData",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "sFeats",
                  "type": "dict[(int, Any)]",
                  "default": "()",
                  "kind": "variadic positional"
                }
              ],
              "returns": {
                "type": "StructureResult | tuple[(dict[(Any, Any)], dict[(Any, Any)])]"
              },
              "decorators": []
            }
          },
          "modules": {},
          "aliases": {
            "Any": {
              "name": "Any",
              "target": "typing.Any"
            },
            "Api": {
              "name": "Api",
              "target": "cfabric.core.api.Api"
            },
            "Callable": {
              "name": "Callable",
              "target": "collections.abc.Callable"
            },
            "TYPE_CHECKING": {
              "name": "TYPE_CHECKING",
              "target": "typing.TYPE_CHECKING"
            },
            "annotations": {
              "name": "annotations",
              "target": "__future__.annotations"
            },
            "array": {
              "name": "array",
              "target": "array"
            },
            "collections": {
              "name": "collections",
              "target": "collections"
            },
            "functools": {
              "name": "functools",
              "target": "functools"
            },
            "itemize": {
              "name": "itemize",
              "target": "cfabric.utils.helpers.itemize"
            }
          }
        }
      },
      "aliases": {
        "boundary": {
          "name": "boundary",
          "target": "cfabric.precompute.prepare.boundary"
        },
        "characters": {
          "name": "characters",
          "target": "cfabric.precompute.prepare.characters"
        },
        "levDown": {
          "name": "levDown",
          "target": "cfabric.precompute.prepare.levDown"
        },
        "levUp": {
          "name": "levUp",
          "target": "cfabric.precompute.prepare.levUp"
        },
        "levels": {
          "name": "levels",
          "target": "cfabric.precompute.prepare.levels"
        },
        "order": {
          "name": "order",
          "target": "cfabric.precompute.prepare.order"
        },
        "rank": {
          "name": "rank",
          "target": "cfabric.precompute.prepare.rank"
        },
        "sections": {
          "name": "sections",
          "target": "cfabric.precompute.prepare.sections"
        },
        "sectionsFromApi": {
          "name": "sectionsFromApi",
          "target": "cfabric.precompute.prepare.sectionsFromApi"
        },
        "structure": {
          "name": "structure",
          "target": "cfabric.precompute.prepare.structure"
        }
      }
    },
    "results": {
      "name": "results",
      "kind": "module",
      "path": "",
      "docstring": {
        "summary": "Rich result types for Context Fabric API.",
        "description": "Rich result types for Context Fabric API.\n\nThese classes wrap raw node IDs with contextual information,\nmaking them suitable for serialization and agent interaction via MCP.",
        "parsed": []
      },
      "classes": {
        "CorpusInfo": {
          "name": "CorpusInfo",
          "kind": "class",
          "path": "",
          "docstring": {
            "summary": "Information about a loaded corpus.",
            "description": "Information about a loaded corpus.\n\nAttributes:\n    name: Corpus name (derived from path or user-specified)\n    path: Path to the corpus\n    node_types: List of node types with counts and ranges\n    node_features: List of node feature names\n    edge_features: List of edge feature names\n    slot_type: The slot type name\n    max_slot: Maximum slot node ID\n    max_node: Maximum node ID\n    section_types: Section type hierarchy (e.g., ['book', 'chapter', 'verse'])",
            "parsed": []
          },
          "bases": [],
          "methods": {
            "__init__": {
              "name": "__init__",
              "kind": "function",
              "signature": "(self, name: str, path: str, node_types: list[dict[(str, Any)]] = {'arguments': [], 'cls': 'ExprCall', 'function': {'cls': 'ExprName', 'member': None, 'name': 'list'}}, node_features: list[str] = {'arguments': [], 'cls': 'ExprCall', 'function': {'cls': 'ExprName', 'member': None, 'name': 'list'}}, edge_features: list[str] = {'arguments': [], 'cls': 'ExprCall', 'function': {'cls': 'ExprName', 'member': None, 'name': 'list'}}, slot_type: str = '', max_slot: int = 0, max_node: int = 0, section_types: list[str] = {'arguments': [], 'cls': 'ExprCall', 'function': {'cls': 'ExprName', 'member': None, 'name': 'list'}})",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "self",
                  "type": "",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "name",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "path",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "node_types",
                  "type": "list[dict[(str, Any)]]",
                  "default": {
                    "arguments": [],
                    "cls": "ExprCall",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "list"
                    }
                  },
                  "kind": "positional or keyword"
                },
                {
                  "name": "node_features",
                  "type": "list[str]",
                  "default": {
                    "arguments": [],
                    "cls": "ExprCall",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "list"
                    }
                  },
                  "kind": "positional or keyword"
                },
                {
                  "name": "edge_features",
                  "type": "list[str]",
                  "default": {
                    "arguments": [],
                    "cls": "ExprCall",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "list"
                    }
                  },
                  "kind": "positional or keyword"
                },
                {
                  "name": "slot_type",
                  "type": "str",
                  "default": "''",
                  "kind": "positional or keyword"
                },
                {
                  "name": "max_slot",
                  "type": "int",
                  "default": "0",
                  "kind": "positional or keyword"
                },
                {
                  "name": "max_node",
                  "type": "int",
                  "default": "0",
                  "kind": "positional or keyword"
                },
                {
                  "name": "section_types",
                  "type": "list[str]",
                  "default": {
                    "arguments": [],
                    "cls": "ExprCall",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "list"
                    }
                  },
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "from_api": {
              "name": "from_api",
              "kind": "function",
              "signature": "(cls, api: Api, name: str, path: str)",
              "docstring": {
                "summary": "Create CorpusInfo from API.",
                "description": "Create CorpusInfo from API.\n\nParameters\n----------\napi: Api\n    The Context Fabric API object\nname: str\n    Corpus name\npath: str\n    Path to the corpus",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "cls",
                  "type": "",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "api",
                  "type": "Api",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "name",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "path",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "CorpusInfo"
              },
              "decorators": [
                {
                  "endlineno": 415,
                  "lineno": 415,
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "classmethod"
                  }
                }
              ]
            },
            "to_dict": {
              "name": "to_dict",
              "kind": "function",
              "signature": "(self)",
              "docstring": {
                "summary": "Convert to JSON-serializable dictionary.",
                "description": "Convert to JSON-serializable dictionary.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "self",
                  "type": "",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "dict[(str, Any)]"
              },
              "decorators": []
            },
            "to_json": {
              "name": "to_json",
              "kind": "function",
              "signature": "(self)",
              "docstring": {
                "summary": "Serialize to JSON string.",
                "description": "Serialize to JSON string.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "self",
                  "type": "",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "str"
              },
              "decorators": []
            }
          },
          "attributes": {
            "edge_features": {
              "name": "edge_features",
              "type": "list[str]",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": {
                "arguments": [
                  {
                    "cls": "ExprKeyword",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "field"
                    },
                    "name": "default_factory",
                    "value": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "list"
                    }
                  }
                ],
                "cls": "ExprCall",
                "function": {
                  "cls": "ExprName",
                  "member": null,
                  "name": "field"
                }
              }
            },
            "max_node": {
              "name": "max_node",
              "type": "int",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": "0"
            },
            "max_slot": {
              "name": "max_slot",
              "type": "int",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": "0"
            },
            "name": {
              "name": "name",
              "type": "str",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": null
            },
            "node_features": {
              "name": "node_features",
              "type": "list[str]",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": {
                "arguments": [
                  {
                    "cls": "ExprKeyword",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "field"
                    },
                    "name": "default_factory",
                    "value": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "list"
                    }
                  }
                ],
                "cls": "ExprCall",
                "function": {
                  "cls": "ExprName",
                  "member": null,
                  "name": "field"
                }
              }
            },
            "node_types": {
              "name": "node_types",
              "type": "list[dict[(str, Any)]]",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": {
                "arguments": [
                  {
                    "cls": "ExprKeyword",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "field"
                    },
                    "name": "default_factory",
                    "value": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "list"
                    }
                  }
                ],
                "cls": "ExprCall",
                "function": {
                  "cls": "ExprName",
                  "member": null,
                  "name": "field"
                }
              }
            },
            "path": {
              "name": "path",
              "type": "str",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": null
            },
            "section_types": {
              "name": "section_types",
              "type": "list[str]",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": {
                "arguments": [
                  {
                    "cls": "ExprKeyword",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "field"
                    },
                    "name": "default_factory",
                    "value": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "list"
                    }
                  }
                ],
                "cls": "ExprCall",
                "function": {
                  "cls": "ExprName",
                  "member": null,
                  "name": "field"
                }
              }
            },
            "slot_type": {
              "name": "slot_type",
              "type": "str",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": "''"
            }
          }
        },
        "FeatureInfo": {
          "name": "FeatureInfo",
          "kind": "class",
          "path": "",
          "docstring": {
            "summary": "Metadata about a feature.",
            "description": "Metadata about a feature.\n\nAttributes:\n    name: Feature name\n    kind: 'node' or 'edge'\n    value_type: 'str', 'int', or '' for edges without values\n    description: Feature description from metadata\n    has_values: For edge features, whether edges have values",
            "parsed": []
          },
          "bases": [],
          "methods": {
            "__init__": {
              "name": "__init__",
              "kind": "function",
              "signature": "(self, name: str, kind: str, value_type: str = '', description: str = '', has_values: bool | None = None)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "self",
                  "type": "",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "name",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "kind",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "value_type",
                  "type": "str",
                  "default": "''",
                  "kind": "positional or keyword"
                },
                {
                  "name": "description",
                  "type": "str",
                  "default": "''",
                  "kind": "positional or keyword"
                },
                {
                  "name": "has_values",
                  "type": "bool | None",
                  "default": "None",
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "from_api": {
              "name": "from_api",
              "kind": "function",
              "signature": "(cls, api: Api, name: str, kind: str)",
              "docstring": {
                "summary": "Create FeatureInfo from API.",
                "description": "Create FeatureInfo from API.\n\nParameters\n----------\napi: Api\n    The Context Fabric API object\nname: str\n    Feature name\nkind: str\n    'node' or 'edge'",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "cls",
                  "type": "",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "api",
                  "type": "Api",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "name",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "kind",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "FeatureInfo | None"
              },
              "decorators": [
                {
                  "endlineno": 335,
                  "lineno": 335,
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "classmethod"
                  }
                }
              ]
            },
            "to_dict": {
              "name": "to_dict",
              "kind": "function",
              "signature": "(self)",
              "docstring": {
                "summary": "Convert to JSON-serializable dictionary.",
                "description": "Convert to JSON-serializable dictionary.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "self",
                  "type": "",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "dict[(str, Any)]"
              },
              "decorators": []
            },
            "to_json": {
              "name": "to_json",
              "kind": "function",
              "signature": "(self)",
              "docstring": {
                "summary": "Serialize to JSON string.",
                "description": "Serialize to JSON string.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "self",
                  "type": "",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "str"
              },
              "decorators": []
            }
          },
          "attributes": {
            "description": {
              "name": "description",
              "type": "str",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": "''"
            },
            "has_values": {
              "name": "has_values",
              "type": "bool | None",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": "None"
            },
            "kind": {
              "name": "kind",
              "type": "str",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": null
            },
            "name": {
              "name": "name",
              "type": "str",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": null
            },
            "value_type": {
              "name": "value_type",
              "type": "str",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": "''"
            }
          }
        },
        "NodeInfo": {
          "name": "NodeInfo",
          "kind": "class",
          "path": "",
          "docstring": {
            "summary": "Rich representation of a single node.",
            "description": "Rich representation of a single node.\n\nAttributes:\n    node: The integer node ID\n    otype: The node type (e.g., 'word', 'verse', 'chapter')\n    text: Text representation of the node\n    section_ref: Human-readable section reference (e.g., 'Genesis 1:1')\n    slots: Tuple of slot node IDs this node spans (for non-slot nodes)\n    features: Dict of feature values for this node (optional, populated on demand)",
            "parsed": []
          },
          "bases": [],
          "methods": {
            "__init__": {
              "name": "__init__",
              "kind": "function",
              "signature": "(self, node: int, otype: str, text: str = '', section_ref: str = '', slots: tuple[(int, ...)] | None = None, features: dict[(str, str | int)] | None = None)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "self",
                  "type": "",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "node",
                  "type": "int",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "otype",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "text",
                  "type": "str",
                  "default": "''",
                  "kind": "positional or keyword"
                },
                {
                  "name": "section_ref",
                  "type": "str",
                  "default": "''",
                  "kind": "positional or keyword"
                },
                {
                  "name": "slots",
                  "type": "tuple[(int, ...)] | None",
                  "default": "None",
                  "kind": "positional or keyword"
                },
                {
                  "name": "features",
                  "type": "dict[(str, str | int)] | None",
                  "default": "None",
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "_format_section_ref": {
              "name": "_format_section_ref",
              "kind": "function",
              "signature": "(section_tuple: tuple, section_types: tuple)",
              "docstring": {
                "summary": "Format section tuple as human-readable reference.",
                "description": "Format section tuple as human-readable reference.\n\nExamples:\n    ('Genesis', 1, 1) -> 'Genesis 1:1'\n    ('Genesis', 1) -> 'Genesis 1'\n    ('Genesis',) -> 'Genesis'",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "section_tuple",
                  "type": "tuple",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "section_types",
                  "type": "tuple",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "str"
              },
              "decorators": [
                {
                  "endlineno": 51,
                  "lineno": 51,
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "staticmethod"
                  }
                }
              ]
            },
            "from_api": {
              "name": "from_api",
              "kind": "function",
              "signature": "(cls, api: Api, node: int, include_text: bool = True, include_section: bool = True, include_slots: bool = False, include_features: list[str] | None = None)",
              "docstring": {
                "summary": "Create NodeInfo from API and node ID.",
                "description": "Create NodeInfo from API and node ID.\n\nParameters\n----------\napi: Api\n    The Context Fabric API object\nnode: int\n    The node ID\ninclude_text: bool\n    Whether to include text representation\ninclude_section: bool\n    Whether to include section reference\ninclude_slots: bool\n    Whether to include slot node IDs\ninclude_features: list[str] | None\n    Feature names to include values for",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "cls",
                  "type": "",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "api",
                  "type": "Api",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "node",
                  "type": "int",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "include_text",
                  "type": "bool",
                  "default": "True",
                  "kind": "positional or keyword"
                },
                {
                  "name": "include_section",
                  "type": "bool",
                  "default": "True",
                  "kind": "positional or keyword"
                },
                {
                  "name": "include_slots",
                  "type": "bool",
                  "default": "False",
                  "kind": "positional or keyword"
                },
                {
                  "name": "include_features",
                  "type": "list[str] | None",
                  "default": "None",
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "NodeInfo"
              },
              "decorators": [
                {
                  "endlineno": 79,
                  "lineno": 79,
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "classmethod"
                  }
                }
              ]
            },
            "to_dict": {
              "name": "to_dict",
              "kind": "function",
              "signature": "(self)",
              "docstring": {
                "summary": "Convert to JSON-serializable dictionary.",
                "description": "Convert to JSON-serializable dictionary.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "self",
                  "type": "",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "dict[(str, Any)]"
              },
              "decorators": []
            },
            "to_json": {
              "name": "to_json",
              "kind": "function",
              "signature": "(self)",
              "docstring": {
                "summary": "Serialize to JSON string.",
                "description": "Serialize to JSON string.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "self",
                  "type": "",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "str"
              },
              "decorators": []
            }
          },
          "attributes": {
            "features": {
              "name": "features",
              "type": "dict[(str, str | int)] | None",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": "None"
            },
            "node": {
              "name": "node",
              "type": "int",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": null
            },
            "otype": {
              "name": "otype",
              "type": "str",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": null
            },
            "section_ref": {
              "name": "section_ref",
              "type": "str",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": "''"
            },
            "slots": {
              "name": "slots",
              "type": "tuple[(int, ...)] | None",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": "None"
            },
            "text": {
              "name": "text",
              "type": "str",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": "''"
            }
          }
        },
        "NodeList": {
          "name": "NodeList",
          "kind": "class",
          "path": "",
          "docstring": {
            "summary": "A list of nodes with rich information.",
            "description": "A list of nodes with rich information.\n\nAttributes:\n    nodes: List of NodeInfo objects\n    total_count: Total number of nodes (may differ from len(nodes) if limited)\n    query: Optional description of how nodes were obtained",
            "parsed": []
          },
          "bases": [],
          "methods": {
            "__init__": {
              "name": "__init__",
              "kind": "function",
              "signature": "(self, nodes: list[NodeInfo] = {'arguments': [], 'cls': 'ExprCall', 'function': {'cls': 'ExprName', 'member': None, 'name': 'list'}}, total_count: int = 0, query: str | None = None)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "self",
                  "type": "",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "nodes",
                  "type": "list[NodeInfo]",
                  "default": {
                    "arguments": [],
                    "cls": "ExprCall",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "list"
                    }
                  },
                  "kind": "positional or keyword"
                },
                {
                  "name": "total_count",
                  "type": "int",
                  "default": "0",
                  "kind": "positional or keyword"
                },
                {
                  "name": "query",
                  "type": "str | None",
                  "default": "None",
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "from_nodes": {
              "name": "from_nodes",
              "kind": "function",
              "signature": "(cls, api: Api, nodes: list[int] | tuple[(int, ...)], limit: int | None = None, query: str | None = None, node_kwargs: Any = {})",
              "docstring": {
                "summary": "Create NodeList from API and node IDs.",
                "description": "Create NodeList from API and node IDs.\n\nParameters\n----------\napi: Api\n    The Context Fabric API object\nnodes: list[int] | tuple[int, ...]\n    The node IDs\nlimit: int | None\n    Maximum number of nodes to include (for pagination)\nquery: str | None\n    Description of how nodes were obtained\n**node_kwargs:\n    Arguments passed to NodeInfo.from_api",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "cls",
                  "type": "",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "api",
                  "type": "Api",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "nodes",
                  "type": "list[int] | tuple[(int, ...)]",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "limit",
                  "type": "int | None",
                  "default": "None",
                  "kind": "positional or keyword"
                },
                {
                  "name": "query",
                  "type": "str | None",
                  "default": "None",
                  "kind": "positional or keyword"
                },
                {
                  "name": "node_kwargs",
                  "type": "Any",
                  "default": "{}",
                  "kind": "variadic keyword"
                }
              ],
              "returns": {
                "type": "NodeList"
              },
              "decorators": [
                {
                  "endlineno": 200,
                  "lineno": 200,
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "classmethod"
                  }
                }
              ]
            },
            "to_dict": {
              "name": "to_dict",
              "kind": "function",
              "signature": "(self)",
              "docstring": {
                "summary": "Convert to JSON-serializable dictionary.",
                "description": "Convert to JSON-serializable dictionary.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "self",
                  "type": "",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "dict[(str, Any)]"
              },
              "decorators": []
            },
            "to_json": {
              "name": "to_json",
              "kind": "function",
              "signature": "(self)",
              "docstring": {
                "summary": "Serialize to JSON string.",
                "description": "Serialize to JSON string.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "self",
                  "type": "",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "str"
              },
              "decorators": []
            }
          },
          "attributes": {
            "nodes": {
              "name": "nodes",
              "type": "list[NodeInfo]",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": {
                "arguments": [
                  {
                    "cls": "ExprKeyword",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "field"
                    },
                    "name": "default_factory",
                    "value": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "list"
                    }
                  }
                ],
                "cls": "ExprCall",
                "function": {
                  "cls": "ExprName",
                  "member": null,
                  "name": "field"
                }
              }
            },
            "query": {
              "name": "query",
              "type": "str | None",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": "None"
            },
            "total_count": {
              "name": "total_count",
              "type": "int",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": "0"
            }
          }
        },
        "SearchResult": {
          "name": "SearchResult",
          "kind": "class",
          "path": "",
          "docstring": {
            "summary": "Result of a search query.",
            "description": "Result of a search query.\n\nAttributes:\n    results: List of result tuples, each tuple is a list of NodeInfo\n    total_count: Total number of results\n    template: The search template used\n    plan: Optional search plan description",
            "parsed": []
          },
          "bases": [],
          "methods": {
            "__init__": {
              "name": "__init__",
              "kind": "function",
              "signature": "(self, results: list[list[NodeInfo]] = {'arguments': [], 'cls': 'ExprCall', 'function': {'cls': 'ExprName', 'member': None, 'name': 'list'}}, total_count: int = 0, template: str = '', plan: str | None = None)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "self",
                  "type": "",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "results",
                  "type": "list[list[NodeInfo]]",
                  "default": {
                    "arguments": [],
                    "cls": "ExprCall",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "list"
                    }
                  },
                  "kind": "positional or keyword"
                },
                {
                  "name": "total_count",
                  "type": "int",
                  "default": "0",
                  "kind": "positional or keyword"
                },
                {
                  "name": "template",
                  "type": "str",
                  "default": "''",
                  "kind": "positional or keyword"
                },
                {
                  "name": "plan",
                  "type": "str | None",
                  "default": "None",
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "from_search": {
              "name": "from_search",
              "kind": "function",
              "signature": "(cls, api: Api, results: tuple[(tuple[(int, ...)], ...)] | list[tuple[(int, ...)]], template: str, limit: int | None = None, node_kwargs: Any = {})",
              "docstring": {
                "summary": "Create SearchResult from search results.",
                "description": "Create SearchResult from search results.\n\nParameters\n----------\napi: Api\n    The Context Fabric API object\nresults: tuple[tuple[int, ...], ...]\n    Raw search results (tuples of node IDs)\ntemplate: str\n    The search template used\nlimit: int | None\n    Maximum number of results to include\n**node_kwargs:\n    Arguments passed to NodeInfo.from_api",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "cls",
                  "type": "",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "api",
                  "type": "Api",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "results",
                  "type": "tuple[(tuple[(int, ...)], ...)] | list[tuple[(int, ...)]]",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "template",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "limit",
                  "type": "int | None",
                  "default": "None",
                  "kind": "positional or keyword"
                },
                {
                  "name": "node_kwargs",
                  "type": "Any",
                  "default": "{}",
                  "kind": "variadic keyword"
                }
              ],
              "returns": {
                "type": "SearchResult"
              },
              "decorators": [
                {
                  "endlineno": 262,
                  "lineno": 262,
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "classmethod"
                  }
                }
              ]
            },
            "to_dict": {
              "name": "to_dict",
              "kind": "function",
              "signature": "(self)",
              "docstring": {
                "summary": "Convert to JSON-serializable dictionary.",
                "description": "Convert to JSON-serializable dictionary.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "self",
                  "type": "",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "dict[(str, Any)]"
              },
              "decorators": []
            },
            "to_json": {
              "name": "to_json",
              "kind": "function",
              "signature": "(self)",
              "docstring": {
                "summary": "Serialize to JSON string.",
                "description": "Serialize to JSON string.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "self",
                  "type": "",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "str"
              },
              "decorators": []
            }
          },
          "attributes": {
            "plan": {
              "name": "plan",
              "type": "str | None",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": "None"
            },
            "results": {
              "name": "results",
              "type": "list[list[NodeInfo]]",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": {
                "arguments": [
                  {
                    "cls": "ExprKeyword",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "field"
                    },
                    "name": "default_factory",
                    "value": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "list"
                    }
                  }
                ],
                "cls": "ExprCall",
                "function": {
                  "cls": "ExprName",
                  "member": null,
                  "name": "field"
                }
              }
            },
            "template": {
              "name": "template",
              "type": "str",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": "''"
            },
            "total_count": {
              "name": "total_count",
              "type": "int",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "value": "0"
            }
          }
        }
      },
      "functions": {},
      "modules": {},
      "aliases": {
        "Any": {
          "name": "Any",
          "target": "typing.Any"
        },
        "Api": {
          "name": "Api",
          "target": "cfabric.core.api.Api"
        },
        "TYPE_CHECKING": {
          "name": "TYPE_CHECKING",
          "target": "typing.TYPE_CHECKING"
        },
        "annotations": {
          "name": "annotations",
          "target": "__future__.annotations"
        },
        "asdict": {
          "name": "asdict",
          "target": "dataclasses.asdict"
        },
        "dataclass": {
          "name": "dataclass",
          "target": "dataclasses.dataclass"
        },
        "field": {
          "name": "field",
          "target": "dataclasses.field"
        },
        "json": {
          "name": "json",
          "target": "json"
        }
      }
    },
    "search": {
      "name": "search",
      "kind": "module",
      "path": "",
      "docstring": {
        "summary": "# Guidance for searching",
        "description": "# Guidance for searching\n\n*   User guide to search: `tf.about.searchusage`\n*   Search API: `tf.search.search`.\n*   Implementation of search: `tf.about.searchdesign`",
        "parsed": []
      },
      "classes": {},
      "functions": {},
      "modules": {
        "graph": {
          "name": "graph",
          "kind": "module",
          "path": "",
          "docstring": {
            "summary": "# Graph oriented functions needed for search",
            "description": "# Graph oriented functions needed for search",
            "parsed": []
          },
          "classes": {},
          "functions": {
            "connectedness": {
              "name": "connectedness",
              "kind": "function",
              "signature": "(searchExe: SearchExe)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "searchExe",
                  "type": "SearchExe",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "displayEdge": {
              "name": "displayEdge",
              "kind": "function",
              "signature": "(searchExe: SearchExe, e: int, dir: int, nodesSeen: set[int])",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "searchExe",
                  "type": "SearchExe",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "e",
                  "type": "int",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "dir",
                  "type": "int",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "nodesSeen",
                  "type": "set[int]",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "set[int]"
              },
              "decorators": []
            },
            "displayNode": {
              "name": "displayNode",
              "kind": "function",
              "signature": "(searchExe: SearchExe, q: int, pos2: bool = False)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "searchExe",
                  "type": "SearchExe",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "q",
                  "type": "int",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "pos2",
                  "type": "bool",
                  "default": "False",
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "displayPlan": {
              "name": "displayPlan",
              "kind": "function",
              "signature": "(searchExe: SearchExe, details: bool = False)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "searchExe",
                  "type": "SearchExe",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "details",
                  "type": "bool",
                  "default": "False",
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "multiEdges": {
              "name": "multiEdges",
              "kind": "function",
              "signature": "(searchExe: SearchExe)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "searchExe",
                  "type": "SearchExe",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            }
          },
          "modules": {},
          "aliases": {
            "SearchExe": {
              "name": "SearchExe",
              "target": "cfabric.search.searchexe.SearchExe"
            },
            "TYPE_CHECKING": {
              "name": "TYPE_CHECKING",
              "target": "typing.TYPE_CHECKING"
            },
            "annotations": {
              "name": "annotations",
              "target": "__future__.annotations"
            },
            "chain": {
              "name": "chain",
              "target": "itertools.chain"
            },
            "logging": {
              "name": "logging",
              "target": "logging"
            }
          }
        },
        "relations": {
          "name": "relations",
          "kind": "module",
          "path": "",
          "docstring": {
            "summary": "# Search by relational patterns between nodes",
            "description": "# Search by relational patterns between nodes",
            "parsed": []
          },
          "classes": {},
          "functions": {
            "_l_em": {
              "name": "_l_em",
              "kind": "function",
              "signature": "(n: int)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "n",
                  "type": "int",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "tuple[()]"
              },
              "decorators": []
            },
            "_l_eq": {
              "name": "_l_eq",
              "kind": "function",
              "signature": "(n: int)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "n",
                  "type": "int",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "tuple[int]"
              },
              "decorators": []
            },
            "_l_gt": {
              "name": "_l_gt",
              "kind": "function",
              "signature": "(n: int, m: int)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "n",
                  "type": "int",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "m",
                  "type": "int",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "bool"
              },
              "decorators": []
            },
            "_l_lt": {
              "name": "_l_lt",
              "kind": "function",
              "signature": "(n: int, m: int)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "n",
                  "type": "int",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "m",
                  "type": "int",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "bool"
              },
              "decorators": []
            },
            "_l_rankgt": {
              "name": "_l_rankgt",
              "kind": "function",
              "signature": "(Crank: [int])",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "Crank",
                  "type": "[int]",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "Callable[([int, int], bool)]"
              },
              "decorators": []
            },
            "_l_ranklt": {
              "name": "_l_ranklt",
              "kind": "function",
              "signature": "(Crank: [int])",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "Crank",
                  "type": "[int]",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "Callable[([int, int], bool)]"
              },
              "decorators": []
            },
            "_l_uneq": {
              "name": "_l_uneq",
              "kind": "function",
              "signature": "(n: int, m: int)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "n",
                  "type": "int",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "m",
                  "type": "int",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "bool"
              },
              "decorators": []
            },
            "add_F_Relations": {
              "name": "add_F_Relations",
              "kind": "function",
              "signature": "(searchExe: SearchExe, varRels: dict[(str, set[Any])])",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "searchExe",
                  "type": "SearchExe",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "varRels",
                  "type": "dict[(str, set[Any])]",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "add_K_Relations": {
              "name": "add_K_Relations",
              "kind": "function",
              "signature": "(searchExe: SearchExe, varRels: dict[(str, set[int])])",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "searchExe",
                  "type": "SearchExe",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "varRels",
                  "type": "dict[(str, set[int])]",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "add_V_Relations": {
              "name": "add_V_Relations",
              "kind": "function",
              "signature": "(searchExe: SearchExe, varRels: dict[(str, set[Any])])",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "searchExe",
                  "type": "SearchExe",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "varRels",
                  "type": "dict[(str, set[Any])]",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "basicRelations": {
              "name": "basicRelations",
              "kind": "function",
              "signature": "(searchExe: SearchExe, api: Api)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "searchExe",
                  "type": "SearchExe",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "api",
                  "type": "Api",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            }
          },
          "modules": {},
          "aliases": {
            "Any": {
              "name": "Any",
              "target": "typing.Any"
            },
            "Api": {
              "name": "Api",
              "target": "cfabric.core.api.Api"
            },
            "Callable": {
              "name": "Callable",
              "target": "typing.Callable"
            },
            "DEEP": {
              "name": "DEEP",
              "target": "cfabric.utils.logging.DEEP"
            },
            "Iterator": {
              "name": "Iterator",
              "target": "typing.Iterator"
            },
            "OMAP": {
              "name": "OMAP",
              "target": "cfabric.core.config.OMAP"
            },
            "OSLOTS": {
              "name": "OSLOTS",
              "target": "cfabric.core.config.OSLOTS"
            },
            "OTYPE": {
              "name": "OTYPE",
              "target": "cfabric.core.config.OTYPE"
            },
            "SearchExe": {
              "name": "SearchExe",
              "target": "cfabric.search.searchexe.SearchExe"
            },
            "TYPE_CHECKING": {
              "name": "TYPE_CHECKING",
              "target": "typing.TYPE_CHECKING"
            },
            "annotations": {
              "name": "annotations",
              "target": "__future__.annotations"
            },
            "array": {
              "name": "array",
              "target": "array"
            },
            "chain": {
              "name": "chain",
              "target": "itertools.chain"
            },
            "collections": {
              "name": "collections",
              "target": "collections"
            },
            "makeIndex": {
              "name": "makeIndex",
              "target": "cfabric.utils.helpers.makeIndex"
            },
            "re": {
              "name": "re",
              "target": "re"
            },
            "reTp": {
              "name": "reTp",
              "target": "cfabric.search.syntax.reTp"
            },
            "safe_rank_key": {
              "name": "safe_rank_key",
              "target": "cfabric.utils.helpers.safe_rank_key"
            },
            "types": {
              "name": "types",
              "target": "types"
            }
          }
        },
        "search": {
          "name": "search",
          "kind": "module",
          "path": "",
          "docstring": {
            "summary": "# Search (top-level)",
            "description": "# Search (top-level)",
            "parsed": []
          },
          "classes": {
            "Search": {
              "name": "Search",
              "kind": "class",
              "path": "",
              "docstring": {
                "summary": "High-level search interface for querying corpus data with structural templates.",
                "description": "High-level search interface for querying corpus data with structural templates.\n\nThe Search class provides the `S` API object for finding patterns in annotated\ntext corpora. It uses a template language that allows you to specify:\n\n- Node types (atoms) to match, e.g., `word`, `phrase`, `sentence`\n- Feature constraints on nodes, e.g., `word pos=verb lemma=run`\n- Structural relations between nodes via indentation and operators\n- Quantifiers for optional or alternative patterns\n\nAttributes\n----------\napi : Api\n    The corpus API providing access to features and navigation.\nexe : SearchExe | None\n    The current search execution context after a search or study call.\nperfParams : dict[str, int | float]\n    Performance tuning parameters for search optimization.\n\nExamples\n--------\nBasic usage with the corpus API:\n\n>>> CF = cfabric.Fabric(locations=corpus_path)\n>>> api = CF.loadAll()\n>>> S = api.S  # The Search object\n\nSimple search for all verbs:\n\n>>> results = S.search('''\n... word pos=verb\n... ''')\n\nSearch with structural nesting (phrase containing a verb):\n\n>>> results = S.search('''\n... phrase\n...   word pos=verb\n... ''')\n\nSee Also\n--------\nsearch : Execute a search and return results\nstudy : Analyze a search template and prepare for execution\nfetch : Retrieve results after study\nshowPlan : Display the search execution plan\n\nNotes\n-----\nFor detailed template syntax, see the search usage documentation.\nThe search engine uses edge spinning optimization to efficiently\nnarrow down the search space before retrieving results.",
                "parsed": []
              },
              "bases": [],
              "methods": {
                "__init__": {
                  "name": "__init__",
                  "kind": "function",
                  "signature": "(self, api: Api, silent: str = {'cls': 'ExprName', 'member': None, 'name': 'SILENT_D'})",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "api",
                      "type": "Api",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "silent",
                      "type": "str",
                      "default": {
                        "cls": "ExprName",
                        "member": null,
                        "name": "SILENT_D"
                      },
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "count": {
                  "name": "count",
                  "kind": "function",
                  "signature": "(self, progress: int | None = None, limit: int | None = None)",
                  "docstring": {
                    "summary": "Counts the results, with progress messages, optionally up to a limit.",
                    "description": "Counts the results, with progress messages, optionally up to a limit.\n\nMust be called after a previous `tf.search.search.Search.search()` or\n`tf.search.search.Search.study()`.\n\nParameters\n----------\nprogress: integer, optional, default `100`\n    Every once for every `progress` results a progress message is shown\n    when fetching results.\n\nlimit: integer, optional None\n    If `limit` is a positive number, it will fetch only that many results.\n    If it is negative, 0, None, or absent, it will fetch arbitrary many results.\n\n    !!! caution \"there is an upper *fail limit* for safety reasons.\n        The limit is a factor times the max node in your corpus.\n        See `tf.parameters.SEARCH_FAIL_FACTOR`.\n        If this *fail limit* is exceeded in cases where no positive `limit`\n        has been passed, you get a warning message.\n\n!!! note \"why needed\"\n    You typically need this in cases where result fetching turns out to\n    be (very) slow.\n\n!!! caution \"generator versus list\"\n    `len(S.results())` does not work in general, because `S.results()` is\n    usually a generator that delivers its results as they come.\n\nReturns\n-------\nNone\n    The point of this function is to show the counting of the results\n    on the screen in a series of timed messages.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "progress",
                      "type": "int | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "limit",
                      "type": "int | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "fetch": {
                  "name": "fetch",
                  "kind": "function",
                  "signature": "(self, limit: int | None = None, _msgCache: bool | list[Any] = False)",
                  "docstring": {
                    "summary": "Retrieves query results, up to a limit.",
                    "description": "Retrieves query results, up to a limit.\n\nMust be called after a previous `tf.search.search.Search.search()` or\n`tf.search.search.Search.study()`.\n\nParameters\n----------\n\nlimit: integer, optional None\n    If `limit` is a positive number, it will fetch only that many results.\n    If it is negative, 0, None, or absent, it will fetch arbitrary many results.\n\n    !!! caution \"there is an upper *fail limit* for safety reasons.\n        The limit is a factor times the max node in your corpus.\n        See `tf.parameters.SEARCH_FAIL_FACTOR`.\n        If this *fail limit* is exceeded in cases where no positive `limit`\n        has been passed, you get a warning message.\n\n\nReturns\n-------\ngenerator | tuple\n    Each result is a tuple of nodes, where each node corresponds to an\n    *atom*-line in your search template (see `tf.about.searchusage`).\n\n    If `limit` is not `None`, a *generator* is returned,\n    which yields the results one by one.\n\n    Otherwise, the results will be fetched up till `limit`\n    and delivered as a tuple.\n\nNotes\n-----\n!!! example \"Iterating over the `fetch()` generator\"\n    You typically fetch results by saying:\n\n        i = 0\n        for tup in S.results():\n            do_something(tup[0])\n            do_something_else(tup[1])\n\n    Alternatively, you can set the `limit` parameter, to ask for just so many\n    results. They will be fetched, and when they are all collected,\n    returned as a tuple.\n\n!!! example \"Fetching a limited amount of results\"\n    This\n\n        S.fetch(limit=10)\n\n    gives you the first 10 results without further ado.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "limit",
                      "type": "int | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "_msgCache",
                      "type": "bool | list[Any]",
                      "default": "False",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "tuple[(tuple[(int, ...)], ...)] | set[int] | set[tuple[(int, ...)]] | Generator[(tuple[(int, ...)], None, None)] | tuple[(Any, str)] | None"
                  },
                  "decorators": []
                },
                "glean": {
                  "name": "glean",
                  "kind": "function",
                  "signature": "(self, tup: tuple[(int, ...)])",
                  "docstring": {
                    "summary": "Renders a single result into something human readable.",
                    "description": "Renders a single result into something human readable.\n\nA search result is just a tuple of nodes that correspond to your template, as\nindicated by `showPlan()`. Nodes give you access to all information that the\ncorpus has about it.\n\nThis function is meant to just give you a quick first impression.\n\nParameters\n----------\ntup: tuple of integer\n    The tuple of nodes in question.\n\nReturns\n-------\nstring\n    The result indicates where the tuple occurs in terms of sections,\n    and what text is associated with the tuple.\n\nNotes\n-----\n!!! example \"Inspecting results\"\n    This\n\n        for result in S.fetch(limit=10):\n            print(S.glean(result))\n\n    is a handy way to get an impression of the first bunch of results.\n\n!!! hint \"Universal\"\n    This function works on all tuples of nodes, whether they have been\n    obtained by search or not.\n\n!!! hint \"More ways of showing results\"\n    The advanced API offers much better ways of showing results.\n    See `tf.advanced.display.show` and `tf.advanced.display.table`.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "tup",
                      "type": "tuple[(int, ...)]",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "str"
                  },
                  "decorators": []
                },
                "relationsLegend": {
                  "name": "relationsLegend",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "Dynamic info about the basic relations that can be used in templates.",
                    "description": "Dynamic info about the basic relations that can be used in templates.\n\nIt includes the edge features that are available in your dataset.\n\nReturns\n-------\nNone\n    The legend will be shown in the output.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "search": {
                  "name": "search",
                  "kind": "function",
                  "signature": "(self, searchTemplate: str, limit: int | None = None, sets: dict[(str, set[int])] | None = None, shallow: bool | int = False, silent: str = {'cls': 'ExprName', 'member': None, 'name': 'SILENT_D'}, here: bool = True, _msgCache: bool | list[Any] = False)",
                  "docstring": {
                    "summary": "Searches for combinations of nodes that together match a search template.",
                    "description": "Searches for combinations of nodes that together match a search template.\n\nIf you can, you should use `tf.advanced.search.search` instead.\n\nParameters\n----------\nsearchTemplate: string\n    A string that conforms to the rules described in `tf.about.searchusage`.\n\nshallow: set | tuple\n    If `True` or `1`, the result is a set of things that match the\n    top-level element of the `query`.\n\n    If `2` or a bigger number `n`, return the set of truncated result tuples:\n    only the first `n` members of each tuple is retained.\n\n    If `False` or `0`, a sorted list of all result tuples will be returned.\n\nsets: dict\n    If not `None`, it should be a dictionary of sets, keyed by a names.\n\nlimit: integer, optional None\n    If `limit` is a positive number, it will fetch only that many results.\n    If it is negative, 0, None, or absent, it will fetch arbitrary many results.\n\n    !!! caution \"there is an upper *fail limit* for safety reasons.\n        The limit is a factor times the max node in your corpus.\n        See `tf.parameters.SEARCH_FAIL_FACTOR`.\n        If this *fail limit* is exceeded in cases where no positive `limit`\n        has been passed, you get a warning message.\n\nReturns\n-------\ngenerator | tuple\n    Each result is a tuple of nodes, where each node corresponds to an\n    *atom*-line in your search template (see `tf.about.searchusage`).\n\n    If `limit` is not `None`, a *generator* is returned,\n    which yields the results one by one.\n\n    Otherwise, the results will be fetched up till `limit`\n    and delivered as a tuple.\n\nNotes\n-----\n!!! hint \"More info on the search plan\"\n    Searching is complex. The search template must be parsed, interpreted,\n    and translated into a search plan. See `tf.search.search.Search.study`.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "searchTemplate",
                      "type": "str",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "limit",
                      "type": "int | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "sets",
                      "type": "dict[(str, set[int])] | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "shallow",
                      "type": "bool | int",
                      "default": "False",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "silent",
                      "type": "str",
                      "default": {
                        "cls": "ExprName",
                        "member": null,
                        "name": "SILENT_D"
                      },
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "here",
                      "type": "bool",
                      "default": "True",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "_msgCache",
                      "type": "bool | list[Any]",
                      "default": "False",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "tuple[(tuple[(int, ...)], ...)] | set[int] | set[tuple[(int, ...)]] | Generator[(tuple[(int, ...)], None, None)] | tuple[(Any, bool, list[str])] | tuple[(Any, bool, list[str], SearchExe)]"
                  },
                  "decorators": []
                },
                "showPlan": {
                  "name": "showPlan",
                  "kind": "function",
                  "signature": "(self, details: bool = False)",
                  "docstring": {
                    "summary": "Show the result of the latest study of a template.",
                    "description": "Show the result of the latest study of a template.\n\nSearch results are tuples of nodes and the plan shows which part of the tuple\ncorresponds to which part of the search template.\n\nOnly meaningful after a previous `tf.search.search.Search.study`.\n\nParameters\n----------\ndetails: boolean, optional False\n    If `True`, more information will be provided:\n    an overview of the search space and a description of how the results\n    will be retrieved.\n\n!!! note \"after S.study()\"\n    This function is only meaningful after a call to `S.study()`.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "details",
                      "type": "bool",
                      "default": "False",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "study": {
                  "name": "study",
                  "kind": "function",
                  "signature": "(self, searchTemplate: str, strategy: str | None = None, sets: dict[(str, set[int])] | None = None, shallow: bool | int = False, here: bool = True, silent: str = {'cls': 'ExprName', 'member': None, 'name': 'SILENT_D'})",
                  "docstring": {
                    "summary": "Studies a template to prepare for searching with it.",
                    "description": "Studies a template to prepare for searching with it.\n\nThe search space will be narrowed down and a plan for retrieving the results\nwill be set up.\n\nIf the search template query has quantifiers, the associated search templates\nwill be constructed and executed. These searches will be reported clearly.\n\nThe resulting plan can be viewed by `tf.search.search.Search.showPlan`.\n\nParameters\n----------\nsearchTemplate: string\n    A string that conforms to the rules described in `tf.about.searchusage`.\n\nstrategy: string\n    In order to tame the performance of search, the strategy by which results\n    are fetched matters a lot.  The search strategy is an implementation detail,\n    but we bring it to the surface nevertheless.\n\n    To see the names of the available strategies, just call\n    `S.study('', strategy='x')` and you will get a list of options reported to\n    choose from.\n\n    Feel free to experiment. To see what the strategies do, see the\n    code in `tf.search.stitch`.\n\nshallow: set | tuple\n    If `True` or `1`, the result is a set of things that match the\n    top-level element of the search template.\n\n    If `2` or a bigger number `n`, return the set of truncated result tuples:\n    only the first `n` members of each tuple is retained.\n\n    If `False` or `0`, a sorted list of all result tuples will be returned.\n\nsets: dict\n    If not `None`, it should be a dictionary of sets, keyed by a names.\n    In the search template you can refer to those names to invoke those sets.\n\nsilent: string, optional cfabric.timestamp.SILENT_D\n    See `cfabric.timestamp.Timestamp`\n\nSee Also\n--------\ntf.about.searchusage: Search guide",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "searchTemplate",
                      "type": "str",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "strategy",
                      "type": "str | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "sets",
                      "type": "dict[(str, set[int])] | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "shallow",
                      "type": "bool | int",
                      "default": "False",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "here",
                      "type": "bool",
                      "default": "True",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "silent",
                      "type": "str",
                      "default": {
                        "cls": "ExprName",
                        "member": null,
                        "name": "SILENT_D"
                      },
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "tweakPerformance": {
                  "name": "tweakPerformance",
                  "kind": "function",
                  "signature": "(self, silent: str = {'cls': 'ExprName', 'member': None, 'name': 'SILENT_D'}, kwargs: Any = {})",
                  "docstring": {
                    "summary": "Tweak parameters that influence the search process.",
                    "description": "Tweak parameters that influence the search process.\n\n!!! explanation \"Theory\"\n    Before the search engine retrieves result tuples of nodes,\n    there is a process to narrow down the search space.\n\n    See `tf.about.searchdesign` and remember that we use the term *yarn* for\n    the sets of candidate nodes from which we stitch our results together.\n\n    *Edge spinning* is the process of\n    transferring constraints on one node via edges to constraints on\n    another node. The one node lives in a yarn, i.e. a set of candidate nodes,\n    and the node at the other side of the edge lives in a yarn.\n\n    If the first yarn is small then we might be able to reduce the second yarn\n    by computing the counterparts of the nodes in the small yarn in the second\n    yarn. We can leave out all other nodes from the second yarn.\n    A big reduction!\n\n    The success of edge spinning depends mainly on two factors:\n\n    !!! info \"Size difference\"\n        Edge spinning works best if there is a big difference in size\n        between the candidate\n        sets for the nodes at both sides of an edge.\n\n    !!! info \"Spread\"\n        The spread of a relation is the number of different edges\n        that can start from the same node or end at the same node.\n\n        For example, the spread of the `equality` operator is just 1, but\n        the spread of the `inequality` operator is virtually as big\n        as the relevant yarn.\n\n        If there are constraints on a node in one yarn, and if there is an edge\n        between that yarn and another one, and if the spread is big,\n        not much of the constraint can be transferred to the other yarn.\n\n    !!! example \"Example\"\n        Suppose both yarns are words, the first yarn has been constrained\n        to verbs, and the equality relation holds must hold between the yarns.\n        Then in all results the node from the second yarn is also a verb.\n        So we can constrain the second yarn to verbs too.\n\n        But if the relation is inequality, we cannot impose any additional\n        restriction on nodes in the second yarn. All nodes in the second\n        yarn are unequal to at least one verb.\n\n    !!! info \"Estimating the spread\"\n        We estimate the spreads of edges over and over again, in a series\n        of iterations where we reduce yarns.\n\n        An exhaustive computation would be too expensive, so we take\n        a sample of a limited amount of relation computations.\n\n\nIf you do not pass a parameter, its value will not be changed.\nIf you pass `None` for a parameter, its value will be reset to the default value.\n\nHere are the parameters that you can tweak:\n\nParameters\n----------\n\nyarnRatio: real\n    The `yarnRatio` is the minimal factor between the sizes of\n    the smallest and the biggest set of candidates of the nodes at both ends of\n    the edge. And that divided by the spread of the relation as estimated\n    by a sample.\n\n    !!! example \"Example\"\n        Suppose we set the `yarnRatio` to 1.5.\n        Then, if we have yarns of 100,000 and 10,000 members,\n        with a relation between them with spread 5,\n        then 100,000 / 10,000 / 5 = 2.\n        This is higher than the `yarnRatio` of 1.5,\n        so the search engine decides that edge spinning is worth it.\n\n        The reasoning is that the 10,000 nodes in the smallest yarn are expected\n        to reach only 10,000 * 5 nodes in the other yarn by the relation,\n        and so we can achieve a significant reduction.\n\n    If you have a very slow query, and you think that a bit more edge spinning\n    helps, decrease the `yarnRatio` towards 0.\n\n    If you find that a lot of queries spend too much time in edge spinning,\n    increase the `yarnRatio`.\n\ntryLimitFrom: integer\n    In order to determine the spreads of the relations, CF takes\n    random samples and extrapolates the results. We grab some nodes\n    from the set at the *from* side of an edge, and some nodes at the\n    *to* side of the same edge, Then we compute in how many cases the relation\n    holds. That is a measure for the spread.\n\n    The parameters `tryLimitFrom` and `tryLimitTo` dictate how big these\n    samples are. The bigger, the better the estimation of the spread.\n    But also the more work it is.\n\n    If you find that your queries take consistently a tad too much time,\n    consider lowering these parameters to 10.\n\n    If you find that the times your queries take varies a lot,\n    increase these values to 10000.\ntryLimitTo: integer\n    See `tryLimitFrom`",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "silent",
                      "type": "str",
                      "default": {
                        "cls": "ExprName",
                        "member": null,
                        "name": "SILENT_D"
                      },
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "kwargs",
                      "type": "Any",
                      "default": "{}",
                      "kind": "variadic keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                }
              },
              "attributes": {
                "api": {
                  "name": "api",
                  "type": "Api",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "api"
                  }
                },
                "exe": {
                  "name": "exe",
                  "type": "SearchExe | None",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": "None"
                },
                "perfParams": {
                  "name": "perfParams",
                  "type": "dict[(str, int | float)]",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprDict",
                    "keys": [],
                    "values": []
                  }
                },
                "silent": {
                  "name": "silent",
                  "type": "str",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "silent"
                  }
                }
              }
            }
          },
          "functions": {},
          "modules": {},
          "aliases": {
            "AUTO": {
              "name": "AUTO",
              "target": "cfabric.utils.logging.AUTO"
            },
            "Any": {
              "name": "Any",
              "target": "typing.Any"
            },
            "Api": {
              "name": "Api",
              "target": "cfabric.core.api.Api"
            },
            "Generator": {
              "name": "Generator",
              "target": "typing.Generator"
            },
            "SILENT_D": {
              "name": "SILENT_D",
              "target": "cfabric.utils.logging.SILENT_D"
            },
            "SearchExe": {
              "name": "SearchExe",
              "target": "cfabric.search.searchexe.SearchExe"
            },
            "TYPE_CHECKING": {
              "name": "TYPE_CHECKING",
              "target": "typing.TYPE_CHECKING"
            },
            "annotations": {
              "name": "annotations",
              "target": "__future__.annotations"
            },
            "console": {
              "name": "console",
              "target": "cfabric.utils.helpers.console"
            },
            "logging": {
              "name": "logging",
              "target": "logging"
            },
            "silentConvert": {
              "name": "silentConvert",
              "target": "cfabric.utils.logging.silentConvert"
            },
            "wrapMessages": {
              "name": "wrapMessages",
              "target": "cfabric.utils.helpers.wrapMessages"
            }
          }
        },
        "searchexe": {
          "name": "searchexe",
          "kind": "module",
          "path": "",
          "docstring": {
            "summary": "# Search execution management",
            "description": "# Search execution management",
            "parsed": []
          },
          "classes": {
            "SearchExe": {
              "name": "SearchExe",
              "kind": "class",
              "path": "",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "bases": [],
              "methods": {
                "__init__": {
                  "name": "__init__",
                  "kind": "function",
                  "signature": "(self, api: Api, searchTemplate: str, outerTemplate: str | None = None, quKind: str | None = None, offset: int = 0, level: int = 0, sets: dict[(str, set[int])] | None = None, shallow: bool | int = False, silent: str = {'cls': 'ExprName', 'member': None, 'name': 'DEEP'}, showQuantifiers: bool = False, _msgCache: bool | list[Any] = False, setInfo: dict[(str, bool | None)] | None = None)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "api",
                      "type": "Api",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "searchTemplate",
                      "type": "str",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "outerTemplate",
                      "type": "str | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "quKind",
                      "type": "str | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "offset",
                      "type": "int",
                      "default": "0",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "level",
                      "type": "int",
                      "default": "0",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "sets",
                      "type": "dict[(str, set[int])] | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "shallow",
                      "type": "bool | int",
                      "default": "False",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "silent",
                      "type": "str",
                      "default": {
                        "cls": "ExprName",
                        "member": null,
                        "name": "DEEP"
                      },
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "showQuantifiers",
                      "type": "bool",
                      "default": "False",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "_msgCache",
                      "type": "bool | list[Any]",
                      "default": "False",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "setInfo",
                      "type": "dict[(str, bool | None)] | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "_parse": {
                  "name": "_parse",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "_prepare": {
                  "name": "_prepare",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "count": {
                  "name": "count",
                  "kind": "function",
                  "signature": "(self, progress: int | None = None, limit: int | None = None)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "progress",
                      "type": "int | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "limit",
                      "type": "int | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "fetch": {
                  "name": "fetch",
                  "kind": "function",
                  "signature": "(self, limit: int | None = None)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "limit",
                      "type": "int | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "tuple[(tuple[(int, ...)], ...)] | set[int] | set[tuple[(int, ...)]] | Generator[(tuple[(int, ...)], None, None)]"
                  },
                  "decorators": []
                },
                "search": {
                  "name": "search",
                  "kind": "function",
                  "signature": "(self, limit: int | None = None)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "limit",
                      "type": "int | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "tuple[(tuple[(int, ...)], ...)] | set[int] | set[tuple[(int, ...)]] | Generator[(tuple[(int, ...)], None, None)]"
                  },
                  "decorators": []
                },
                "setPerfParams": {
                  "name": "setPerfParams",
                  "kind": "function",
                  "signature": "(cls, params: dict[(str, int | float)])",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "cls",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "params",
                      "type": "dict[(str, int | float)]",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": [
                    {
                      "endlineno": 36,
                      "lineno": 36,
                      "value": {
                        "cls": "ExprName",
                        "member": null,
                        "name": "classmethod"
                      }
                    }
                  ]
                },
                "showOuterTemplate": {
                  "name": "showOuterTemplate",
                  "kind": "function",
                  "signature": "(self, _msgCache: list[Any] | int)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "_msgCache",
                      "type": "list[Any] | int",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "showPlan": {
                  "name": "showPlan",
                  "kind": "function",
                  "signature": "(self, details: bool = False)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "details",
                      "type": "bool",
                      "default": "False",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "study": {
                  "name": "study",
                  "kind": "function",
                  "signature": "(self, strategy: str | None = None)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "strategy",
                      "type": "str | None",
                      "default": "None",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                }
              },
              "attributes": {
                "_msgCache": {
                  "name": "_msgCache",
                  "type": "list[Any] | int",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "body": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "_msgCache"
                    },
                    "cls": "ExprIfExp",
                    "orelse": {
                      "body": {
                        "cls": "ExprUnaryOp",
                        "operator": "-",
                        "value": "1"
                      },
                      "cls": "ExprIfExp",
                      "orelse": "0",
                      "test": {
                        "cls": "ExprName",
                        "member": null,
                        "name": "_msgCache"
                      }
                    },
                    "test": {
                      "cls": "ExprCompare",
                      "comparators": [
                        {
                          "cls": "ExprName",
                          "member": null,
                          "name": "list"
                        }
                      ],
                      "left": {
                        "arguments": [
                          {
                            "cls": "ExprName",
                            "member": null,
                            "name": "_msgCache"
                          }
                        ],
                        "cls": "ExprCall",
                        "function": {
                          "cls": "ExprName",
                          "member": null,
                          "name": "type"
                        }
                      },
                      "operators": [
                        "is"
                      ]
                    }
                  }
                },
                "api": {
                  "name": "api",
                  "type": "Api",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "api"
                  }
                },
                "good": {
                  "name": "good",
                  "type": "bool",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": "True"
                },
                "level": {
                  "name": "level",
                  "type": "int",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "level"
                  }
                },
                "offset": {
                  "name": "offset",
                  "type": "int",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "offset"
                  }
                },
                "outerTemplate": {
                  "name": "outerTemplate",
                  "type": "str | None",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "outerTemplate"
                  }
                },
                "perfDefaults": {
                  "name": "perfDefaults",
                  "type": "dict[(str, int | float)]",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "arguments": [
                      {
                        "cls": "ExprKeyword",
                        "function": {
                          "cls": "ExprName",
                          "member": null,
                          "name": "dict"
                        },
                        "name": "yarnRatio",
                        "value": {
                          "cls": "ExprName",
                          "member": null,
                          "name": "YARN_RATIO"
                        }
                      },
                      {
                        "cls": "ExprKeyword",
                        "function": {
                          "cls": "ExprName",
                          "member": null,
                          "name": "dict"
                        },
                        "name": "tryLimitFrom",
                        "value": {
                          "cls": "ExprName",
                          "member": null,
                          "name": "TRY_LIMIT_FROM"
                        }
                      },
                      {
                        "cls": "ExprKeyword",
                        "function": {
                          "cls": "ExprName",
                          "member": null,
                          "name": "dict"
                        },
                        "name": "tryLimitTo",
                        "value": {
                          "cls": "ExprName",
                          "member": null,
                          "name": "TRY_LIMIT_TO"
                        }
                      }
                    ],
                    "cls": "ExprCall",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "dict"
                    }
                  }
                },
                "perfParams": {
                  "name": "perfParams",
                  "type": "dict[(str, int | float)]",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "arguments": [
                      {
                        "cls": "ExprVarKeyword",
                        "value": {
                          "cls": "ExprName",
                          "member": null,
                          "name": "perfDefaults"
                        }
                      }
                    ],
                    "cls": "ExprCall",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "dict"
                    }
                  }
                },
                "quKind": {
                  "name": "quKind",
                  "type": "str | None",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "quKind"
                  }
                },
                "searchTemplate": {
                  "name": "searchTemplate",
                  "type": "str",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "searchTemplate"
                  }
                },
                "setInfo": {
                  "name": "setInfo",
                  "type": "dict[(str, bool | None)]",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "setInfo"
                  }
                },
                "sets": {
                  "name": "sets",
                  "type": "dict[(str, set[int])] | None",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "sets"
                  }
                },
                "shallow": {
                  "name": "shallow",
                  "type": "int",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "body": "0",
                    "cls": "ExprIfExp",
                    "orelse": {
                      "body": "1",
                      "cls": "ExprIfExp",
                      "orelse": {
                        "cls": "ExprName",
                        "member": null,
                        "name": "shallow"
                      },
                      "test": {
                        "cls": "ExprCompare",
                        "comparators": [
                          "True"
                        ],
                        "left": {
                          "cls": "ExprName",
                          "member": null,
                          "name": "shallow"
                        },
                        "operators": [
                          "is"
                        ]
                      }
                    },
                    "test": {
                      "cls": "ExprUnaryOp",
                      "operator": "not",
                      "value": {
                        "cls": "ExprName",
                        "member": null,
                        "name": "shallow"
                      }
                    }
                  }
                },
                "showQuantifiers": {
                  "name": "showQuantifiers",
                  "type": "bool",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "showQuantifiers"
                  }
                },
                "silent": {
                  "name": "silent",
                  "type": "str",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "silent"
                  }
                }
              }
            }
          },
          "functions": {},
          "modules": {},
          "aliases": {
            "Any": {
              "name": "Any",
              "target": "typing.Any"
            },
            "Api": {
              "name": "Api",
              "target": "cfabric.core.api.Api"
            },
            "Callable": {
              "name": "Callable",
              "target": "typing.Callable"
            },
            "DEEP": {
              "name": "DEEP",
              "target": "cfabric.utils.logging.DEEP"
            },
            "Generator": {
              "name": "Generator",
              "target": "typing.Generator"
            },
            "SEARCH_FAIL_FACTOR": {
              "name": "SEARCH_FAIL_FACTOR",
              "target": "cfabric.core.config.SEARCH_FAIL_FACTOR"
            },
            "TRY_LIMIT_FROM": {
              "name": "TRY_LIMIT_FROM",
              "target": "cfabric.core.config.TRY_LIMIT_FROM"
            },
            "TRY_LIMIT_TO": {
              "name": "TRY_LIMIT_TO",
              "target": "cfabric.core.config.TRY_LIMIT_TO"
            },
            "TYPE_CHECKING": {
              "name": "TYPE_CHECKING",
              "target": "typing.TYPE_CHECKING"
            },
            "YARN_RATIO": {
              "name": "YARN_RATIO",
              "target": "cfabric.core.config.YARN_RATIO"
            },
            "annotations": {
              "name": "annotations",
              "target": "__future__.annotations"
            },
            "basicRelations": {
              "name": "basicRelations",
              "target": "cfabric.search.relations.basicRelations"
            },
            "connectedness": {
              "name": "connectedness",
              "target": "cfabric.search.graph.connectedness"
            },
            "displayPlan": {
              "name": "displayPlan",
              "target": "cfabric.search.graph.displayPlan"
            },
            "logging": {
              "name": "logging",
              "target": "logging"
            },
            "semantics": {
              "name": "semantics",
              "target": "cfabric.search.semantics.semantics"
            },
            "setStrategy": {
              "name": "setStrategy",
              "target": "cfabric.search.stitch.setStrategy"
            },
            "spinAtoms": {
              "name": "spinAtoms",
              "target": "cfabric.search.spin.spinAtoms"
            },
            "spinEdges": {
              "name": "spinEdges",
              "target": "cfabric.search.spin.spinEdges"
            },
            "stitch": {
              "name": "stitch",
              "target": "cfabric.search.stitch.stitch"
            },
            "syntax": {
              "name": "syntax",
              "target": "cfabric.search.syntax.syntax"
            }
          }
        },
        "semantics": {
          "name": "semantics",
          "kind": "module",
          "path": "",
          "docstring": {
            "summary": "Semantic analysis and validation of search templates.",
            "description": "Semantic analysis and validation of search templates.\n\nThis module performs semantic validation on syntactically parsed search templates.\nIt verifies that the template is meaningful and executable against a corpus by:\n\n- Validating object types exist in the corpus\n- Checking that referenced features are loaded\n- Verifying relation operators are valid\n- Building the query graph (qnodes, qedges) for execution\n- Type-checking feature value comparisons\n\nThe semantic analysis runs after syntactic parsing (see `cfabric.search.syntax`)\nand before search execution (see `cfabric.search.searchexe`).\n\nSee Also\n--------\ncfabric.search.syntax : Syntactic parsing of templates\ncfabric.search.search : High-level search API\ncfabric.search.relations : Relation definitions and operators",
            "parsed": []
          },
          "classes": {},
          "functions": {
            "_grammar": {
              "name": "_grammar",
              "kind": "function",
              "signature": "(searchExe: SearchExe)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "searchExe",
                  "type": "SearchExe",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "_validateFeature": {
              "name": "_validateFeature",
              "kind": "function",
              "signature": "(searchExe: SearchExe, q: int, fName: str, features: dict[(str, Any)], missingFeatures: dict[(str, list[int])], wrongValues: dict[(str, dict[(Any, list[int])])], hasValues: dict[(str, dict[(Any, list[int])])] | None = None, asEdge: bool = False)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "searchExe",
                  "type": "SearchExe",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "q",
                  "type": "int",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "fName",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "features",
                  "type": "dict[(str, Any)]",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "missingFeatures",
                  "type": "dict[(str, list[int])]",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "wrongValues",
                  "type": "dict[(str, dict[(Any, list[int])])]",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "hasValues",
                  "type": "dict[(str, dict[(Any, list[int])])] | None",
                  "default": "None",
                  "kind": "positional or keyword"
                },
                {
                  "name": "asEdge",
                  "type": "bool",
                  "default": "False",
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "_validation": {
              "name": "_validation",
              "kind": "function",
              "signature": "(searchExe: SearchExe)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "searchExe",
                  "type": "SearchExe",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "semantics": {
              "name": "semantics",
              "kind": "function",
              "signature": "(searchExe: SearchExe)",
              "docstring": {
                "summary": "Perform semantic analysis on a parsed search template.",
                "description": "Perform semantic analysis on a parsed search template.\n\nThis is the main entry point for semantic validation. It takes a SearchExe\nobject that has already passed syntactic analysis and validates that the\ntemplate can be executed against the corpus.\n\nThe function modifies the SearchExe object in place, setting:\n- `searchExe.qnames`: Mapping of atom names to query node indices\n- `searchExe.qnodes`: List of query nodes (otype, features, src, quantifiers)\n- `searchExe.qedges`: List of validated query edges (from, relation, to)\n- `searchExe.good`: False if semantic errors were found\n- `searchExe.badSemantics`: List of (line_number, error_message) tuples\n\nParameters\n----------\nsearchExe : SearchExe\n    The search execution context. Must have passed syntactic analysis\n    (i.e., `searchExe.good` is True and `searchExe.tokens` is populated).\n\nNotes\n-----\nSemantic validation includes:\n\n1. **Grammar validation**: Checks structural validity of the token sequence,\n   builds the query graph from indentation-based nesting.\n\n2. **Feature validation**: Verifies all referenced features exist in the\n   corpus and have compatible value types.\n\n3. **Relation validation**: Resolves relation operators to internal\n   relation functions, handles k-nearness and feature comparison relations.\n\nErrors are logged and stored in `searchExe.badSemantics`. The caller should\ncheck `searchExe.good` after calling to determine if validation succeeded.\n\nSee Also\n--------\ncfabric.search.syntax.syntax : Syntactic analysis (must be called first)",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "searchExe",
                  "type": "SearchExe",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            }
          },
          "modules": {},
          "aliases": {
            "Any": {
              "name": "Any",
              "target": "typing.Any"
            },
            "SearchExe": {
              "name": "SearchExe",
              "target": "cfabric.search.searchexe.SearchExe"
            },
            "TYPE_CHECKING": {
              "name": "TYPE_CHECKING",
              "target": "typing.TYPE_CHECKING"
            },
            "add_F_Relations": {
              "name": "add_F_Relations",
              "target": "cfabric.search.relations.add_F_Relations"
            },
            "add_K_Relations": {
              "name": "add_K_Relations",
              "target": "cfabric.search.relations.add_K_Relations"
            },
            "add_V_Relations": {
              "name": "add_V_Relations",
              "target": "cfabric.search.relations.add_V_Relations"
            },
            "annotations": {
              "name": "annotations",
              "target": "__future__.annotations"
            },
            "deContext": {
              "name": "deContext",
              "target": "cfabric.search.syntax.deContext"
            },
            "kRe": {
              "name": "kRe",
              "target": "cfabric.search.syntax.kRe"
            },
            "logging": {
              "name": "logging",
              "target": "logging"
            },
            "re": {
              "name": "re",
              "target": "re"
            },
            "reTp": {
              "name": "reTp",
              "target": "cfabric.search.syntax.reTp"
            },
            "types": {
              "name": "types",
              "target": "types"
            }
          }
        },
        "spin": {
          "name": "spin",
          "kind": "module",
          "path": "",
          "docstring": {
            "summary": "# Search pre-processing",
            "description": "# Search pre-processing",
            "parsed": []
          },
          "classes": {},
          "functions": {
            "_can_vectorize_constraint": {
              "name": "_can_vectorize_constraint",
              "kind": "function",
              "signature": "(val: Any)",
              "docstring": {
                "summary": "Check if a constraint can be handled with vectorized operations.",
                "description": "Check if a constraint can be handled with vectorized operations.\n\nVectorizable constraints:\n- None (feature must be missing)\n- True (feature must exist)\n- (True, set) for value in set (ident=True)\n- (False, set) for value not in set (ident=False)\n- (None, True) for any value exists\n\nNon-vectorizable:\n- Functions (custom predicates)\n- Regex patterns",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "val",
                  "type": "Any",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "bool"
              },
              "decorators": []
            },
            "_chooseEdge": {
              "name": "_chooseEdge",
              "kind": "function",
              "signature": "(searchExe: SearchExe)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "searchExe",
                  "type": "SearchExe",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "int"
              },
              "decorators": []
            },
            "_doQuantifier": {
              "name": "_doQuantifier",
              "kind": "function",
              "signature": "(searchExe: SearchExe, yarn: set[int], atom: str, quantifier: tuple[(str, list[str], str, int)])",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "searchExe",
                  "type": "SearchExe",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "yarn",
                  "type": "set[int]",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "atom",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "quantifier",
                  "type": "tuple[(str, list[str], str, int)]",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "set[int]"
              },
              "decorators": []
            },
            "_scalar_filter": {
              "name": "_scalar_filter",
              "kind": "function",
              "signature": "(yarn: set[int], feature: Any, val: Any)",
              "docstring": {
                "summary": "Apply constraint using per-node lookup (fallback for complex constraints).",
                "description": "Apply constraint using per-node lookup (fallback for complex constraints).",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "yarn",
                  "type": "set[int]",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "feature",
                  "type": "Any",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "val",
                  "type": "Any",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "set[int]"
              },
              "decorators": []
            },
            "_spinAtom": {
              "name": "_spinAtom",
              "kind": "function",
              "signature": "(searchExe: SearchExe, q: int)",
              "docstring": {
                "summary": "Build the initial candidate set (yarn) for a search atom.",
                "description": "Build the initial candidate set (yarn) for a search atom.\n\nThis function filters nodes by type and feature constraints. When features\nare backed by mmap storage (StringPool/IntFeatureArray), we use vectorized\nnumpy operations for significant performance improvement.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "searchExe",
                  "type": "SearchExe",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "q",
                  "type": "int",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "_spinEdge": {
              "name": "_spinEdge",
              "kind": "function",
              "signature": "(searchExe: SearchExe, e: int)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "searchExe",
                  "type": "SearchExe",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "e",
                  "type": "int",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "bool"
              },
              "decorators": []
            },
            "_vectorized_filter": {
              "name": "_vectorized_filter",
              "kind": "function",
              "signature": "(yarn: set[int], feature_data: StringPool | IntFeatureArray, val: Any)",
              "docstring": {
                "summary": "Apply constraint using vectorized numpy operations.",
                "description": "Apply constraint using vectorized numpy operations.\n\nReturns filtered yarn as a set.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "yarn",
                  "type": "set[int]",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "feature_data",
                  "type": "StringPool | IntFeatureArray",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "val",
                  "type": "Any",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "set[int]"
              },
              "decorators": []
            },
            "estimateSpreads": {
              "name": "estimateSpreads",
              "kind": "function",
              "signature": "(searchExe: SearchExe, both: bool = False)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "searchExe",
                  "type": "SearchExe",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "both",
                  "type": "bool",
                  "default": "False",
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "spinAtoms": {
              "name": "spinAtoms",
              "kind": "function",
              "signature": "(searchExe: SearchExe)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "searchExe",
                  "type": "SearchExe",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "spinEdges": {
              "name": "spinEdges",
              "kind": "function",
              "signature": "(searchExe: SearchExe)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "searchExe",
                  "type": "SearchExe",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            }
          },
          "modules": {},
          "aliases": {
            "Any": {
              "name": "Any",
              "target": "typing.Any"
            },
            "IntFeatureArray": {
              "name": "IntFeatureArray",
              "target": "cfabric.storage.string_pool.IntFeatureArray"
            },
            "QEND": {
              "name": "QEND",
              "target": "cfabric.search.syntax.QEND"
            },
            "QHAVE": {
              "name": "QHAVE",
              "target": "cfabric.search.syntax.QHAVE"
            },
            "QOR": {
              "name": "QOR",
              "target": "cfabric.search.syntax.QOR"
            },
            "QWHERE": {
              "name": "QWHERE",
              "target": "cfabric.search.syntax.QWHERE"
            },
            "QWITH": {
              "name": "QWITH",
              "target": "cfabric.search.syntax.QWITH"
            },
            "QWITHOUT": {
              "name": "QWITHOUT",
              "target": "cfabric.search.syntax.QWITHOUT"
            },
            "SearchExe": {
              "name": "SearchExe",
              "target": "cfabric.search.searchexe.SearchExe"
            },
            "StringPool": {
              "name": "StringPool",
              "target": "cfabric.storage.string_pool.StringPool"
            },
            "TYPE_CHECKING": {
              "name": "TYPE_CHECKING",
              "target": "typing.TYPE_CHECKING"
            },
            "annotations": {
              "name": "annotations",
              "target": "__future__.annotations"
            },
            "cleanParent": {
              "name": "cleanParent",
              "target": "cfabric.search.syntax.cleanParent"
            },
            "logging": {
              "name": "logging",
              "target": "logging"
            },
            "np": {
              "name": "np",
              "target": "numpy"
            },
            "project": {
              "name": "project",
              "target": "cfabric.utils.helpers.project"
            },
            "randrange": {
              "name": "randrange",
              "target": "random.randrange"
            },
            "reTp": {
              "name": "reTp",
              "target": "cfabric.search.syntax.reTp"
            },
            "signature": {
              "name": "signature",
              "target": "inspect.signature"
            },
            "types": {
              "name": "types",
              "target": "types"
            }
          }
        },
        "stitch": {
          "name": "stitch",
          "kind": "module",
          "path": "",
          "docstring": {
            "summary": "# Search result finding",
            "description": "# Search result finding",
            "parsed": []
          },
          "classes": {},
          "functions": {
            "_big_choice_first": {
              "name": "_big_choice_first",
              "kind": "function",
              "signature": "(searchExe: SearchExe)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "searchExe",
                  "type": "SearchExe",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "_by_yarn_size": {
              "name": "_by_yarn_size",
              "kind": "function",
              "signature": "(searchExe: SearchExe)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "searchExe",
                  "type": "SearchExe",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "_small_choice_first": {
              "name": "_small_choice_first",
              "kind": "function",
              "signature": "(searchExe: SearchExe)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "searchExe",
                  "type": "SearchExe",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "_small_choice_multi": {
              "name": "_small_choice_multi",
              "kind": "function",
              "signature": "(searchExe: SearchExe)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "searchExe",
                  "type": "SearchExe",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "_spread_1_first": {
              "name": "_spread_1_first",
              "kind": "function",
              "signature": "(searchExe: SearchExe)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "searchExe",
                  "type": "SearchExe",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "_stitchPlan": {
              "name": "_stitchPlan",
              "kind": "function",
              "signature": "(searchExe: SearchExe, strategy: str | None = None)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "searchExe",
                  "type": "SearchExe",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "strategy",
                  "type": "str | None",
                  "default": "None",
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "_stitchResults": {
              "name": "_stitchResults",
              "kind": "function",
              "signature": "(searchExe: SearchExe)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "searchExe",
                  "type": "SearchExe",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "setStrategy": {
              "name": "setStrategy",
              "kind": "function",
              "signature": "(searchExe: SearchExe, strategy: str | None, keep: bool = False)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "searchExe",
                  "type": "SearchExe",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "strategy",
                  "type": "str | None",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "keep",
                  "type": "bool",
                  "default": "False",
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "stitch": {
              "name": "stitch",
              "kind": "function",
              "signature": "(searchExe: SearchExe)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "searchExe",
                  "type": "SearchExe",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            }
          },
          "modules": {},
          "aliases": {
            "Any": {
              "name": "Any",
              "target": "typing.Any"
            },
            "Callable": {
              "name": "Callable",
              "target": "typing.Callable"
            },
            "Generator": {
              "name": "Generator",
              "target": "typing.Generator"
            },
            "SearchExe": {
              "name": "SearchExe",
              "target": "cfabric.search.searchexe.SearchExe"
            },
            "TYPE_CHECKING": {
              "name": "TYPE_CHECKING",
              "target": "typing.TYPE_CHECKING"
            },
            "annotations": {
              "name": "annotations",
              "target": "__future__.annotations"
            },
            "chain": {
              "name": "chain",
              "target": "itertools.chain"
            },
            "estimateSpreads": {
              "name": "estimateSpreads",
              "target": "cfabric.search.spin.estimateSpreads"
            },
            "logging": {
              "name": "logging",
              "target": "logging"
            },
            "multiEdges": {
              "name": "multiEdges",
              "target": "cfabric.search.graph.multiEdges"
            },
            "signature": {
              "name": "signature",
              "target": "inspect.signature"
            },
            "types": {
              "name": "types",
              "target": "types"
            }
          }
        },
        "syntax": {
          "name": "syntax",
          "kind": "module",
          "path": "",
          "docstring": {
            "summary": "Syntactic analysis of search templates.",
            "description": "Syntactic analysis of search templates.\n\nThis module provides the lexical and syntactic parsing layer for Context-Fabric\nsearch templates. It tokenizes template strings into structured representations\nthat can be validated and executed by the semantic analysis layer.\n\nThe module handles:\n- Template line parsing (atoms, relations, features, operators)\n- Quantifier detection and nesting (where/have/without/with/or)\n- Feature value parsing (equality, regex, numeric comparisons)\n- Escape sequence processing\n\nSee Also\n--------\ncfabric.search.semantics : Semantic validation of parsed templates\ncfabric.search.search : High-level search API",
            "parsed": []
          },
          "classes": {},
          "functions": {
            "_esc": {
              "name": "_esc",
              "kind": "function",
              "signature": "(x: str)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "x",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "str"
              },
              "decorators": []
            },
            "_genLine": {
              "name": "_genLine",
              "kind": "function",
              "signature": "(kind: str, data: tuple[(Any, ...)])",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "kind",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "data",
                  "type": "tuple[(Any, ...)]",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "str | None"
              },
              "decorators": []
            },
            "_makeLimit": {
              "name": "_makeLimit",
              "kind": "function",
              "signature": "(n: int, isLower: bool)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "n",
                  "type": "int",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "isLower",
                  "type": "bool",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "Callable[([Any], bool)]"
              },
              "decorators": []
            },
            "_tokenize": {
              "name": "_tokenize",
              "kind": "function",
              "signature": "(searchExe: SearchExe)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "searchExe",
                  "type": "SearchExe",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "_unesc": {
              "name": "_unesc",
              "kind": "function",
              "signature": "(x: str, inRe: bool = False)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "x",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "inRe",
                  "type": "bool",
                  "default": "False",
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "str"
              },
              "decorators": []
            },
            "cleanParent": {
              "name": "cleanParent",
              "kind": "function",
              "signature": "(atom: str, parentName: str)",
              "docstring": {
                "summary": "Clean an atom line by replacing empty names with the parent name.",
                "description": "Clean an atom line by replacing empty names with the parent name.\n\nUsed in quantifier processing to ensure atoms have proper names\nwhen they reference the parent context.\n\nParameters\n----------\natom : str\n    The atom line string to process.\nparentName : str\n    The name to use if the atom has no explicit name.\n\nReturns\n-------\nstr | None\n    The regenerated atom line with the name filled in, or None if\n    the line could not be parsed as an atom.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "atom",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "parentName",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "str | None"
              },
              "decorators": []
            },
            "deContext": {
              "name": "deContext",
              "kind": "function",
              "signature": "(quantifier: tuple[(str, list[list[str]], int)], parentName: str)",
              "docstring": {
                "summary": "Transform a quantifier by resolving parent references.",
                "description": "Transform a quantifier by resolving parent references.\n\nQuantifiers (where/have/without/with/or) contain nested search templates\nthat may reference their parent atom using \"..\" (PARENT_REF). This function\nreplaces those references with an actual parent name.\n\nParameters\n----------\nquantifier : tuple[str, list[list[str]], int]\n    A tuple of (quantifier_kind, templates, line_number) where:\n    - quantifier_kind is one of: /where/, /have/, /without/, /with/, /or/\n    - templates is a list of template line lists (one per branch)\n    - line_number is where the quantifier started in the source\nparentName : str\n    The name to assign to the parent. If empty, a unique name will be\n    generated based on names already used in the templates.\n\nReturns\n-------\ntuple[str, list[str], str, int]\n    A tuple of (quantifier_kind, templates, parent_name, line_number)\n    where templates have \"..\" references replaced with the actual parent name.\n\nNotes\n-----\nThe \"..\" reference can appear in:\n- Relation lines: \".. < child\" becomes \"parent < child\"\n- Atom otype position: \"..\" becomes \"parent\"",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "quantifier",
                  "type": "tuple[(str, list[list[str]], int)]",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "parentName",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "tuple[(str, list[str], str, int)]"
              },
              "decorators": []
            },
            "parseFeatureVals": {
              "name": "parseFeatureVals",
              "kind": "function",
              "signature": "(searchExe: SearchExe, featStr: str, features: dict[(str, Any)], i: int, asEdge: bool = False)",
              "docstring": {
                "summary": "Parse a feature value specification and add it to the features dict.",
                "description": "Parse a feature value specification and add it to the features dict.\n\nHandles various feature constraint syntaxes:\n- `feature` or `feature*`: Feature must have any value / be True\n- `feature#`: Feature must be absent (None)\n- `feature=value` or `feature=val1|val2`: Equality with value(s)\n- `feature#value`: Inequality (not equal to value)\n- `feature>n` or `feature<n`: Numeric comparisons\n- `feature~regex`: Regular expression match\n\nParameters\n----------\nsearchExe : SearchExe\n    The search execution context for error reporting.\nfeatStr : str\n    The feature specification string to parse.\nfeatures : dict[str, Any]\n    Dictionary to update with the parsed feature constraint.\ni : int\n    Line number for error reporting.\nasEdge : bool, default False\n    If True, parse as edge feature (expects -feature> or <feature- syntax).\n\nReturns\n-------\nbool\n    True if parsing succeeded, False if there was a syntax error.\n    Errors are appended to `searchExe.badSyntax`.\n\nExamples\n--------\n>>> features = {}\n>>> parseFeatureVals(exe, \"lemma=run\", features, 0)\nTrue\n>>> features\n{'lemma': (True, frozenset({'run'}))}",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "searchExe",
                  "type": "SearchExe",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "featStr",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "features",
                  "type": "dict[(str, Any)]",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "i",
                  "type": "int",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "asEdge",
                  "type": "bool",
                  "default": "False",
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "bool"
              },
              "decorators": []
            },
            "parseLine": {
              "name": "parseLine",
              "kind": "function",
              "signature": "(line: str)",
              "docstring": {
                "summary": "Parse a single line of a search template.",
                "description": "Parse a single line of a search template.\n\nDetermines the type of line (operator, relation, atom, or feature) and\nextracts its components.\n\nParameters\n----------\nline : str\n    A single line from a search template.\n\nReturns\n-------\ntuple[str, tuple[Any, ...]]\n    A tuple of (kind, data) where:\n    - kind is one of: \"op\", \"rel\", \"atom\", \"feat\"\n    - data is a tuple of parsed components depending on kind:\n        - \"op\": (indent, operator)\n        - \"rel\": (indent, from_name, operator, to_name)\n        - \"atom\": (indent, operator, name, otype, features)\n        - \"feat\": (features_string,)\n\nExamples\n--------\n>>> parseLine(\"  word\")\n('atom', ('  ', None, '', 'word', ''))\n>>> parseLine(\"  a:word lemma=run\")\n('atom', ('  ', None, 'a', 'word', 'lemma=run'))\n>>> parseLine(\"a < b\")\n('rel', ('', 'a', '<', 'b'))",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "line",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "tuple[(str, tuple[(Any, ...)])]"
              },
              "decorators": []
            },
            "syntax": {
              "name": "syntax",
              "kind": "function",
              "signature": "(searchExe: SearchExe)",
              "docstring": {
                "summary": "Perform syntactic analysis on a search template.",
                "description": "Perform syntactic analysis on a search template.\n\nThis is the main entry point for parsing search templates. It tokenizes\nthe template string into a list of structured tokens representing atoms,\nrelations, features, and quantifiers.\n\nThe function modifies the SearchExe object in place, setting:\n- `searchExe.tokens`: List of parsed tokens if successful\n- `searchExe.good`: False if syntax errors were found\n- `searchExe.badSyntax`: List of (line_number, error_message) tuples\n\nParameters\n----------\nsearchExe : SearchExe\n    The search execution context containing the template to parse.\n    Must have `searchTemplate` and `offset` attributes set.\n\nNotes\n-----\nSyntax errors are logged and stored in `searchExe.badSyntax`. The caller\nshould check `searchExe.good` after calling to determine if parsing succeeded.\n\nSee Also\n--------\nparseLine : Parse individual template lines\nparseFeatureVals : Parse feature value specifications",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "searchExe",
                  "type": "SearchExe",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            }
          },
          "modules": {},
          "aliases": {
            "Any": {
              "name": "Any",
              "target": "typing.Any"
            },
            "Callable": {
              "name": "Callable",
              "target": "typing.Callable"
            },
            "Pattern": {
              "name": "Pattern",
              "target": "typing.Pattern"
            },
            "SearchExe": {
              "name": "SearchExe",
              "target": "cfabric.search.searchexe.SearchExe"
            },
            "TYPE_CHECKING": {
              "name": "TYPE_CHECKING",
              "target": "typing.TYPE_CHECKING"
            },
            "annotations": {
              "name": "annotations",
              "target": "__future__.annotations"
            },
            "logging": {
              "name": "logging",
              "target": "logging"
            },
            "re": {
              "name": "re",
              "target": "re"
            }
          }
        }
      },
      "aliases": {}
    },
    "storage": {
      "name": "storage",
      "kind": "module",
      "path": "",
      "docstring": {
        "summary": "Low-level storage backends for Context-Fabric.",
        "description": "Low-level storage backends for Context-Fabric.\n\nThis module provides memory-mapped storage implementations for\nefficient feature data access.",
        "parsed": []
      },
      "classes": {},
      "functions": {},
      "modules": {
        "csr": {
          "name": "csr",
          "kind": "module",
          "path": "",
          "docstring": {
            "summary": "Compressed Sparse Row (CSR) utilities for variable-length data.",
            "description": "Compressed Sparse Row (CSR) utilities for variable-length data.",
            "parsed": []
          },
          "classes": {
            "CSRArray": {
              "name": "CSRArray",
              "kind": "class",
              "path": "",
              "docstring": {
                "summary": "CSR representation for variable-length node data.",
                "description": "CSR representation for variable-length node data.\n\nFor data where each node maps to a variable number of values\n(e.g., oslots, edges, levUp/levDown).\n\nAttributes\n----------\nindptr : np.ndarray\n    Index pointers. Row i contains data[indptr[i]:indptr[i+1]]\ndata : np.ndarray\n    Concatenated row data",
                "parsed": []
              },
              "bases": [],
              "methods": {
                "__getitem__": {
                  "name": "__getitem__",
                  "kind": "function",
                  "signature": "(self, i: int)",
                  "docstring": {
                    "summary": "Get data for row i as tuple.",
                    "description": "Get data for row i as tuple.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "i",
                      "type": "int",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "tuple[(int, ...)]"
                  },
                  "decorators": []
                },
                "__init__": {
                  "name": "__init__",
                  "kind": "function",
                  "signature": "(self, indptr: NDArray[], data: NDArray[])",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "indptr",
                      "type": "NDArray[]",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "data",
                      "type": "NDArray[]",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "__len__": {
                  "name": "__len__",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "int"
                  },
                  "decorators": []
                },
                "filter_sources_with_targets_in": {
                  "name": "filter_sources_with_targets_in",
                  "kind": "function",
                  "signature": "(self, sources: set[int], target_set: set[int])",
                  "docstring": {
                    "summary": "Filter sources that have at least one target in target_set.",
                    "description": "Filter sources that have at least one target in target_set.\n\nReturns both the filtered sources AND the matched targets.\nThis is the core operation for relation spinning.\n\nParameters\n----------\nsources : set[int]\n    Source node IDs (1-indexed)\ntarget_set : set[int]\n    Target node IDs to match against (1-indexed)\n\nReturns\n-------\ntuple[set[int], set[int]]\n    (filtered_sources, matched_targets) - sources with matches and targets that were matched",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "sources",
                      "type": "set[int]",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "target_set",
                      "type": "set[int]",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "tuple[(set[int], set[int])]"
                  },
                  "decorators": []
                },
                "from_sequences": {
                  "name": "from_sequences",
                  "kind": "function",
                  "signature": "(cls, sequences: Sequence[Sequence[int]])",
                  "docstring": {
                    "summary": "Build CSR from sequence of sequences.",
                    "description": "Build CSR from sequence of sequences.\n\nParameters\n----------\nsequences : Sequence[Sequence[int]]\n    List of variable-length integer sequences\n\nReturns\n-------\nCSRArray",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "cls",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "sequences",
                      "type": "Sequence[Sequence[int]]",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "CSRArray"
                  },
                  "decorators": [
                    {
                      "endlineno": 97,
                      "lineno": 97,
                      "value": {
                        "cls": "ExprName",
                        "member": null,
                        "name": "classmethod"
                      }
                    }
                  ]
                },
                "get_all_targets": {
                  "name": "get_all_targets",
                  "kind": "function",
                  "signature": "(self, sources: set[int])",
                  "docstring": {
                    "summary": "Get union of all targets for a set of source nodes.",
                    "description": "Get union of all targets for a set of source nodes.\n\nParameters\n----------\nsources : set[int]\n    Source node IDs (1-indexed)\n\nReturns\n-------\nset[int]\n    Union of all targets from all sources",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "sources",
                      "type": "set[int]",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "set[int]"
                  },
                  "decorators": []
                },
                "get_as_tuple": {
                  "name": "get_as_tuple",
                  "kind": "function",
                  "signature": "(self, i: int)",
                  "docstring": {
                    "summary": "Get data for row i as tuple (alias for __getitem__).",
                    "description": "Get data for row i as tuple (alias for __getitem__).",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "i",
                      "type": "int",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "tuple[(int, ...)]"
                  },
                  "decorators": []
                },
                "load": {
                  "name": "load",
                  "kind": "function",
                  "signature": "(cls, path_prefix: str, mmap_mode: str = 'r')",
                  "docstring": {
                    "summary": "Load from files.",
                    "description": "Load from files.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "cls",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "path_prefix",
                      "type": "str",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "mmap_mode",
                      "type": "str",
                      "default": "'r'",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "CSRArray"
                  },
                  "decorators": [
                    {
                      "endlineno": 130,
                      "lineno": 130,
                      "value": {
                        "cls": "ExprName",
                        "member": null,
                        "name": "classmethod"
                      }
                    }
                  ]
                },
                "memory_usage_bytes": {
                  "name": "memory_usage_bytes",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "Return memory used by RAM cache, or 0 if not cached.",
                    "description": "Return memory used by RAM cache, or 0 if not cached.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "int"
                  },
                  "decorators": []
                },
                "preload_to_ram": {
                  "name": "preload_to_ram",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "Load CSR data into RAM for faster access.",
                    "description": "Load CSR data into RAM for faster access.\n\nThis trades memory for speed. Use when you need fast repeated\naccess to the CSR data (e.g., embedding queries).\n\nMemory cost: indptr.nbytes + data.nbytes (typically 50-100MB for BHSA)",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "release_cache": {
                  "name": "release_cache",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "Release RAM cache, returning to mmap-only access.",
                    "description": "Release RAM cache, returning to mmap-only access.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "save": {
                  "name": "save",
                  "kind": "function",
                  "signature": "(self, path_prefix: str)",
                  "docstring": {
                    "summary": "Save to {path_prefix}_indptr.npy and {path_prefix}_data.npy",
                    "description": "Save to {path_prefix}_indptr.npy and {path_prefix}_data.npy",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "path_prefix",
                      "type": "str",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                }
              },
              "attributes": {
                "_data": {
                  "name": "_data",
                  "type": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "data"
                  }
                },
                "_indptr": {
                  "name": "_indptr",
                  "type": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "indptr"
                  }
                },
                "_ram_data": {
                  "name": "_ram_data",
                  "type": "NDArray[] | None",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": "None"
                },
                "_ram_indptr": {
                  "name": "_ram_indptr",
                  "type": "NDArray[] | None",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": "None"
                },
                "data": {
                  "name": "data",
                  "type": "NDArray[]",
                  "docstring": {
                    "summary": "Return data, using RAM cache if available.",
                    "description": "Return data, using RAM cache if available.",
                    "parsed": []
                  },
                  "value": null
                },
                "indptr": {
                  "name": "indptr",
                  "type": "NDArray[]",
                  "docstring": {
                    "summary": "Return indptr, using RAM cache if available.",
                    "description": "Return indptr, using RAM cache if available.",
                    "parsed": []
                  },
                  "value": null
                },
                "is_cached": {
                  "name": "is_cached",
                  "type": "bool",
                  "docstring": {
                    "summary": "Return True if data is cached in RAM.",
                    "description": "Return True if data is cached in RAM.",
                    "parsed": []
                  },
                  "value": null
                }
              }
            },
            "CSRArrayWithValues": {
              "name": "CSRArrayWithValues",
              "kind": "class",
              "path": "",
              "docstring": {
                "summary": "CSR with associated values (for edge features with values).",
                "description": "CSR with associated values (for edge features with values).",
                "parsed": []
              },
              "bases": [
                "CSRArray"
              ],
              "methods": {
                "__getitem__": {
                  "name": "__getitem__",
                  "kind": "function",
                  "signature": "(self, i: int)",
                  "docstring": {
                    "summary": "Get (indices, values) for row i as tuples.",
                    "description": "Get (indices, values) for row i as tuples.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "i",
                      "type": "int",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "tuple[(tuple[(int, ...)], tuple[(Any, ...)])]"
                  },
                  "decorators": []
                },
                "__init__": {
                  "name": "__init__",
                  "kind": "function",
                  "signature": "(self, indptr: NDArray[], indices: NDArray[], values: NDArray[Any])",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "indptr",
                      "type": "NDArray[]",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "indices",
                      "type": "NDArray[]",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "values",
                      "type": "NDArray[Any]",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "from_dict_of_dicts": {
                  "name": "from_dict_of_dicts",
                  "kind": "function",
                  "signature": "(cls, data: dict[(int, dict[(int, Any)])], num_rows: int, value_dtype: str = 'int32')",
                  "docstring": {
                    "summary": "Build from dict[int, dict[int, value]].",
                    "description": "Build from dict[int, dict[int, value]].\n\nParameters\n----------\ndata : dict\n    Mapping from row index to {column: value} dict\nnum_rows : int\n    Total number of rows\nvalue_dtype : str\n    Numpy dtype for values\n\nReturns\n-------\nCSRArrayWithValues",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "cls",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "data",
                      "type": "dict[(int, dict[(int, Any)])]",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "num_rows",
                      "type": "int",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "value_dtype",
                      "type": "str",
                      "default": "'int32'",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "CSRArrayWithValues"
                  },
                  "decorators": [
                    {
                      "endlineno": 289,
                      "lineno": 289,
                      "value": {
                        "cls": "ExprName",
                        "member": null,
                        "name": "classmethod"
                      }
                    }
                  ]
                },
                "get_as_dict": {
                  "name": "get_as_dict",
                  "kind": "function",
                  "signature": "(self, i: int)",
                  "docstring": {
                    "summary": "Get as {index: value} dict for row i.",
                    "description": "Get as {index: value} dict for row i.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "i",
                      "type": "int",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "dict[(int, Any)]"
                  },
                  "decorators": []
                },
                "load": {
                  "name": "load",
                  "kind": "function",
                  "signature": "(cls, path_prefix: str, mmap_mode: str = 'r')",
                  "docstring": {
                    "summary": "Load from files (with string decoding if needed).",
                    "description": "Load from files (with string decoding if needed).",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "cls",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "path_prefix",
                      "type": "str",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "mmap_mode",
                      "type": "str",
                      "default": "'r'",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "CSRArrayWithValues"
                  },
                  "decorators": [
                    {
                      "endlineno": 268,
                      "lineno": 268,
                      "value": {
                        "cls": "ExprName",
                        "member": null,
                        "name": "classmethod"
                      }
                    }
                  ]
                },
                "save": {
                  "name": "save",
                  "kind": "function",
                  "signature": "(self, path_prefix: str)",
                  "docstring": {
                    "summary": "Save to files including values (with string encoding if needed).",
                    "description": "Save to files including values (with string encoding if needed).",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "path_prefix",
                      "type": "str",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                }
              },
              "attributes": {
                "indices": {
                  "name": "indices",
                  "type": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "indices"
                  }
                },
                "values": {
                  "name": "values",
                  "type": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "values"
                  }
                }
              }
            }
          },
          "functions": {},
          "modules": {},
          "aliases": {
            "Any": {
              "name": "Any",
              "target": "typing.Any"
            },
            "NDArray": {
              "name": "NDArray",
              "target": "numpy.typing.NDArray"
            },
            "Sequence": {
              "name": "Sequence",
              "target": "collections.abc.Sequence"
            },
            "TYPE_CHECKING": {
              "name": "TYPE_CHECKING",
              "target": "typing.TYPE_CHECKING"
            },
            "annotations": {
              "name": "annotations",
              "target": "__future__.annotations"
            },
            "np": {
              "name": "np",
              "target": "numpy"
            },
            "os": {
              "name": "os",
              "target": "os"
            }
          }
        },
        "mmap_manager": {
          "name": "mmap_manager",
          "kind": "module",
          "path": "",
          "docstring": {
            "summary": "Memory-mapped array management for Context Fabric.",
            "description": "Memory-mapped array management for Context Fabric.",
            "parsed": []
          },
          "classes": {
            "MmapManager": {
              "name": "MmapManager",
              "kind": "class",
              "path": "",
              "docstring": {
                "summary": "Manages memory-mapped numpy arrays for a corpus.",
                "description": "Manages memory-mapped numpy arrays for a corpus.\n\nProvides lazy loading and shared access to corpus data.\n\nParameters\n----------\ncfm_path : Path\n    Path to .cfm/{version}/ directory",
                "parsed": []
              },
              "bases": [],
              "methods": {
                "__init__": {
                  "name": "__init__",
                  "kind": "function",
                  "signature": "(self, cfm_path: Path | str)",
                  "docstring": {
                    "summary": "Initialize manager for a .cfm directory.",
                    "description": "Initialize manager for a .cfm directory.\n\nParameters\n----------\ncfm_path : Path\n    Path to .cfm/{version}/ directory",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "cfm_path",
                      "type": "Path | str",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "close": {
                  "name": "close",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "Release all memory mappings.",
                    "description": "Release all memory mappings.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "exists": {
                  "name": "exists",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "Check if the .cfm directory exists and has metadata.",
                    "description": "Check if the .cfm directory exists and has metadata.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "bool"
                  },
                  "decorators": []
                },
                "get_array": {
                  "name": "get_array",
                  "kind": "function",
                  "signature": "(self, path_parts: str = ())",
                  "docstring": {
                    "summary": "Get a memory-mapped array, loading lazily.",
                    "description": "Get a memory-mapped array, loading lazily.\n\nParameters\n----------\npath_parts : str\n    Path components relative to cfm_path\n    e.g., get_array('warp', 'otype') -> warp/otype.npy\n\nReturns\n-------\nnp.ndarray\n    Memory-mapped array (read-only)",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "path_parts",
                      "type": "str",
                      "default": "()",
                      "kind": "variadic positional"
                    }
                  ],
                  "returns": {
                    "type": "NDArray[Any]"
                  },
                  "decorators": []
                },
                "get_csr": {
                  "name": "get_csr",
                  "kind": "function",
                  "signature": "(self, path_parts: str = ())",
                  "docstring": {
                    "summary": "Get CSR array pair.",
                    "description": "Get CSR array pair.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "path_parts",
                      "type": "str",
                      "default": "()",
                      "kind": "variadic positional"
                    }
                  ],
                  "returns": {
                    "type": "CSRArray"
                  },
                  "decorators": []
                },
                "get_json": {
                  "name": "get_json",
                  "kind": "function",
                  "signature": "(self, path_parts: str = ())",
                  "docstring": {
                    "summary": "Load a JSON metadata file.",
                    "description": "Load a JSON metadata file.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "path_parts",
                      "type": "str",
                      "default": "()",
                      "kind": "variadic positional"
                    }
                  ],
                  "returns": {
                    "type": "Any"
                  },
                  "decorators": []
                },
                "get_string_pool": {
                  "name": "get_string_pool",
                  "kind": "function",
                  "signature": "(self, feature_name: str)",
                  "docstring": {
                    "summary": "Get string pool for a string-valued feature.",
                    "description": "Get string pool for a string-valued feature.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "feature_name",
                      "type": "str",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "StringPool"
                  },
                  "decorators": []
                }
              },
              "attributes": {
                "_arrays": {
                  "name": "_arrays",
                  "type": "dict[(str, NDArray[Any])]",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprDict",
                    "keys": [],
                    "values": []
                  }
                },
                "_meta": {
                  "name": "_meta",
                  "type": "dict[(str, Any)] | None",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": "None"
                },
                "cfm_path": {
                  "name": "cfm_path",
                  "type": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "arguments": [
                      {
                        "cls": "ExprName",
                        "member": null,
                        "name": "cfm_path"
                      }
                    ],
                    "cls": "ExprCall",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "Path"
                    }
                  }
                },
                "max_node": {
                  "name": "max_node",
                  "type": "int",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": null
                },
                "max_slot": {
                  "name": "max_slot",
                  "type": "int",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": null
                },
                "meta": {
                  "name": "meta",
                  "type": "dict[(str, Any)]",
                  "docstring": {
                    "summary": "Load and cache corpus metadata.",
                    "description": "Load and cache corpus metadata.",
                    "parsed": []
                  },
                  "value": null
                },
                "node_types": {
                  "name": "node_types",
                  "type": "list[str]",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": null
                },
                "slot_type": {
                  "name": "slot_type",
                  "type": "str",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": null
                }
              }
            }
          },
          "functions": {},
          "modules": {},
          "aliases": {
            "Any": {
              "name": "Any",
              "target": "typing.Any"
            },
            "CSRArray": {
              "name": "CSRArray",
              "target": "cfabric.storage.csr.CSRArray"
            },
            "NDArray": {
              "name": "NDArray",
              "target": "numpy.typing.NDArray"
            },
            "Path": {
              "name": "Path",
              "target": "pathlib.Path"
            },
            "StringPool": {
              "name": "StringPool",
              "target": "cfabric.storage.string_pool.StringPool"
            },
            "TYPE_CHECKING": {
              "name": "TYPE_CHECKING",
              "target": "typing.TYPE_CHECKING"
            },
            "annotations": {
              "name": "annotations",
              "target": "__future__.annotations"
            },
            "json": {
              "name": "json",
              "target": "json"
            },
            "np": {
              "name": "np",
              "target": "numpy"
            }
          }
        },
        "string_pool": {
          "name": "string_pool",
          "kind": "module",
          "path": "",
          "docstring": {
            "summary": "String pool management for string-valued features.",
            "description": "String pool management for string-valued features.\n\nThis module provides efficient storage for string-valued features using\ninteger indices into a shared string pool. This approach minimizes memory\nusage when many nodes share the same string values.",
            "parsed": []
          },
          "classes": {
            "IntFeatureArray": {
              "name": "IntFeatureArray",
              "kind": "class",
              "path": "",
              "docstring": {
                "summary": "Integer feature storage.",
                "description": "Integer feature storage.\n\nDense array with sentinel for missing values.\n\nAttributes\n----------\nvalues : np.ndarray\n    Array of integer values (dtype=int32)\n    MISSING (-1) indicates no value",
                "parsed": []
              },
              "bases": [],
              "methods": {
                "__getitem__": {
                  "name": "__getitem__",
                  "kind": "function",
                  "signature": "(self, node: int)",
                  "docstring": {
                    "summary": "Get int value for node using bracket notation.",
                    "description": "Get int value for node using bracket notation.\n\nParameters\n----------\nnode : int\n    Node number (1-indexed)\n\nReturns\n-------\nint | None\n    Integer value or None if missing",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "node",
                      "type": "int",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "int | None"
                  },
                  "decorators": []
                },
                "__init__": {
                  "name": "__init__",
                  "kind": "function",
                  "signature": "(self, values: NDArray[])",
                  "docstring": {
                    "summary": "Initialize an IntFeatureArray.",
                    "description": "Initialize an IntFeatureArray.\n\nParameters\n----------\nvalues : np.ndarray\n    Array of integer values (dtype=int32)",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "values",
                      "type": "NDArray[]",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "__len__": {
                  "name": "__len__",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "Number of nodes tracked.",
                    "description": "Number of nodes tracked.\n\nReturns\n-------\nint\n    Length of values array",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "int"
                  },
                  "decorators": []
                },
                "filter_by_value": {
                  "name": "filter_by_value",
                  "kind": "function",
                  "signature": "(self, nodes: list[int] | range, value: int)",
                  "docstring": {
                    "summary": "Vectorized filter: return nodes where feature equals value.",
                    "description": "Vectorized filter: return nodes where feature equals value.\n\nParameters\n----------\nnodes : list[int] | range\n    Nodes to filter (1-indexed)\nvalue : int\n    Value to match\n\nReturns\n-------\nNDArray[np.int64]\n    Array of matching nodes (1-indexed)",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "nodes",
                      "type": "list[int] | range",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "value",
                      "type": "int",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "NDArray[]"
                  },
                  "decorators": []
                },
                "filter_by_values": {
                  "name": "filter_by_values",
                  "kind": "function",
                  "signature": "(self, nodes: list[int] | range, values: set[int])",
                  "docstring": {
                    "summary": "Vectorized filter: return nodes where feature is in values set.",
                    "description": "Vectorized filter: return nodes where feature is in values set.\n\nParameters\n----------\nnodes : list[int] | range\n    Nodes to filter (1-indexed)\nvalues : set[int]\n    Set of values to match\n\nReturns\n-------\nNDArray[np.int64]\n    Array of matching nodes (1-indexed)",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "nodes",
                      "type": "list[int] | range",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "values",
                      "type": "set[int]",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "NDArray[]"
                  },
                  "decorators": []
                },
                "filter_greater_than": {
                  "name": "filter_greater_than",
                  "kind": "function",
                  "signature": "(self, nodes: list[int] | range, threshold: int)",
                  "docstring": {
                    "summary": "Vectorized filter: return nodes where value > threshold.",
                    "description": "Vectorized filter: return nodes where value > threshold.\n\nParameters\n----------\nnodes : list[int] | range\n    Nodes to filter (1-indexed)\nthreshold : int\n    Threshold value\n\nReturns\n-------\nNDArray[np.int64]\n    Array of matching nodes (1-indexed)",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "nodes",
                      "type": "list[int] | range",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "threshold",
                      "type": "int",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "NDArray[]"
                  },
                  "decorators": []
                },
                "filter_has_value": {
                  "name": "filter_has_value",
                  "kind": "function",
                  "signature": "(self, nodes: list[int] | range)",
                  "docstring": {
                    "summary": "Vectorized filter: return nodes that have any value.",
                    "description": "Vectorized filter: return nodes that have any value.\n\nParameters\n----------\nnodes : list[int] | range\n    Nodes to filter (1-indexed)\n\nReturns\n-------\nNDArray[np.int64]\n    Array of nodes with values (1-indexed)",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "nodes",
                      "type": "list[int] | range",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "NDArray[]"
                  },
                  "decorators": []
                },
                "filter_less_than": {
                  "name": "filter_less_than",
                  "kind": "function",
                  "signature": "(self, nodes: list[int] | range, threshold: int)",
                  "docstring": {
                    "summary": "Vectorized filter: return nodes where value < threshold.",
                    "description": "Vectorized filter: return nodes where value < threshold.\n\nParameters\n----------\nnodes : list[int] | range\n    Nodes to filter (1-indexed)\nthreshold : int\n    Threshold value\n\nReturns\n-------\nNDArray[np.int64]\n    Array of matching nodes (1-indexed)",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "nodes",
                      "type": "list[int] | range",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "threshold",
                      "type": "int",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "NDArray[]"
                  },
                  "decorators": []
                },
                "filter_missing_value": {
                  "name": "filter_missing_value",
                  "kind": "function",
                  "signature": "(self, nodes: list[int] | range)",
                  "docstring": {
                    "summary": "Vectorized filter: return nodes that have no value.",
                    "description": "Vectorized filter: return nodes that have no value.\n\nParameters\n----------\nnodes : list[int] | range\n    Nodes to filter (1-indexed)\n\nReturns\n-------\nNDArray[np.int64]\n    Array of nodes without values (1-indexed)",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "nodes",
                      "type": "list[int] | range",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "NDArray[]"
                  },
                  "decorators": []
                },
                "from_dict": {
                  "name": "from_dict",
                  "kind": "function",
                  "signature": "(cls, data: dict[(int, int | None)], max_node: int)",
                  "docstring": {
                    "summary": "Build from node->int dict.",
                    "description": "Build from node->int dict.\n\nParameters\n----------\ndata : dict[int, int | None]\n    Mapping from node (int) to integer value (or None for missing)\nmax_node : int\n    Maximum node number in corpus\n\nReturns\n-------\nIntFeatureArray\n    New IntFeatureArray instance",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "cls",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "data",
                      "type": "dict[(int, int | None)]",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "max_node",
                      "type": "int",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "IntFeatureArray"
                  },
                  "decorators": [
                    {
                      "endlineno": 494,
                      "lineno": 494,
                      "value": {
                        "cls": "ExprName",
                        "member": null,
                        "name": "classmethod"
                      }
                    }
                  ]
                },
                "get": {
                  "name": "get",
                  "kind": "function",
                  "signature": "(self, node: int)",
                  "docstring": {
                    "summary": "Get int value for node (1-indexed).",
                    "description": "Get int value for node (1-indexed).\n\nParameters\n----------\nnode : int\n    Node number (1-indexed)\n\nReturns\n-------\nint | None\n    Integer value or None if missing",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "node",
                      "type": "int",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "int | None"
                  },
                  "decorators": []
                },
                "get_frequency_counts": {
                  "name": "get_frequency_counts",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "Get frequency counts of all values using vectorized numpy operations.",
                    "description": "Get frequency counts of all values using vectorized numpy operations.\n\nReturns\n-------\ndict[int, int]\n    Mapping from integer value to count",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "dict[(int, int)]"
                  },
                  "decorators": []
                },
                "items": {
                  "name": "items",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "Iterate over (node, value) pairs efficiently using numpy.",
                    "description": "Iterate over (node, value) pairs efficiently using numpy.\n\nOnly yields nodes that have values (skips MISSING entries).\n\nYields\n------\ntuple[int, int]\n    (node, int_value) pairs",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "Iterator[tuple[(int, int)]]"
                  },
                  "decorators": []
                },
                "load": {
                  "name": "load",
                  "kind": "function",
                  "signature": "(cls, path: str, mmap_mode: str = 'r')",
                  "docstring": {
                    "summary": "Load from .npy file.",
                    "description": "Load from .npy file.\n\nParameters\n----------\npath : str\n    Input file path\nmmap_mode : str, optional\n    Memory-map mode (default: 'r')\n\nReturns\n-------\nIntFeatureArray\n    Loaded IntFeatureArray instance",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "cls",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "path",
                      "type": "str",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "mmap_mode",
                      "type": "str",
                      "default": "'r'",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "IntFeatureArray"
                  },
                  "decorators": [
                    {
                      "endlineno": 529,
                      "lineno": 529,
                      "value": {
                        "cls": "ExprName",
                        "member": null,
                        "name": "classmethod"
                      }
                    }
                  ]
                },
                "save": {
                  "name": "save",
                  "kind": "function",
                  "signature": "(self, path: str)",
                  "docstring": {
                    "summary": "Save to .npy file.",
                    "description": "Save to .npy file.\n\nParameters\n----------\npath : str\n    Output file path",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "path",
                      "type": "str",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "to_dict": {
                  "name": "to_dict",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "Convert to dict efficiently.",
                    "description": "Convert to dict efficiently.\n\nReturns\n-------\ndict[int, int]\n    Mapping from node to int value",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "dict[(int, int)]"
                  },
                  "decorators": []
                }
              },
              "attributes": {
                "MISSING": {
                  "name": "MISSING",
                  "type": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprUnaryOp",
                    "operator": "-",
                    "value": "1"
                  }
                },
                "values": {
                  "name": "values",
                  "type": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "values"
                  }
                }
              }
            },
            "StringPool": {
              "name": "StringPool",
              "kind": "class",
              "path": "",
              "docstring": {
                "summary": "Efficient string storage with integer indices.",
                "description": "Efficient string storage with integer indices.\n\nUses numpy object arrays which support copy-on-write sharing.\n\nAttributes\n----------\nstrings : np.ndarray\n    Array of unique strings (dtype=object)\nindices : np.ndarray\n    Per-node index into strings array (dtype=uint32)\n    MISSING_STR_INDEX indicates no value",
                "parsed": []
              },
              "bases": [],
              "methods": {
                "__getitem__": {
                  "name": "__getitem__",
                  "kind": "function",
                  "signature": "(self, node: int)",
                  "docstring": {
                    "summary": "Get string value for node using bracket notation.",
                    "description": "Get string value for node using bracket notation.\n\nParameters\n----------\nnode : int\n    Node number (1-indexed)\n\nReturns\n-------\nstr | None\n    String value or None if missing",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "node",
                      "type": "int",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "str | None"
                  },
                  "decorators": []
                },
                "__init__": {
                  "name": "__init__",
                  "kind": "function",
                  "signature": "(self, strings: NDArray[], indices: NDArray[])",
                  "docstring": {
                    "summary": "Initialize a StringPool.",
                    "description": "Initialize a StringPool.\n\nParameters\n----------\nstrings : np.ndarray\n    Array of unique strings (dtype=object)\nindices : np.ndarray\n    Per-node index into strings array (dtype=uint32)",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "strings",
                      "type": "NDArray[]",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "indices",
                      "type": "NDArray[]",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "__len__": {
                  "name": "__len__",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "Number of nodes tracked.",
                    "description": "Number of nodes tracked.\n\nReturns\n-------\nint\n    Length of indices array",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "int"
                  },
                  "decorators": []
                },
                "filter_by_value": {
                  "name": "filter_by_value",
                  "kind": "function",
                  "signature": "(self, nodes: list[int] | range, value: str)",
                  "docstring": {
                    "summary": "Vectorized filter: return nodes where feature equals value.",
                    "description": "Vectorized filter: return nodes where feature equals value.\n\nThis is much faster than calling get() in a loop because it uses\nnumpy vectorized operations instead of per-element Python calls.\n\nParameters\n----------\nnodes : list[int] | range\n    Nodes to filter (1-indexed)\nvalue : str\n    Value to match\n\nReturns\n-------\nNDArray[np.int64]\n    Array of matching nodes (1-indexed)",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "nodes",
                      "type": "list[int] | range",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "value",
                      "type": "str",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "NDArray[]"
                  },
                  "decorators": []
                },
                "filter_by_values": {
                  "name": "filter_by_values",
                  "kind": "function",
                  "signature": "(self, nodes: list[int] | range, values: set[str])",
                  "docstring": {
                    "summary": "Vectorized filter: return nodes where feature is in values set.",
                    "description": "Vectorized filter: return nodes where feature is in values set.\n\nParameters\n----------\nnodes : list[int] | range\n    Nodes to filter (1-indexed)\nvalues : set[str]\n    Set of values to match\n\nReturns\n-------\nNDArray[np.int64]\n    Array of matching nodes (1-indexed)",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "nodes",
                      "type": "list[int] | range",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "values",
                      "type": "set[str]",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "NDArray[]"
                  },
                  "decorators": []
                },
                "filter_has_value": {
                  "name": "filter_has_value",
                  "kind": "function",
                  "signature": "(self, nodes: list[int] | range)",
                  "docstring": {
                    "summary": "Vectorized filter: return nodes that have any value.",
                    "description": "Vectorized filter: return nodes that have any value.\n\nParameters\n----------\nnodes : list[int] | range\n    Nodes to filter (1-indexed)\n\nReturns\n-------\nNDArray[np.int64]\n    Array of nodes with values (1-indexed)",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "nodes",
                      "type": "list[int] | range",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "NDArray[]"
                  },
                  "decorators": []
                },
                "filter_missing_value": {
                  "name": "filter_missing_value",
                  "kind": "function",
                  "signature": "(self, nodes: list[int] | range)",
                  "docstring": {
                    "summary": "Vectorized filter: return nodes that have no value.",
                    "description": "Vectorized filter: return nodes that have no value.\n\nParameters\n----------\nnodes : list[int] | range\n    Nodes to filter (1-indexed)\n\nReturns\n-------\nNDArray[np.int64]\n    Array of nodes without values (1-indexed)",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "nodes",
                      "type": "list[int] | range",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "NDArray[]"
                  },
                  "decorators": []
                },
                "from_dict": {
                  "name": "from_dict",
                  "kind": "function",
                  "signature": "(cls, data: dict[(int, str)], max_node: int)",
                  "docstring": {
                    "summary": "Build string pool from node->string dict.",
                    "description": "Build string pool from node->string dict.\n\nParameters\n----------\ndata : dict[int, str]\n    Mapping from node (int) to string value\nmax_node : int\n    Maximum node number in corpus\n\nReturns\n-------\nStringPool\n    New StringPool instance",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "cls",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "data",
                      "type": "dict[(int, str)]",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "max_node",
                      "type": "int",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "StringPool"
                  },
                  "decorators": [
                    {
                      "endlineno": 138,
                      "lineno": 138,
                      "value": {
                        "cls": "ExprName",
                        "member": null,
                        "name": "classmethod"
                      }
                    }
                  ]
                },
                "get": {
                  "name": "get",
                  "kind": "function",
                  "signature": "(self, node: int)",
                  "docstring": {
                    "summary": "Get string value for node (1-indexed).",
                    "description": "Get string value for node (1-indexed).\n\nParameters\n----------\nnode : int\n    Node number (1-indexed)\n\nReturns\n-------\nstr | None\n    String value or None if missing",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "node",
                      "type": "int",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "str | None"
                  },
                  "decorators": []
                },
                "get_frequency_counts": {
                  "name": "get_frequency_counts",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "Get frequency counts of all values using vectorized numpy operations.",
                    "description": "Get frequency counts of all values using vectorized numpy operations.\n\nReturns\n-------\ndict[str, int]\n    Mapping from string value to count",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "dict[(str, int)]"
                  },
                  "decorators": []
                },
                "get_value_index": {
                  "name": "get_value_index",
                  "kind": "function",
                  "signature": "(self, value: str)",
                  "docstring": {
                    "summary": "Get the internal index for a string value.",
                    "description": "Get the internal index for a string value.\n\nUseful for pre-computing indices for repeated filtering operations.\n\nParameters\n----------\nvalue : str\n    String value to look up\n\nReturns\n-------\nint | None\n    Internal index, or None if value doesn't exist",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "value",
                      "type": "str",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "int | None"
                  },
                  "decorators": []
                },
                "items": {
                  "name": "items",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "Iterate over (node, value) pairs efficiently using numpy.",
                    "description": "Iterate over (node, value) pairs efficiently using numpy.\n\nOnly yields nodes that have values (skips MISSING entries).\n\nYields\n------\ntuple[int, str]\n    (node, string_value) pairs",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "Iterator[tuple[(int, str)]]"
                  },
                  "decorators": []
                },
                "load": {
                  "name": "load",
                  "kind": "function",
                  "signature": "(cls, path_prefix: str, mmap_mode: str = 'r')",
                  "docstring": {
                    "summary": "Load from files.",
                    "description": "Load from files.\n\nParameters\n----------\npath_prefix : str\n    Path prefix for input files\nmmap_mode : str, optional\n    Memory-map mode for indices array (default: 'r')\n\nReturns\n-------\nStringPool\n    Loaded StringPool instance",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "cls",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "path_prefix",
                      "type": "str",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "mmap_mode",
                      "type": "str",
                      "default": "'r'",
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "StringPool"
                  },
                  "decorators": [
                    {
                      "endlineno": 179,
                      "lineno": 179,
                      "value": {
                        "cls": "ExprName",
                        "member": null,
                        "name": "classmethod"
                      }
                    }
                  ]
                },
                "save": {
                  "name": "save",
                  "kind": "function",
                  "signature": "(self, path_prefix: str)",
                  "docstring": {
                    "summary": "Save to {path_prefix}_strings.npy and {path_prefix}_idx.npy.",
                    "description": "Save to {path_prefix}_strings.npy and {path_prefix}_idx.npy.\n\nParameters\n----------\npath_prefix : str\n    Path prefix for output files",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "path_prefix",
                      "type": "str",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "to_dict": {
                  "name": "to_dict",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "Convert to dict efficiently.",
                    "description": "Convert to dict efficiently.\n\nReturns\n-------\ndict[int, str]\n    Mapping from node to string value",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "dict[(int, str)]"
                  },
                  "decorators": []
                }
              },
              "attributes": {
                "indices": {
                  "name": "indices",
                  "type": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "indices"
                  }
                },
                "strings": {
                  "name": "strings",
                  "type": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "strings"
                  }
                }
              }
            }
          },
          "functions": {},
          "modules": {},
          "aliases": {
            "Iterator": {
              "name": "Iterator",
              "target": "collections.abc.Iterator"
            },
            "NDArray": {
              "name": "NDArray",
              "target": "numpy.typing.NDArray"
            },
            "TYPE_CHECKING": {
              "name": "TYPE_CHECKING",
              "target": "typing.TYPE_CHECKING"
            },
            "annotations": {
              "name": "annotations",
              "target": "__future__.annotations"
            },
            "np": {
              "name": "np",
              "target": "numpy"
            }
          }
        }
      },
      "aliases": {
        "CSRArray": {
          "name": "CSRArray",
          "target": "cfabric.storage.csr.CSRArray"
        },
        "CSRArrayWithValues": {
          "name": "CSRArrayWithValues",
          "target": "cfabric.storage.csr.CSRArrayWithValues"
        },
        "IntFeatureArray": {
          "name": "IntFeatureArray",
          "target": "cfabric.storage.string_pool.IntFeatureArray"
        },
        "MmapManager": {
          "name": "MmapManager",
          "target": "cfabric.storage.mmap_manager.MmapManager"
        },
        "StringPool": {
          "name": "StringPool",
          "target": "cfabric.storage.string_pool.StringPool"
        }
      }
    },
    "types": {
      "name": "types",
      "kind": "module",
      "path": "",
      "docstring": {
        "summary": "Type definitions for Context-Fabric.",
        "description": "Type definitions for Context-Fabric.\n\nThis module defines type aliases used throughout the codebase for\nimproved type safety and documentation.",
        "parsed": []
      },
      "classes": {},
      "functions": {},
      "modules": {},
      "aliases": {
        "NDArray": {
          "name": "NDArray",
          "target": "numpy.typing.NDArray"
        },
        "TypeAlias": {
          "name": "TypeAlias",
          "target": "typing.TypeAlias"
        },
        "np": {
          "name": "np",
          "target": "numpy"
        }
      }
    },
    "utils": {
      "name": "utils",
      "kind": "module",
      "path": "",
      "docstring": {
        "summary": "Utility modules for Context-Fabric.",
        "description": "Utility modules for Context-Fabric.\n\nThis module provides helper functions, file operations, and other utilities.",
        "parsed": []
      },
      "classes": {},
      "functions": {},
      "modules": {
        "attrs": {
          "name": "attrs",
          "kind": "module",
          "path": "",
          "docstring": {
            "summary": "",
            "description": "",
            "sections": {}
          },
          "classes": {
            "AttrDict": {
              "name": "AttrDict",
              "kind": "class",
              "path": "",
              "docstring": {
                "summary": "Turn a dict into an object with attributes.",
                "description": "Turn a dict into an object with attributes.\n\nIf non-existing attributes are accessed for reading, `None` is returned.\n\nSee these links on stackoverflow:\n\n*   [1](https://stackoverflow.com/questions/4984647/accessing-dict-keys-like-an-attribute)\n*   [2](https://stackoverflow.com/questions/16237659/python-how-to-implement-getattr)\n    especially the remark that\n\n    > `__getattr__` is only used for missing attribute lookup\n\nWe also need to define the `__missing__` method in case we access the underlying\ndict by means of keys, like `xxx[\"yyy\"]` rather then by attribute like `xxx.yyy`.",
                "parsed": []
              },
              "bases": [
                "dict"
              ],
              "methods": {
                "__getattr__": {
                  "name": "__getattr__",
                  "kind": "function",
                  "signature": "(self, key: str, args: Any = (), kwargs: Any = {})",
                  "docstring": {
                    "summary": "Provide a default when retrieving a non-existent member.",
                    "description": "Provide a default when retrieving a non-existent member.\n\nThis method is used when using the `[key]` notation for accessing members.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "key",
                      "type": "str",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "args",
                      "type": "Any",
                      "default": "()",
                      "kind": "variadic positional"
                    },
                    {
                      "name": "kwargs",
                      "type": "Any",
                      "default": "{}",
                      "kind": "variadic keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "__init__": {
                  "name": "__init__",
                  "kind": "function",
                  "signature": "(self, args: Any = (), kwargs: Any = {})",
                  "docstring": {
                    "summary": "Create the data structure from incoming data.",
                    "description": "Create the data structure from incoming data.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "args",
                      "type": "Any",
                      "default": "()",
                      "kind": "variadic positional"
                    },
                    {
                      "name": "kwargs",
                      "type": "Any",
                      "default": "{}",
                      "kind": "variadic keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "__missing__": {
                  "name": "__missing__",
                  "kind": "function",
                  "signature": "(self, key: str, args: Any = (), kwargs: Any = {})",
                  "docstring": {
                    "summary": "Provide a default when retrieving a non-existent member.",
                    "description": "Provide a default when retrieving a non-existent member.\n\nThis method is used when using the `.key` notation for accessing members.",
                    "parsed": []
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "key",
                      "type": "str",
                      "default": null,
                      "kind": "positional or keyword"
                    },
                    {
                      "name": "args",
                      "type": "Any",
                      "default": "()",
                      "kind": "variadic positional"
                    },
                    {
                      "name": "kwargs",
                      "type": "Any",
                      "default": "{}",
                      "kind": "variadic keyword"
                    }
                  ],
                  "returns": {
                    "type": "None"
                  },
                  "decorators": []
                },
                "deepdict": {
                  "name": "deepdict",
                  "kind": "function",
                  "signature": "(self)",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "parameters": [
                    {
                      "name": "self",
                      "type": "",
                      "default": null,
                      "kind": "positional or keyword"
                    }
                  ],
                  "returns": {
                    "type": "dict[(str, Any)]"
                  },
                  "decorators": []
                }
              },
              "attributes": {
                "__dict__": {
                  "name": "__dict__",
                  "type": "",
                  "docstring": {
                    "summary": "",
                    "description": "",
                    "sections": {}
                  },
                  "value": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "self"
                  }
                }
              }
            }
          },
          "functions": {
            "deepAttrDict": {
              "name": "deepAttrDict",
              "kind": "function",
              "signature": "(info: Any, preferTuples: bool = False)",
              "docstring": {
                "summary": "Turn a `dict` into an `AttrDict`, recursively.",
                "description": "Turn a `dict` into an `AttrDict`, recursively.\n\nParameters\n----------\ninfo: any\n    The input dictionary. We assume that it is a data structure built by\n    `tuple`, `list`, `set`, `frozenset`, `dict` and atomic types such as\n    `int`, `str`, `bool`.\n    We assume there are no user defined objects in it, and no generators\n    and functions.\npreferTuples: boolean, optional False\n    Lists are converted to tuples.\n\nReturns\n-------\nAttrDict\n    An `AttrDict` containing the same info as the input dictionary, but where\n    each value of type `dict` is turned into an `AttrDict`.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "info",
                  "type": "Any",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "preferTuples",
                  "type": "bool",
                  "default": "False",
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "Any"
              },
              "decorators": []
            },
            "deepdict": {
              "name": "deepdict",
              "kind": "function",
              "signature": "(info: Any, ordinary: bool = False)",
              "docstring": {
                "summary": "Turns an `AttrDict` into a `dict`, recursively.",
                "description": "Turns an `AttrDict` into a `dict`, recursively.\n\nParameters\n----------\ninfo: any\n    The input dictionary. We assume that it is a data structure built by\n    `tuple`, `list`, `set`, `frozenset`, `dict` and atomic types such as\n    `int`, `str`, `bool`.\n    We assume there are no user defined objects in it, and no generators\n    and functions.\nordinary: boolean, optional False\n    If True, no frozensets and tuples are constructed, but sets and lists\n    instead.\n\nReturns\n-------\ndict\n    A dictionary containing the same info as the input dictionary, but where\n    each value of type `AttrDict` is turned into a `dict`.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "info",
                  "type": "Any",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "ordinary",
                  "type": "bool",
                  "default": "False",
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "Any"
              },
              "decorators": []
            },
            "isIterable": {
              "name": "isIterable",
              "kind": "function",
              "signature": "(value: Any)",
              "docstring": {
                "summary": "Whether a value is a non-string iterable.",
                "description": "Whether a value is a non-string iterable.\n\n!!! note\n    Strings are iterables.\n    But for this purpose we regard strings as non-iterable scalars.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "value",
                  "type": "Any",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "bool"
              },
              "decorators": []
            }
          },
          "modules": {},
          "aliases": {
            "Any": {
              "name": "Any",
              "target": "typing.Any"
            },
            "annotations": {
              "name": "annotations",
              "target": "__future__.annotations"
            }
          }
        },
        "cli": {
          "name": "cli",
          "kind": "module",
          "path": "",
          "docstring": {
            "summary": "Command-line argument parsing utilities for Context-Fabric tools.",
            "description": "Command-line argument parsing utilities for Context-Fabric tools.\n\nThis module provides a flexible argument parser for CLI tools that need to\nhandle tasks, parameters, and flags. It supports:\n\n- Named tasks with descriptions\n- Key=value parameters with defaults\n- Boolean and tri-state flags (-/+/++ syntax)\n- Automatic help text generation\n- Validation of argument names\n\nSee Also\n--------\nreadArgs : Main function for parsing command-line arguments",
            "parsed": []
          },
          "classes": {},
          "functions": {
            "readArgs": {
              "name": "readArgs",
              "kind": "function",
              "signature": "(command: str, descr: str, possibleTasks: dict[(str, str)], possibleParams: dict[(str, tuple[(str, str)])], possibleFlags: dict[(str, tuple[(str, int | bool, int)])], notInAll: set[str] = {'arguments': [], 'cls': 'ExprCall', 'function': {'cls': 'ExprName', 'member': None, 'name': 'set'}})",
              "docstring": {
                "summary": "Interpret tasks, parameters and flags specified.",
                "description": "Interpret tasks, parameters and flags specified.\n\nParameters\n----------\ncommand:\n    The name of the command, as entered on the command-line\ndescr: string\n    A description of the task\npossibleTasks: dict\n    Keyed by the names of tasks, the values are a short description of the task.\npossibleParams: dict\n    Keyed by the names of the parameters, the values are tuples with a short\n    description of the parameter plus a default value for it.\npossibleFlags: dict\n    Keyed by the name of the flags, the values are tuples with a short\n    description of the flag, plus a default value for it, plus the number\n    of values it can take.\n    There are these possibilities:\n\n    *   `2`: values are False or True, represented by `-` and `+`;\n    *   `3`: values are `-1`, `0` or `1`, represented by `-`, `+` and `++`.\n\nnotInAll: set, optional set()\n    A set of tasks which are excluded from execution if `all` is passed as a task\n    argument. Such tasks will only by executed if they are explicitly passed\n    as an argument to the command.\n\nReturns\n-------\ntuple\n    The tuple returned consists of\n\n    *   a boolean whether there is an error in the arguments\n    *   a dict keyed by the tasks, values are True or False\n    *   a dict of the parameters, values are strings\n    *   a dict of the flags, values are -1, 0 or 1",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "command",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "descr",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "possibleTasks",
                  "type": "dict[(str, str)]",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "possibleParams",
                  "type": "dict[(str, tuple[(str, str)])]",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "possibleFlags",
                  "type": "dict[(str, tuple[(str, int | bool, int)])]",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "notInAll",
                  "type": "set[str]",
                  "default": {
                    "arguments": [],
                    "cls": "ExprCall",
                    "function": {
                      "cls": "ExprName",
                      "member": null,
                      "name": "set"
                    }
                  },
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "tuple[(bool, dict[(str, bool)], dict[(str, str)], dict[(str, int | bool)])]"
              },
              "decorators": []
            }
          },
          "modules": {},
          "aliases": {
            "Any": {
              "name": "Any",
              "target": "typing.Any"
            },
            "annotations": {
              "name": "annotations",
              "target": "__future__.annotations"
            },
            "console": {
              "name": "console",
              "target": "cfabric.utils.helpers.console"
            },
            "dedent": {
              "name": "dedent",
              "target": "textwrap.dedent"
            },
            "sys": {
              "name": "sys",
              "target": "sys"
            }
          }
        },
        "files": {
          "name": "files",
          "kind": "module",
          "path": "",
          "docstring": {
            "summary": "",
            "description": "",
            "sections": {}
          },
          "classes": {},
          "functions": {
            "abspath": {
              "name": "abspath",
              "kind": "function",
              "signature": "(path: str)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "path",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "str"
              },
              "decorators": []
            },
            "annotateDir": {
              "name": "annotateDir",
              "kind": "function",
              "signature": "(app: Any, tool: str)",
              "docstring": {
                "summary": "Return the input and output and report directories for a specific annotation tool.",
                "description": "Return the input and output and report directories for a specific annotation tool.\n\n*   The input directory is located next to the CF data of the corpus\n*   The output directory is located in the `_temp` directory next to the CF data of\n    the corpus\n    of the corpus\n\nParameters\n----------\napp: object\n    the CF app\ntool: string\n    The name of the annotation tool\n\nReturns\n-------\nstring\n    The path of the working directory for that tool and that corpus",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "app",
                  "type": "Any",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "tool",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "tuple[(str, str)]"
              },
              "decorators": []
            },
            "backendRep": {
              "name": "backendRep",
              "kind": "function",
              "signature": "(be: str | None, kind: str, default: str | None = None)",
              "docstring": {
                "summary": "Various back-end dependent values.",
                "description": "Various back-end dependent values.\n\nFirst of all, the back-end value is\nnormalized. Then related values are computed.\n\nParameters\n----------\nbe: string or None\n    The raw back-end value.\n    It will be normalized first, where missing, undefined, empty values are\n    converted to the string `github`, and other values will be lower-cased.\n    Also, `github.com` and `gitlab.com` will be shortened to `github` and `gitlab`.\n\nkind: string\n    Indicates what kind of related value should be returned:\n\n    *   `norm`: the normalized value as described above\n    *   `tech`: technology of the back-end: either `github` or `gitlab` or None;\n        we assume that there is only one GitHub; that there are many GitLabs;\n        any back-end that is not `github` is an instance of `gitlab`.\n    *   `name`: lowercase shortest name of the back-end: `github` or `gitlab`\n        or a server name like `gitlab.huc.knaw.nl`\n    *   `machine`: lowercase machine name of the back-end: `github.com` or\n        `gitlab.com`\n        or a server name like `gitlab.huc.knaw.nl`\n    *   `spec`: enclosed in `<` and `>`. Depending on the parameter `default`\n        the empty string is returned instead.\n    *   `clone`: base directory where clones of repos in this back-end are stored\n        `~/github`, etc.\n    *   `cache`: base directory where data downloads from this back-end are stored:\n        `~/text-fabric-data/github`, etc.\n    *   `url`: URL of the online back-end\n    *   `urlnb`: URL of notebooks from the online back-end, rendered on NB-Viewer\n    *   `pages`: base URL of the Pages service of the back-end\n\ndefault: boolean, optional False\n    Only relevant for `kind` = `rep`.\n    If `default` is passed and not None and `be` is equal to `default`,\n    then the empty string is returned.\n\n    Explanation: this is used to supply a back-end specifier to a module\n    but only if that module has a different back-end than the main module.\n\nReturns\n-------\nstring",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "be",
                  "type": "str | None",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "kind",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "default",
                  "type": "str | None",
                  "default": "None",
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "str | None"
              },
              "decorators": []
            },
            "chDir": {
              "name": "chDir",
              "kind": "function",
              "signature": "(directory: str)",
              "docstring": {
                "summary": "Change to other directory.",
                "description": "Change to other directory.\n\nParameters\n----------\ndirectory: string\n    The directory to change to.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "directory",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "clearTree": {
              "name": "clearTree",
              "kind": "function",
              "signature": "(path: str)",
              "docstring": {
                "summary": "Remove all files from a directory, recursively, but leave subdirectories.",
                "description": "Remove all files from a directory, recursively, but leave subdirectories.\n\nReason: we want to inspect output in an editor.\nBut if we remove the directories, the editor looses its current directory\nall the time.\n\nParameters\n----------\npath:\n    The directory in question. A leading `~` will be expanded to the user's\n    home directory.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "path",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "dirAllFiles": {
              "name": "dirAllFiles",
              "kind": "function",
              "signature": "(path: str, ignore: set[str] | None = None)",
              "docstring": {
                "summary": "Gets all the files found by `path`.",
                "description": "Gets all the files found by `path`.\n\nThe result is just `[path]` if `path` is a file, otherwise the list of files under\n`path`, recursively.\n\nThe files are sorted alphabetically by path name.\n\nParameters\n----------\npath: string\n    The path to the file or directory on the file system.\nignore: set\n    Names of directories that must be skipped\n\nReturns\n-------\ntuple of string\n    The names of the files under `path`, starting with `path`, followed\n    by the bit relative to `path`.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "path",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "ignore",
                  "type": "set[str] | None",
                  "default": "None",
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "list[str] | tuple[(str, ...)]"
              },
              "decorators": []
            },
            "dirContents": {
              "name": "dirContents",
              "kind": "function",
              "signature": "(path: str)",
              "docstring": {
                "summary": "Gets the contents of a directory.",
                "description": "Gets the contents of a directory.\n\nOnly the direct entries in the directory (not recursively), and only real files\nand folders.\n\nThe list of files and folders will be returned separately.\nThere is no attempt to sort the files.\n\nParameters\n----------\npath: string\n    The path to the directory on the file system.\n\nReturns\n-------\ntuple of tuple\n    The subdirectories and the files.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "path",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "tuple[(tuple[(str, ...)], tuple[(str, ...)])]"
              },
              "decorators": []
            },
            "dirCopy": {
              "name": "dirCopy",
              "kind": "function",
              "signature": "(pathSrc: str, pathDst: str, noclobber: bool = False)",
              "docstring": {
                "summary": "Copies a directory if it exists as directory.",
                "description": "Copies a directory if it exists as directory.\n\nWipes the destination directory, if it exists.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "pathSrc",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "pathDst",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "noclobber",
                  "type": "bool",
                  "default": "False",
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "bool"
              },
              "decorators": []
            },
            "dirEmpty": {
              "name": "dirEmpty",
              "kind": "function",
              "signature": "(target: str)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "target",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "bool"
              },
              "decorators": []
            },
            "dirExists": {
              "name": "dirExists",
              "kind": "function",
              "signature": "(path: str | None)",
              "docstring": {
                "summary": "Whether a path exists as directory on the file system.",
                "description": "Whether a path exists as directory on the file system.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "path",
                  "type": "str | None",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "bool"
              },
              "decorators": []
            },
            "dirMake": {
              "name": "dirMake",
              "kind": "function",
              "signature": "(path: str)",
              "docstring": {
                "summary": "Creates a directory if it does not already exist as directory.",
                "description": "Creates a directory if it does not already exist as directory.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "path",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "dirMove": {
              "name": "dirMove",
              "kind": "function",
              "signature": "(pathSrc: str, pathDst: str)",
              "docstring": {
                "summary": "Moves a directory if it exists as directory.",
                "description": "Moves a directory if it exists as directory.\n\nRefuses the operation in the target exists.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "pathSrc",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "pathDst",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "bool"
              },
              "decorators": []
            },
            "dirNm": {
              "name": "dirNm",
              "kind": "function",
              "signature": "(path: str)",
              "docstring": {
                "summary": "Get the directory part of a file name.",
                "description": "Get the directory part of a file name.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "path",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "str"
              },
              "decorators": []
            },
            "dirRemove": {
              "name": "dirRemove",
              "kind": "function",
              "signature": "(path: str)",
              "docstring": {
                "summary": "Removes a directory if it exists as directory.",
                "description": "Removes a directory if it exists as directory.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "path",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "expandDir": {
              "name": "expandDir",
              "kind": "function",
              "signature": "(obj: Any, dirName: str)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "obj",
                  "type": "Any",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "dirName",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "str"
              },
              "decorators": []
            },
            "expanduser": {
              "name": "expanduser",
              "kind": "function",
              "signature": "(path: str)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "path",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "str"
              },
              "decorators": []
            },
            "extNm": {
              "name": "extNm",
              "kind": "function",
              "signature": "(path: str)",
              "docstring": {
                "summary": "Get the extension part of a file name.",
                "description": "Get the extension part of a file name.\n\nThe dot is not included.\nIf there is no extension, the empty string is returned.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "path",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "str"
              },
              "decorators": []
            },
            "fileCopy": {
              "name": "fileCopy",
              "kind": "function",
              "signature": "(pathSrc: str, pathDst: str)",
              "docstring": {
                "summary": "Copies a file if it exists as file.",
                "description": "Copies a file if it exists as file.\n\nWipes the destination file, if it exists.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "pathSrc",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "pathDst",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "fileCopyExpr": {
              "name": "fileCopyExpr",
              "kind": "function",
              "signature": "(dirSrc: str, dirDst: str)",
              "docstring": {
                "summary": "Copies the `__checkout__.txt` file from one directory to an other.",
                "description": "Copies the `__checkout__.txt` file from one directory to an other.\n\nWipes the destination file, if it exists.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "dirSrc",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "dirDst",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "fileExists": {
              "name": "fileExists",
              "kind": "function",
              "signature": "(path: str)",
              "docstring": {
                "summary": "Whether a path exists as file on the file system.",
                "description": "Whether a path exists as file on the file system.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "path",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "bool"
              },
              "decorators": []
            },
            "fileMake": {
              "name": "fileMake",
              "kind": "function",
              "signature": "(path: str, force: bool = False)",
              "docstring": {
                "summary": "Create a new empty file.",
                "description": "Create a new empty file.\n\nIf necessary, create intermediate subdirectories.\nIf the file already exists, do nothing, unless `force` is True.\nIf the file exists as a directory, do nothing\n\nParameters\n----------\npath: string\n    The path to the new file\nforce: boolean, optional False\n    If `False`, nothing is done if the file already exists.\n    Otherwise, an existing file is truncated.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "path",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "force",
                  "type": "bool",
                  "default": "False",
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "fileMove": {
              "name": "fileMove",
              "kind": "function",
              "signature": "(pathSrc: str, pathDst: str)",
              "docstring": {
                "summary": "Moves a file if it exists as file.",
                "description": "Moves a file if it exists as file.\n\nWipes the destination file, if it exists.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "pathSrc",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "pathDst",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "fileNm": {
              "name": "fileNm",
              "kind": "function",
              "signature": "(path: str)",
              "docstring": {
                "summary": "Get the file part of a file name.",
                "description": "Get the file part of a file name.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "path",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "str"
              },
              "decorators": []
            },
            "fileOpen": {
              "name": "fileOpen",
              "kind": "function",
              "signature": "(args: Any = (), kwargs: Any = {})",
              "docstring": {
                "summary": "Wrapper around `open()`, making sure `encoding=\"utf8\" is passed.",
                "description": "Wrapper around `open()`, making sure `encoding=\"utf8\" is passed.\n\nThis function calls `open()` with the same arguments, but if the optional\nargument `encoding` is missing and the mode argument does not contain a `b`\n(binary file), then `encoding=\"utf8\"` is supplied.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "args",
                  "type": "Any",
                  "default": "()",
                  "kind": "variadic positional"
                },
                {
                  "name": "kwargs",
                  "type": "Any",
                  "default": "{}",
                  "kind": "variadic keyword"
                }
              ],
              "returns": {
                "type": "TextIO | BinaryIO"
              },
              "decorators": []
            },
            "fileRemove": {
              "name": "fileRemove",
              "kind": "function",
              "signature": "(path: str)",
              "docstring": {
                "summary": "Removes a file if it exists as file.",
                "description": "Removes a file if it exists as file.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "path",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "getCwd": {
              "name": "getCwd",
              "kind": "function",
              "signature": "()",
              "docstring": {
                "summary": "Get current directory.",
                "description": "Get current directory.\n\nReturns\n-------\nstring\n    The current directory.",
                "parsed": []
              },
              "parameters": [],
              "returns": {
                "type": "str"
              },
              "decorators": []
            },
            "getLocation": {
              "name": "getLocation",
              "kind": "function",
              "signature": "(targetDir: str | None = None)",
              "docstring": {
                "summary": "Get back-end, org, repo, relative of directory.",
                "description": "Get back-end, org, repo, relative of directory.\n\nParameters\n----------\ntargetDir: string, optional None\n    If None, we take the current directory.\n    Otherwise, if it starts with a `/` we take it as the absolute\n    target directory.\n    Otherwise, we append it to the absolute path of the current directory,\n    with a `/` in between.\n\nWe assume the target directory is somewhere inside\n\n`~/backend/org/repo`\n\nIf it is immediately inside this, we set `relative` to `\"\"`.\n\nIf it is deeper down, we assume the reference directory is the parent of the\ncurrent directory, and the path of this parent, relative to the repo directory\ngoes into the `relative` component, preceded with a backslash if it is non-empty.\n\nReturns\n-------\ntuple\n    Consisting of `backend`, `org`, `repo`, `relative`.\n    `relative` is either empty or it starts with a \"/\" plus a non-empty path.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "targetDir",
                  "type": "str | None",
                  "default": "None",
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "tuple[(str | None, str | None, str | None, str | None)]"
              },
              "decorators": []
            },
            "initTree": {
              "name": "initTree",
              "kind": "function",
              "signature": "(path: str, fresh: bool = False, gentle: bool = False)",
              "docstring": {
                "summary": "Make sure a directory exists, optionally clean it.",
                "description": "Make sure a directory exists, optionally clean it.\n\nParameters\n----------\npath:\n    The directory in question. A leading `~` will be expanded to the user's\n    home directory.\n\n    If the directory does not exist, it will be created.\n\nfresh: boolean, optional False\n    If True, existing contents will be removed, more or less gently.\n\ngentle: boolean, optional False\n    When existing content is removed, only files are recursively removed, not\n    subdirectories.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "path",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "fresh",
                  "type": "bool",
                  "default": "False",
                  "kind": "positional or keyword"
                },
                {
                  "name": "gentle",
                  "type": "bool",
                  "default": "False",
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "isDir": {
              "name": "isDir",
              "kind": "function",
              "signature": "(path: str)",
              "docstring": {
                "summary": "Whether path exists and is a directory.",
                "description": "Whether path exists and is a directory.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "path",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "bool"
              },
              "decorators": []
            },
            "isFile": {
              "name": "isFile",
              "kind": "function",
              "signature": "(path: str)",
              "docstring": {
                "summary": "Whether path exists and is a file.",
                "description": "Whether path exists and is a file.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "path",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "bool"
              },
              "decorators": []
            },
            "normpath": {
              "name": "normpath",
              "kind": "function",
              "signature": "(path: str | None)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "path",
                  "type": "str | None",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "str | None"
              },
              "decorators": []
            },
            "prefixSlash": {
              "name": "prefixSlash",
              "kind": "function",
              "signature": "(path: str)",
              "docstring": {
                "summary": "Prefix a / before a path if it is non-empty and not already starts with it.",
                "description": "Prefix a / before a path if it is non-empty and not already starts with it.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "path",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "str"
              },
              "decorators": []
            },
            "readJson": {
              "name": "readJson",
              "kind": "function",
              "signature": "(text: str | None = None, plain: bool = False, asFile: str | TextIO | None = None, preferTuples: bool = False)",
              "docstring": {
                "summary": "Read a JSON file or string.",
                "description": "Read a JSON file or string.\n\nThe input data is either a text string or a file name or a file handle.\nExactly one of the optional parameters `text` and `asFile` should be `None`.\n\nParameters\n----------\ntext: string, optional None\n    The input text if it is a string.\nasFile: string | object, optional None\n    The input text if it is a file.\n    If the value of `asFile` is a string, it is taken as a file name to read.\n    Otherwise, it is taken as a file handle from which data can be read.\nplain: boolean, optional False\n    If True, it return a dictionary, otherwise it wraps the data structure\n    recursively in an AttrDict.\npreferTuples: boolean, optional False\n    If the resulting data structure is to be wrapped in an AttrDict,\n    we will represent lists as tuples.\n\nReturns\n-------\nobject\n    The resulting data structure.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "text",
                  "type": "str | None",
                  "default": "None",
                  "kind": "positional or keyword"
                },
                {
                  "name": "plain",
                  "type": "bool",
                  "default": "False",
                  "kind": "positional or keyword"
                },
                {
                  "name": "asFile",
                  "type": "str | TextIO | None",
                  "default": "None",
                  "kind": "positional or keyword"
                },
                {
                  "name": "preferTuples",
                  "type": "bool",
                  "default": "False",
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "dict[(str, Any)] | AttrDict"
              },
              "decorators": []
            },
            "readYaml": {
              "name": "readYaml",
              "kind": "function",
              "signature": "(text: str | None = None, plain: bool = False, asFile: str | TextIO | None = None, preferTuples: bool = True, preferLists: bool = True)",
              "docstring": {
                "summary": "Read a YAML file or string.",
                "description": "Read a YAML file or string.\n\nThe input data is either a text string or a file name or a file handle.\nExactly one of the optional parameters `text` and `asFile` should be `None`.\n\nParameters\n----------\ntext: string, optional None\n    The input text if it is a string.\nasFile: string | object, optional None\n    The input text if it is a file.\n    If the value of `asFile` is a string, it is taken as a file name to read.\n    Otherwise, it is taken as a file handle from which data can be read.\nplain: boolean, optional False\n    If True, it return a dictionary, otherwise it wraps the data structure\n    recursively in an AttrDict.\npreferTuples: boolean, optional False\n    If the resulting data structure is to be wrapped in an AttrDict,\n    we will represent lists as tuples.\n\nReturns\n-------\nobject\n    The resulting data structure.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "text",
                  "type": "str | None",
                  "default": "None",
                  "kind": "positional or keyword"
                },
                {
                  "name": "plain",
                  "type": "bool",
                  "default": "False",
                  "kind": "positional or keyword"
                },
                {
                  "name": "asFile",
                  "type": "str | TextIO | None",
                  "default": "None",
                  "kind": "positional or keyword"
                },
                {
                  "name": "preferTuples",
                  "type": "bool",
                  "default": "True",
                  "kind": "positional or keyword"
                },
                {
                  "name": "preferLists",
                  "type": "bool",
                  "default": "True",
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "dict[(str, Any)] | AttrDict | None"
              },
              "decorators": []
            },
            "replaceExt": {
              "name": "replaceExt",
              "kind": "function",
              "signature": "(path: str, newExt: str)",
              "docstring": {
                "summary": "Replace the extension of a path by another one. Specify it without dot.",
                "description": "Replace the extension of a path by another one. Specify it without dot.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "path",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "newExt",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "str"
              },
              "decorators": []
            },
            "setDir": {
              "name": "setDir",
              "kind": "function",
              "signature": "(obj: Any)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "obj",
                  "type": "Any",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "splitPath": {
              "name": "splitPath",
              "kind": "function",
              "signature": "(path: str)",
              "docstring": {
                "summary": "Split a file name in a directory part and a file part.",
                "description": "Split a file name in a directory part and a file part.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "path",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "tuple[(str, str)]"
              },
              "decorators": []
            },
            "str_presenter": {
              "name": "str_presenter",
              "kind": "function",
              "signature": "(dumper, data: str)",
              "docstring": {
                "summary": "configures yaml for dumping multiline strings\nRef: https://stackoverflow.com/questions/8640959",
                "description": "configures yaml for dumping multiline strings\nRef: https://stackoverflow.com/questions/8640959",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "dumper",
                  "type": "",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "data",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": ""
              },
              "decorators": []
            },
            "stripExt": {
              "name": "stripExt",
              "kind": "function",
              "signature": "(path: str)",
              "docstring": {
                "summary": "Strip the extension of a file name, if there is one.",
                "description": "Strip the extension of a file name, if there is one.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "path",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "str"
              },
              "decorators": []
            },
            "unexpanduser": {
              "name": "unexpanduser",
              "kind": "function",
              "signature": "(path: str)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "path",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "str"
              },
              "decorators": []
            },
            "writeJson": {
              "name": "writeJson",
              "kind": "function",
              "signature": "(data: Any, asFile: str | TextIO | None = None, kwargs: Any = {})",
              "docstring": {
                "summary": "Write data as JSON.",
                "description": "Write data as JSON.\n\nThe output is either delivered as string or written to a file.\n\nParameters\n----------\ndata: object\n    The input data.\nasFile: string | object, optional None\n    The output destination.\n    If `None`, the output text is delivered as the function result.\n    If the value of `asFile` is a string, it is taken as a file name to write to.\n    Otherwise, it is taken as a file handle to which text can be written.\nkwargs: dict, optional {}\n    Additional paramters for the underlying json.dump method.\n    By default, we use `indent=1, ensure_ascii=False`.\n\nReturns\n-------\nstr | void\n    If asFile is not None, the function returns None and the result is written\n    to a file. Otherwise, the result string is returned.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "data",
                  "type": "Any",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "asFile",
                  "type": "str | TextIO | None",
                  "default": "None",
                  "kind": "positional or keyword"
                },
                {
                  "name": "kwargs",
                  "type": "Any",
                  "default": "{}",
                  "kind": "variadic keyword"
                }
              ],
              "returns": {
                "type": "str | None"
              },
              "decorators": []
            },
            "writeYaml": {
              "name": "writeYaml",
              "kind": "function",
              "signature": "(data: Any, asFile: str | TextIO | None = None, sorted: bool = False)",
              "docstring": {
                "summary": "Write data as YAML.",
                "description": "Write data as YAML.\n\nThe output is either delivered as string or written to a file.\n\nParameters\n----------\ndata: object\n    The input data.\nasFile: string | object, optional None\n    The output destination.\n    If `None`, the output text is delivered as the function result.\n    If the value of `asFile` is a string, it is taken as a file name to write to.\n    Otherwise, it is taken as a file handle to which text can be written.\nsorted: boolean, optional False\n    If True, when writing out a dictionary, its keys will be sorted.\n\nReturns\n-------\nstr | void\n    If asFile is not None, the function returns None and the result is written\n    to a file. Otherwise, the result string is returned.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "data",
                  "type": "Any",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "asFile",
                  "type": "str | TextIO | None",
                  "default": "None",
                  "kind": "positional or keyword"
                },
                {
                  "name": "sorted",
                  "type": "bool",
                  "default": "False",
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "str | None"
              },
              "decorators": []
            }
          },
          "modules": {},
          "aliases": {
            "Any": {
              "name": "Any",
              "target": "typing.Any"
            },
            "AttrDict": {
              "name": "AttrDict",
              "target": "cfabric.utils.attrs.AttrDict"
            },
            "BinaryIO": {
              "name": "BinaryIO",
              "target": "typing.BinaryIO"
            },
            "GH": {
              "name": "GH",
              "target": "cfabric.core.config.GH"
            },
            "GL": {
              "name": "GL",
              "target": "cfabric.core.config.GL"
            },
            "ON_IPAD": {
              "name": "ON_IPAD",
              "target": "cfabric.core.config.ON_IPAD"
            },
            "ORG": {
              "name": "ORG",
              "target": "cfabric.core.config.ORG"
            },
            "REPO": {
              "name": "REPO",
              "target": "cfabric.core.config.REPO"
            },
            "TYPE_CHECKING": {
              "name": "TYPE_CHECKING",
              "target": "typing.TYPE_CHECKING"
            },
            "TextIO": {
              "name": "TextIO",
              "target": "typing.TextIO"
            },
            "URL_GH": {
              "name": "URL_GH",
              "target": "cfabric.core.config.URL_GH"
            },
            "URL_GH_API": {
              "name": "URL_GH_API",
              "target": "cfabric.core.config.URL_GH_API"
            },
            "URL_GH_UPLOAD": {
              "name": "URL_GH_UPLOAD",
              "target": "cfabric.core.config.URL_GH_UPLOAD"
            },
            "URL_GL": {
              "name": "URL_GL",
              "target": "cfabric.core.config.URL_GL"
            },
            "URL_GL_API": {
              "name": "URL_GL_API",
              "target": "cfabric.core.config.URL_GL_API"
            },
            "URL_GL_UPLOAD": {
              "name": "URL_GL_UPLOAD",
              "target": "cfabric.core.config.URL_GL_UPLOAD"
            },
            "URL_NB": {
              "name": "URL_NB",
              "target": "cfabric.core.config.URL_NB"
            },
            "annotations": {
              "name": "annotations",
              "target": "__future__.annotations"
            },
            "copy": {
              "name": "copy",
              "target": "shutil.copy"
            },
            "copytree": {
              "name": "copytree",
              "target": "shutil.copytree"
            },
            "deepAttrDict": {
              "name": "deepAttrDict",
              "target": "cfabric.utils.attrs.deepAttrDict"
            },
            "json": {
              "name": "json",
              "target": "json"
            },
            "os": {
              "name": "os",
              "target": "os"
            },
            "rmtree": {
              "name": "rmtree",
              "target": "shutil.rmtree"
            },
            "yaml": {
              "name": "yaml",
              "target": "yaml"
            }
          }
        },
        "helpers": {
          "name": "helpers",
          "kind": "module",
          "path": "",
          "docstring": {
            "summary": "",
            "description": "",
            "sections": {}
          },
          "classes": {},
          "functions": {
            "camel": {
              "name": "camel",
              "kind": "function",
              "signature": "(name: str)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "name",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "str"
              },
              "decorators": []
            },
            "check32": {
              "name": "check32",
              "kind": "function",
              "signature": "()",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [],
              "returns": {
                "type": "tuple[(bool, str, str)]"
              },
              "decorators": []
            },
            "cleanName": {
              "name": "cleanName",
              "kind": "function",
              "signature": "(name: str)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "name",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "str"
              },
              "decorators": []
            },
            "collectFormats": {
              "name": "collectFormats",
              "kind": "function",
              "signature": "(config: dict[(str, str)])",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "config",
                  "type": "dict[(str, str)]",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "tuple[(dict[(str, tuple[(str, str, tuple[(tuple[(tuple[(str, ...)], str)], ...)])])], list[str])]"
              },
              "decorators": []
            },
            "console": {
              "name": "console",
              "kind": "function",
              "signature": "(msg: Any = (), error: bool = False, newline: bool = True, file: Any = None)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "msg",
                  "type": "Any",
                  "default": "()",
                  "kind": "variadic positional"
                },
                {
                  "name": "error",
                  "type": "bool",
                  "default": "False",
                  "kind": "keyword-only"
                },
                {
                  "name": "newline",
                  "type": "bool",
                  "default": "True",
                  "kind": "keyword-only"
                },
                {
                  "name": "file",
                  "type": "Any",
                  "default": "None",
                  "kind": "keyword-only"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "deepSize": {
              "name": "deepSize",
              "kind": "function",
              "signature": "(o: Any, handlers: dict[(type, Callable[([Any], Any)])] = {'cls': 'ExprDict', 'keys': [], 'values': []}, verbose: bool = False, seen: set[int] | None = None)",
              "docstring": {
                "summary": "Returns the approximate memory footprint an object and all of its contents.",
                "description": "Returns the approximate memory footprint an object and all of its contents.\n\nAutomatically finds the contents of the following builtin containers and\ntheir subclasses:\n`tuple`, `list`, `deque`, `dict`, `set` and `frozenset`.\nTo search other containers, add handlers to iterate over their contents:\n\n```\nhandlers = {SomeContainerClass: iter,\n            OtherContainerClass: OtherContainerClass.get_elements}\n```",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "o",
                  "type": "Any",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "handlers",
                  "type": "dict[(type, Callable[([Any], Any)])]",
                  "default": {
                    "cls": "ExprDict",
                    "keys": [],
                    "values": []
                  },
                  "kind": "positional or keyword"
                },
                {
                  "name": "verbose",
                  "type": "bool",
                  "default": "False",
                  "kind": "positional or keyword"
                },
                {
                  "name": "seen",
                  "type": "set[int] | None",
                  "default": "None",
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "int"
              },
              "decorators": []
            },
            "fitemize": {
              "name": "fitemize",
              "kind": "function",
              "signature": "(value: Any)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "value",
                  "type": "Any",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "list[str]"
              },
              "decorators": []
            },
            "flattenToSet": {
              "name": "flattenToSet",
              "kind": "function",
              "signature": "(features: str | list[Any] | tuple[(Any, ...)])",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "features",
                  "type": "str | list[Any] | tuple[(Any, ...)]",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "set[str]"
              },
              "decorators": []
            },
            "formatMeta": {
              "name": "formatMeta",
              "kind": "function",
              "signature": "(featureMeta: dict[(str, dict[(str, str)])])",
              "docstring": {
                "summary": "Reorder meta data.",
                "description": "Reorder meta data.\n\nParameters\n----------\nmeta: dict\n    Dictionary of meta data: keyed by feature, valued by a dict\n    of metadata in the form of key values\n\nReturns\n-------\ndict\n    A copy of the dict but with the values for metadata keys\n    `desc` and `eg` merged under a new key `description`,\n    and the keys `desc` and `eg` deleted.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "featureMeta",
                  "type": "dict[(str, dict[(str, str)])]",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "dict[(str, dict[(str, str)])]"
              },
              "decorators": []
            },
            "getAllRealFeatures": {
              "name": "getAllRealFeatures",
              "kind": "function",
              "signature": "(api: Any)",
              "docstring": {
                "summary": "Get all configuration features and all loaded node and edge features.",
                "description": "Get all configuration features and all loaded node and edge features.\n\nExcept `omap@v-w` features.\nWhen we take volumes or collections from works,\nwe need to pass these features on.\n\nThis will exclude the computed features and the node / edge features\nthat are not loaded by default.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "api",
                  "type": "Any",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "set[str]"
              },
              "decorators": []
            },
            "htmlEsc": {
              "name": "htmlEsc",
              "kind": "function",
              "signature": "(val: Any, math: bool = False)",
              "docstring": {
                "summary": "Escape certain HTML characters by HTML entities.",
                "description": "Escape certain HTML characters by HTML entities.\n\nTo prevent them to be interpreted as HTML\nin cases where you need them literally.\n\nParameters\n----------\nval: string\n    The input value\nmath: boolean, optional False\n    Whether retain TeX notation.\n    If True, `$` is not escaped, if False, it is not escaped.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "val",
                  "type": "Any",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "math",
                  "type": "bool",
                  "default": "False",
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "str"
              },
              "decorators": []
            },
            "isClean": {
              "name": "isClean",
              "kind": "function",
              "signature": "(name: str | None)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "name",
                  "type": "str | None",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "bool"
              },
              "decorators": []
            },
            "isInt": {
              "name": "isInt",
              "kind": "function",
              "signature": "(val: Any)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "val",
                  "type": "Any",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "bool"
              },
              "decorators": []
            },
            "itemize": {
              "name": "itemize",
              "kind": "function",
              "signature": "(string: str | None, sep: str | None = None)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "string",
                  "type": "str | None",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "sep",
                  "type": "str | None",
                  "default": "None",
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "list[str]"
              },
              "decorators": []
            },
            "makeExamples": {
              "name": "makeExamples",
              "kind": "function",
              "signature": "(nodeList: list[int] | tuple[(int, ...)])",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "nodeList",
                  "type": "list[int] | tuple[(int, ...)]",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "str"
              },
              "decorators": []
            },
            "makeIndex": {
              "name": "makeIndex",
              "kind": "function",
              "signature": "(data: dict[(int, int)])",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "data",
                  "type": "dict[(int, int)]",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "dict[(int, set[int])]"
              },
              "decorators": []
            },
            "makeInverse": {
              "name": "makeInverse",
              "kind": "function",
              "signature": "(data: dict[(int, list[int] | set[int])])",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "data",
                  "type": "dict[(int, list[int] | set[int])]",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "dict[(int, set[int])]"
              },
              "decorators": []
            },
            "makeInverseVal": {
              "name": "makeInverseVal",
              "kind": "function",
              "signature": "(data: dict[(int, dict[(int, Any)])])",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "data",
                  "type": "dict[(int, dict[(int, Any)])]",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "dict[(int, dict[(int, Any)])]"
              },
              "decorators": []
            },
            "mathEsc": {
              "name": "mathEsc",
              "kind": "function",
              "signature": "(val: Any)",
              "docstring": {
                "summary": "Escape dollar signs to `<span>$</span>`.",
                "description": "Escape dollar signs to `<span>$</span>`.\n\nTo prevent them from being interpreted as math in a Jupyter notebook\nin cases where you need them literally.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "val",
                  "type": "Any",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "str"
              },
              "decorators": []
            },
            "mdEsc": {
              "name": "mdEsc",
              "kind": "function",
              "signature": "(val: Any, math: bool = False)",
              "docstring": {
                "summary": "Escape certain markdown characters.",
                "description": "Escape certain markdown characters.\n\nParameters\n----------\nval: string\n    The input value\nmath: boolean, optional False\n    Whether retain TeX notation.\n    If True, `$` is not escaped, if False, it is not escaped.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "val",
                  "type": "Any",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "math",
                  "type": "bool",
                  "default": "False",
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "str"
              },
              "decorators": []
            },
            "mdhtmlEsc": {
              "name": "mdhtmlEsc",
              "kind": "function",
              "signature": "(val: Any, math: bool = False)",
              "docstring": {
                "summary": "Escape certain Markdown characters by HTML entities or span elements.",
                "description": "Escape certain Markdown characters by HTML entities or span elements.\n\nTo prevent them to be interpreted as Markdown\nin cases where you need them literally.\n\nParameters\n----------\nval: string\n    The input value\nmath: boolean, optional False\n    Whether retain TeX notation.\n    If True, `$` is not escaped, if False, it is not escaped.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "val",
                  "type": "Any",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "math",
                  "type": "bool",
                  "default": "False",
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "str"
              },
              "decorators": []
            },
            "mergeDict": {
              "name": "mergeDict",
              "kind": "function",
              "signature": "(source: dict[(str, Any)], overrides: dict[(str, Any)])",
              "docstring": {
                "summary": "Merge overrides into a source dictionary recursively.",
                "description": "Merge overrides into a source dictionary recursively.\n\nParameters\n----------\nsource: dict\n    The source dictionary, which will be modified by the overrides.\noverrides: dict\n    The overrides, itself a dictionary.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "source",
                  "type": "dict[(str, Any)]",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "overrides",
                  "type": "dict[(str, Any)]",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "mergeDictOfSets": {
              "name": "mergeDictOfSets",
              "kind": "function",
              "signature": "(d1: dict[(Any, set[Any])], d2: dict[(Any, set[Any])])",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "d1",
                  "type": "dict[(Any, set[Any])]",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "d2",
                  "type": "dict[(Any, set[Any])]",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "nbytes": {
              "name": "nbytes",
              "kind": "function",
              "signature": "(by: int | float)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "by",
                  "type": "int | float",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "str"
              },
              "decorators": []
            },
            "pandasEsc": {
              "name": "pandasEsc",
              "kind": "function",
              "signature": "(x: Any)",
              "docstring": {
                "summary": "Escapes the character that will be used as the `pandas` quote char.",
                "description": "Escapes the character that will be used as the `pandas` quote char.\n\nThe escaping is realized by prepending a special char the quote char.\nAlso: all tab characters will be replaced by single spaces.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "x",
                  "type": "Any",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "str"
              },
              "decorators": []
            },
            "project": {
              "name": "project",
              "kind": "function",
              "signature": "(iterableOfTuples: set[tuple[(Any, ...)]] | list[tuple[(Any, ...)]], maxDimension: int)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "iterableOfTuples",
                  "type": "set[tuple[(Any, ...)]] | list[tuple[(Any, ...)]]",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "maxDimension",
                  "type": "int",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "set[Any] | set[tuple[(Any, ...)]]"
              },
              "decorators": []
            },
            "rangesFromList": {
              "name": "rangesFromList",
              "kind": "function",
              "signature": "(nodeList: list[int])",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "nodeList",
                  "type": "list[int]",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "Generator[(tuple[(int, int)], None, None)]"
              },
              "decorators": []
            },
            "rangesFromSet": {
              "name": "rangesFromSet",
              "kind": "function",
              "signature": "(nodeSet: set[int])",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "nodeSet",
                  "type": "set[int]",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "Generator[(tuple[(int, int)], None, None)]"
              },
              "decorators": []
            },
            "readCfg": {
              "name": "readCfg",
              "kind": "function",
              "signature": "(folder: str, file: str, label: str, verbose: int = 0, kwargs: Any = {})",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "folder",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "file",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "label",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "verbose",
                  "type": "int",
                  "default": "0",
                  "kind": "positional or keyword"
                },
                {
                  "name": "kwargs",
                  "type": "Any",
                  "default": "{}",
                  "kind": "variadic keyword"
                }
              ],
              "returns": {
                "type": "tuple[(bool, AttrDict | dict[(str, Any)] | None)]"
              },
              "decorators": []
            },
            "run": {
              "name": "run",
              "kind": "function",
              "signature": "(cmdline: str, workDir: str | None = None)",
              "docstring": {
                "summary": "Runs a shell command and returns all relevant info.",
                "description": "Runs a shell command and returns all relevant info.\n\nThe function runs a command-line in a shell, and returns\nwhether the command was successful, and also what the output was, separately for\nstandard error and standard output.\n\nParameters\n----------\ncmdline: string\n    The command-line to execute.\nworkDir: string, optional None\n    The working directory where the command should be executed.\n    If `None` the current directory is used.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "cmdline",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "workDir",
                  "type": "str | None",
                  "default": "None",
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "tuple[(bool, int, str, str)]"
              },
              "decorators": []
            },
            "safe_rank_key": {
              "name": "safe_rank_key",
              "kind": "function",
              "signature": "(Crank: Any)",
              "docstring": {
                "summary": "Create a sort key function that safely handles out-of-bounds nodes.",
                "description": "Create a sort key function that safely handles out-of-bounds nodes.\n\nParameters\n----------\nCrank : array-like\n    The canonical rank array (0-indexed, so node n has rank Crank[n-1])\n\nReturns\n-------\nCallable[[int], int]\n    A function that returns the rank for a node, or a large value for\n    out-of-bounds nodes (so they sort to the end).",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "Crank",
                  "type": "Any",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "Callable[([int], int)]"
              },
              "decorators": []
            },
            "setFromSpec": {
              "name": "setFromSpec",
              "kind": "function",
              "signature": "(spec: str)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "spec",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "set[int]"
              },
              "decorators": []
            },
            "setFromStr": {
              "name": "setFromStr",
              "kind": "function",
              "signature": "(x: str | None)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "x",
                  "type": "str | None",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "set[str]"
              },
              "decorators": []
            },
            "setFromValue": {
              "name": "setFromValue",
              "kind": "function",
              "signature": "(x: Any, asInt: bool = False)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "x",
                  "type": "Any",
                  "default": null,
                  "kind": "positional or keyword"
                },
                {
                  "name": "asInt",
                  "type": "bool",
                  "default": "False",
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "set[Any]"
              },
              "decorators": []
            },
            "specFromRanges": {
              "name": "specFromRanges",
              "kind": "function",
              "signature": "(ranges: list[tuple[(int, int)]] | Generator[(tuple[(int, int)], None, None)])",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "ranges",
                  "type": "list[tuple[(int, int)]] | Generator[(tuple[(int, int)], None, None)]",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "str"
              },
              "decorators": []
            },
            "specFromRangesLogical": {
              "name": "specFromRangesLogical",
              "kind": "function",
              "signature": "(ranges: list[tuple[(int, int)]] | Generator[(tuple[(int, int)], None, None)])",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "ranges",
                  "type": "list[tuple[(int, int)]] | Generator[(tuple[(int, int)], None, None)]",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "list[int | list[int]]"
              },
              "decorators": []
            },
            "tfFromValue": {
              "name": "tfFromValue",
              "kind": "function",
              "signature": "(val: str | int)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "val",
                  "type": "str | int",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "str | None"
              },
              "decorators": []
            },
            "tsvEsc": {
              "name": "tsvEsc",
              "kind": "function",
              "signature": "(x: Any)",
              "docstring": {
                "summary": "Escapes a double quote for strings to be included in TSV data.",
                "description": "Escapes a double quote for strings to be included in TSV data.\n\nOnly `\"` and `'` at the beginning of the string are escaped.\nThe escaping is realized by putting a backslash at the beginning.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "x",
                  "type": "Any",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "str"
              },
              "decorators": []
            },
            "utcnow": {
              "name": "utcnow",
              "kind": "function",
              "signature": "()",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [],
              "returns": {
                "type": "dt"
              },
              "decorators": []
            },
            "valueFromTf": {
              "name": "valueFromTf",
              "kind": "function",
              "signature": "(tf: str)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "tf",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "str"
              },
              "decorators": []
            },
            "var": {
              "name": "var",
              "kind": "function",
              "signature": "(envVar: str)",
              "docstring": {
                "summary": "Retrieves the value of an environment variable.",
                "description": "Retrieves the value of an environment variable.\n\nParameters\n----------\nenvVar: string\n    The name of the environment variable.\n\nReturns\n-------\nstring or void\n    The value of the environment variable if it exists, otherwise `None`.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "envVar",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "str | None"
              },
              "decorators": []
            },
            "versionSort": {
              "name": "versionSort",
              "kind": "function",
              "signature": "(x: str)",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "x",
                  "type": "str",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "tuple[(tuple[(int, str, str)], ...)]"
              },
              "decorators": []
            },
            "wrapMessages": {
              "name": "wrapMessages",
              "kind": "function",
              "signature": "(messages: str | list[str | tuple[(bool, bool, str)]])",
              "docstring": {
                "summary": "",
                "description": "",
                "sections": {}
              },
              "parameters": [
                {
                  "name": "messages",
                  "type": "str | list[str | tuple[(bool, bool, str)]]",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "tuple[(bool, str)]"
              },
              "decorators": []
            },
            "xmlEsc": {
              "name": "xmlEsc",
              "kind": "function",
              "signature": "(val: Any)",
              "docstring": {
                "summary": "Escape certain HTML characters by XML entities.",
                "description": "Escape certain HTML characters by XML entities.\n\nTo prevent them to be interpreted as XML\nin cases where you need them literally.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "val",
                  "type": "Any",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "str"
              },
              "decorators": []
            }
          },
          "modules": {},
          "aliases": {
            "Any": {
              "name": "Any",
              "target": "typing.Any"
            },
            "AttrDict": {
              "name": "AttrDict",
              "target": "cfabric.utils.attrs.AttrDict"
            },
            "Callable": {
              "name": "Callable",
              "target": "typing.Callable"
            },
            "CalledProcessError": {
              "name": "CalledProcessError",
              "target": "subprocess.CalledProcessError"
            },
            "Generator": {
              "name": "Generator",
              "target": "typing.Generator"
            },
            "Match": {
              "name": "Match",
              "target": "re.Match"
            },
            "OMAP": {
              "name": "OMAP",
              "target": "cfabric.core.config.OMAP"
            },
            "TYPE_CHECKING": {
              "name": "TYPE_CHECKING",
              "target": "typing.TYPE_CHECKING"
            },
            "annotations": {
              "name": "annotations",
              "target": "__future__.annotations"
            },
            "chain": {
              "name": "chain",
              "target": "itertools.chain"
            },
            "deque": {
              "name": "deque",
              "target": "collections.deque"
            },
            "dt": {
              "name": "dt",
              "target": "datetime.datetime"
            },
            "getsizeof": {
              "name": "getsizeof",
              "target": "sys.getsizeof"
            },
            "os": {
              "name": "os",
              "target": "os"
            },
            "re": {
              "name": "re",
              "target": "re"
            },
            "readYaml": {
              "name": "readYaml",
              "target": "cfabric.utils.files.readYaml"
            },
            "run_cmd": {
              "name": "run_cmd",
              "target": "subprocess.run"
            },
            "stderr": {
              "name": "stderr",
              "target": "sys.stderr"
            },
            "sys": {
              "name": "sys",
              "target": "sys"
            },
            "timezone": {
              "name": "timezone",
              "target": "datetime.timezone"
            },
            "ux": {
              "name": "ux",
              "target": "cfabric.utils.files.unexpanduser"
            }
          }
        },
        "logging": {
          "name": "logging",
          "kind": "module",
          "path": "",
          "docstring": {
            "summary": "# Logging configuration for cfabric.",
            "description": "# Logging configuration for cfabric.\n\nThis module provides logging level constants and configuration utilities\nfor the cfabric library. Uses standard Python logging with output to stderr.",
            "parsed": []
          },
          "classes": {},
          "functions": {
            "configure_logging": {
              "name": "configure_logging",
              "kind": "function",
              "signature": "(silent: str = {'cls': 'ExprName', 'member': None, 'name': 'SILENT_D'})",
              "docstring": {
                "summary": "Configure the cfabric logger.",
                "description": "Configure the cfabric logger.\n\nSets up the root cfabric logger with a stderr handler.\n\nParameters\n----------\nsilent : str\n    Verbosity level: \"verbose\", \"auto\", \"terse\", or \"deep\"",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "silent",
                  "type": "str",
                  "default": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "SILENT_D"
                  },
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "set_logging_level": {
              "name": "set_logging_level",
              "kind": "function",
              "signature": "(silent: str = {'cls': 'ExprName', 'member': None, 'name': 'SILENT_D'})",
              "docstring": {
                "summary": "Set the logging level for cfabric.",
                "description": "Set the logging level for cfabric.\n\nParameters\n----------\nsilent : str\n    Verbosity level: \"verbose\", \"auto\", \"terse\", or \"deep\"",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "silent",
                  "type": "str",
                  "default": {
                    "cls": "ExprName",
                    "member": null,
                    "name": "SILENT_D"
                  },
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "None"
              },
              "decorators": []
            },
            "silentConvert": {
              "name": "silentConvert",
              "kind": "function",
              "signature": "(arg: str | bool | None)",
              "docstring": {
                "summary": "Convert silent parameter to canonical string form.",
                "description": "Convert silent parameter to canonical string form.\n\nAccepts str, bool, or None and always returns a valid silent level string.",
                "parsed": []
              },
              "parameters": [
                {
                  "name": "arg",
                  "type": "str | bool | None",
                  "default": null,
                  "kind": "positional or keyword"
                }
              ],
              "returns": {
                "type": "str"
              },
              "decorators": []
            }
          },
          "modules": {},
          "aliases": {
            "annotations": {
              "name": "annotations",
              "target": "__future__.annotations"
            },
            "logging": {
              "name": "logging",
              "target": "logging"
            },
            "sys": {
              "name": "sys",
              "target": "sys"
            }
          }
        }
      },
      "aliases": {
        "AttrDict": {
          "name": "AttrDict",
          "target": "cfabric.utils.attrs.AttrDict"
        },
        "DEEP": {
          "name": "DEEP",
          "target": "cfabric.utils.logging.DEEP"
        },
        "LOCATIONS": {
          "name": "LOCATIONS",
          "target": "cfabric.utils.files.LOCATIONS"
        },
        "SILENT_D": {
          "name": "SILENT_D",
          "target": "cfabric.utils.logging.SILENT_D"
        },
        "check32": {
          "name": "check32",
          "target": "cfabric.utils.helpers.check32"
        },
        "collectFormats": {
          "name": "collectFormats",
          "target": "cfabric.utils.helpers.collectFormats"
        },
        "configure_logging": {
          "name": "configure_logging",
          "target": "cfabric.utils.logging.configure_logging"
        },
        "console": {
          "name": "console",
          "target": "cfabric.utils.helpers.console"
        },
        "deepSize": {
          "name": "deepSize",
          "target": "cfabric.utils.helpers.deepSize"
        },
        "deepdict": {
          "name": "deepdict",
          "target": "cfabric.utils.attrs.deepdict"
        },
        "dirExists": {
          "name": "dirExists",
          "target": "cfabric.utils.files.dirExists"
        },
        "expandDir": {
          "name": "expandDir",
          "target": "cfabric.utils.files.expandDir"
        },
        "expanduser": {
          "name": "expanduser",
          "target": "cfabric.utils.files.expanduser"
        },
        "fitemize": {
          "name": "fitemize",
          "target": "cfabric.utils.helpers.fitemize"
        },
        "flattenToSet": {
          "name": "flattenToSet",
          "target": "cfabric.utils.helpers.flattenToSet"
        },
        "itemize": {
          "name": "itemize",
          "target": "cfabric.utils.helpers.itemize"
        },
        "makeExamples": {
          "name": "makeExamples",
          "target": "cfabric.utils.helpers.makeExamples"
        },
        "normpath": {
          "name": "normpath",
          "target": "cfabric.utils.files.normpath"
        },
        "readArgs": {
          "name": "readArgs",
          "target": "cfabric.utils.cli.readArgs"
        },
        "scanDir": {
          "name": "scanDir",
          "target": "cfabric.utils.files.scanDir"
        },
        "setDir": {
          "name": "setDir",
          "target": "cfabric.utils.files.setDir"
        },
        "silentConvert": {
          "name": "silentConvert",
          "target": "cfabric.utils.logging.silentConvert"
        },
        "splitExt": {
          "name": "splitExt",
          "target": "cfabric.utils.files.splitExt"
        },
        "unexpanduser": {
          "name": "unexpanduser",
          "target": "cfabric.utils.files.unexpanduser"
        }
      }
    }
  },
  "aliases": {
    "BANNER": {
      "name": "BANNER",
      "target": "cfabric.core.config.BANNER"
    },
    "CorpusInfo": {
      "name": "CorpusInfo",
      "target": "cfabric.results.CorpusInfo"
    },
    "Fabric": {
      "name": "Fabric",
      "target": "cfabric.core.fabric.Fabric"
    },
    "FeatureInfo": {
      "name": "FeatureInfo",
      "target": "cfabric.results.FeatureInfo"
    },
    "NAME": {
      "name": "NAME",
      "target": "cfabric.core.config.NAME"
    },
    "NodeInfo": {
      "name": "NodeInfo",
      "target": "cfabric.results.NodeInfo"
    },
    "NodeList": {
      "name": "NodeList",
      "target": "cfabric.results.NodeList"
    },
    "SearchResult": {
      "name": "SearchResult",
      "target": "cfabric.results.SearchResult"
    },
    "VERSION": {
      "name": "VERSION",
      "target": "cfabric.core.config.VERSION"
    },
    "download": {
      "name": "download",
      "target": "cfabric.downloader.download"
    },
    "get_cache_dir": {
      "name": "get_cache_dir",
      "target": "cfabric.downloader.get_cache_dir"
    },
    "list_corpora": {
      "name": "list_corpora",
      "target": "cfabric.downloader.list_corpora"
    }
  }
}